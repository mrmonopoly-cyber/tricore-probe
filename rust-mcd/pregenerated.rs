/* automatically generated by rust-bindgen 0.63.0 */

pub const _VCRT_COMPILER_PREPROCESSOR : u32 = 1 ; pub const _SAL_VERSION : u32 = 20 ; pub const __SAL_H_VERSION : u32 = 180000000 ; pub const _USE_DECLSPECS_FOR_SAL : u32 = 0 ; pub const _USE_ATTRIBUTES_FOR_SAL : u32 = 0 ; pub const _CRT_PACKING : u32 = 8 ; pub const _HAS_EXCEPTIONS : u32 = 1 ; pub const _STL_LANG : u32 = 0 ; pub const _HAS_CXX17 : u32 = 0 ; pub const _HAS_CXX20 : u32 = 0 ; pub const _HAS_NODISCARD : u32 = 0 ; pub const WCHAR_MIN : u32 = 0 ; pub const WCHAR_MAX : u32 = 65535 ; pub const WINT_MIN : u32 = 0 ; pub const WINT_MAX : u32 = 65535 ; pub const FALSE : u32 = 0 ; pub const TRUE : u32 = 1 ; pub const REVISION_STRING : & [u8 ; 12usize] = b"$Rev: 156 $\0" ; pub const _ARGMAX : u32 = 100 ; pub const _CRT_INT_MAX : u32 = 2147483647 ; pub const _ARM_WINAPI_PARTITION_DESKTOP_SDK_AVAILABLE : u32 = 0 ; pub const _CRT_BUILD_DESKTOP_APP : u32 = 1 ; pub const __STDC_SECURE_LIB__ : u32 = 200411 ; pub const __GOT_SECURE_LIB__ : u32 = 200411 ; pub const __STDC_WANT_SECURE_LIB__ : u32 = 1 ; pub const _SECURECRT_FILL_BUFFER_PATTERN : u32 = 254 ; pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES : u32 = 0 ; pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT : u32 = 0 ; pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES : u32 = 1 ; pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY : u32 = 0 ; pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY : u32 = 0 ; pub const _MAX_ITOSTR_BASE16_COUNT : u32 = 9 ; pub const _MAX_ITOSTR_BASE10_COUNT : u32 = 12 ; pub const _MAX_ITOSTR_BASE8_COUNT : u32 = 12 ; pub const _MAX_ITOSTR_BASE2_COUNT : u32 = 33 ; pub const _MAX_LTOSTR_BASE16_COUNT : u32 = 9 ; pub const _MAX_LTOSTR_BASE10_COUNT : u32 = 12 ; pub const _MAX_LTOSTR_BASE8_COUNT : u32 = 12 ; pub const _MAX_LTOSTR_BASE2_COUNT : u32 = 33 ; pub const _MAX_ULTOSTR_BASE16_COUNT : u32 = 9 ; pub const _MAX_ULTOSTR_BASE10_COUNT : u32 = 11 ; pub const _MAX_ULTOSTR_BASE8_COUNT : u32 = 12 ; pub const _MAX_ULTOSTR_BASE2_COUNT : u32 = 33 ; pub const _MAX_I64TOSTR_BASE16_COUNT : u32 = 17 ; pub const _MAX_I64TOSTR_BASE10_COUNT : u32 = 21 ; pub const _MAX_I64TOSTR_BASE8_COUNT : u32 = 23 ; pub const _MAX_I64TOSTR_BASE2_COUNT : u32 = 65 ; pub const _MAX_U64TOSTR_BASE16_COUNT : u32 = 17 ; pub const _MAX_U64TOSTR_BASE10_COUNT : u32 = 21 ; pub const _MAX_U64TOSTR_BASE8_COUNT : u32 = 23 ; pub const _MAX_U64TOSTR_BASE2_COUNT : u32 = 65 ; pub const CHAR_BIT : u32 = 8 ; pub const SCHAR_MIN : i32 = - 128 ; pub const SCHAR_MAX : u32 = 127 ; pub const UCHAR_MAX : u32 = 255 ; pub const CHAR_MIN : i32 = - 128 ; pub const CHAR_MAX : u32 = 127 ; pub const MB_LEN_MAX : u32 = 5 ; pub const SHRT_MIN : i32 = - 32768 ; pub const SHRT_MAX : u32 = 32767 ; pub const USHRT_MAX : u32 = 65535 ; pub const INT_MIN : i32 = - 2147483648 ; pub const INT_MAX : u32 = 2147483647 ; pub const UINT_MAX : u32 = 4294967295 ; pub const LONG_MIN : i32 = - 2147483648 ; pub const LONG_MAX : u32 = 2147483647 ; pub const ULONG_MAX : u32 = 4294967295 ; pub const EXIT_SUCCESS : u32 = 0 ; pub const EXIT_FAILURE : u32 = 1 ; pub const _WRITE_ABORT_MSG : u32 = 1 ; pub const _CALL_REPORTFAULT : u32 = 2 ; pub const _OUT_TO_DEFAULT : u32 = 0 ; pub const _OUT_TO_STDERR : u32 = 1 ; pub const _OUT_TO_MSGBOX : u32 = 2 ; pub const _REPORT_ERRMODE : u32 = 3 ; pub const RAND_MAX : u32 = 32767 ; pub const _CVTBUFSIZE : u32 = 349 ; pub const _MAX_PATH : u32 = 260 ; pub const _MAX_DRIVE : u32 = 3 ; pub const _MAX_DIR : u32 = 256 ; pub const _MAX_FNAME : u32 = 256 ; pub const _MAX_EXT : u32 = 256 ; pub const _MAX_ENV : u32 = 32767 ; pub const MCD_API_VER_MAJOR : u32 = 1 ; pub const MCD_API_VER_MINOR : u32 = 1 ; pub const MCD_API_VER_AUTHOR : & [u8 ; 15usize] = b"SPRINT Release\0" ; pub const MCD_HOSTNAME_LEN : u32 = 64 ; pub const MCD_REG_NAME_LEN : u32 = 32 ; pub const MCD_MEM_SPACE_NAME_LEN : u32 = 32 ; pub const MCD_MEM_BLOCK_NAME_LEN : u32 = 32 ; pub const MCD_MEM_BLOCK_NOPARENT : u32 = 0 ; pub const MCD_MEM_AUSIZE_NUM : u32 = 8 ; pub const MCD_INFO_STR_LEN : u32 = 256 ; pub const MCD_KEY_LEN : u32 = 64 ; pub const MCD_UNIQUE_NAME_LEN : u32 = 64 ; pub const MCD_MAX_TRIGS : u32 = 32 ; pub const MCD_API_IMP_VENDOR_LEN : u32 = 32 ; pub const MCD_CHL_NUM_MAX : u32 = 32 ; pub const MCD_CHL_LOWEST_PRIORITY : u32 = 15 ; pub const MCD_TX_NUM_MAX : u32 = 64 ; pub const MCD_GUARANTEED_MIN_PAYLOAD : u32 = 16384 ; pub const MCD_CORE_MODE_NAME_LEN : u32 = 32 ; pub type va_list = * mut :: std :: os :: raw :: c_char ; pub type __vcrt_bool = bool ; pub type wchar_t = :: std :: os :: raw :: c_ushort ; extern "C" { pub static mut __security_cookie : usize ; } pub type int_least8_t = :: std :: os :: raw :: c_schar ; pub type int_least16_t = :: std :: os :: raw :: c_short ; pub type int_least32_t = :: std :: os :: raw :: c_int ; pub type int_least64_t = :: std :: os :: raw :: c_longlong ; pub type uint_least8_t = :: std :: os :: raw :: c_uchar ; pub type uint_least16_t = :: std :: os :: raw :: c_ushort ; pub type uint_least32_t = :: std :: os :: raw :: c_uint ; pub type uint_least64_t = :: std :: os :: raw :: c_ulonglong ; pub type int_fast8_t = :: std :: os :: raw :: c_schar ; pub type int_fast16_t = :: std :: os :: raw :: c_int ; pub type int_fast32_t = :: std :: os :: raw :: c_int ; pub type int_fast64_t = :: std :: os :: raw :: c_longlong ; pub type uint_fast8_t = :: std :: os :: raw :: c_uchar ; pub type uint_fast16_t = :: std :: os :: raw :: c_uint ; pub type uint_fast32_t = :: std :: os :: raw :: c_uint ; pub type uint_fast64_t = :: std :: os :: raw :: c_ulonglong ; pub type intmax_t = :: std :: os :: raw :: c_longlong ; pub type uintmax_t = :: std :: os :: raw :: c_ulonglong ; pub type mcd_char_t = :: std :: os :: raw :: c_char ; pub type mcd_bool_t = u32 ; pub type __crt_bool = bool ; pub type errno_t = :: std :: os :: raw :: c_int ; pub type wint_t = :: std :: os :: raw :: c_ushort ; pub type wctype_t = :: std :: os :: raw :: c_ushort ; pub type __time32_t = :: std :: os :: raw :: c_long ; pub type __time64_t = :: std :: os :: raw :: c_longlong ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct __crt_locale_data_public { pub _locale_pctype : * const :: std :: os :: raw :: c_ushort , pub _locale_mb_cur_max : :: std :: os :: raw :: c_int , pub _locale_lc_codepage : :: std :: os :: raw :: c_uint , } # [test] fn bindgen_test_layout___crt_locale_data_public () { const UNINIT : :: std :: mem :: MaybeUninit < __crt_locale_data_public > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < __crt_locale_data_public > () , 16usize , concat ! ("Size of: " , stringify ! (__crt_locale_data_public))) ; assert_eq ! (:: std :: mem :: align_of :: < __crt_locale_data_public > () , 8usize , concat ! ("Alignment of " , stringify ! (__crt_locale_data_public))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . _locale_pctype) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (__crt_locale_data_public) , "::" , stringify ! (_locale_pctype))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . _locale_mb_cur_max) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (__crt_locale_data_public) , "::" , stringify ! (_locale_mb_cur_max))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . _locale_lc_codepage) as usize - ptr as usize } , 12usize , concat ! ("Offset of field: " , stringify ! (__crt_locale_data_public) , "::" , stringify ! (_locale_lc_codepage))) ; } impl Default for __crt_locale_data_public { fn default () -> Self { let mut s = :: std :: mem :: MaybeUninit :: < Self > :: uninit () ; unsafe { :: std :: ptr :: write_bytes (s . as_mut_ptr () , 0 , 1) ; s . assume_init () } } } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct __crt_locale_pointers { pub locinfo : * mut __crt_locale_data , pub mbcinfo : * mut __crt_multibyte_data , } # [test] fn bindgen_test_layout___crt_locale_pointers () { const UNINIT : :: std :: mem :: MaybeUninit < __crt_locale_pointers > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < __crt_locale_pointers > () , 16usize , concat ! ("Size of: " , stringify ! (__crt_locale_pointers))) ; assert_eq ! (:: std :: mem :: align_of :: < __crt_locale_pointers > () , 8usize , concat ! ("Alignment of " , stringify ! (__crt_locale_pointers))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . locinfo) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (__crt_locale_pointers) , "::" , stringify ! (locinfo))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . mbcinfo) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (__crt_locale_pointers) , "::" , stringify ! (mbcinfo))) ; } impl Default for __crt_locale_pointers { fn default () -> Self { let mut s = :: std :: mem :: MaybeUninit :: < Self > :: uninit () ; unsafe { :: std :: ptr :: write_bytes (s . as_mut_ptr () , 0 , 1) ; s . assume_init () } } } pub type _locale_t = * mut __crt_locale_pointers ; # [repr (C)] # [derive (Debug , Default , Copy , Clone)] pub struct _Mbstatet { pub _Wchar : :: std :: os :: raw :: c_ulong , pub _Byte : :: std :: os :: raw :: c_ushort , pub _State : :: std :: os :: raw :: c_ushort , } # [test] fn bindgen_test_layout__Mbstatet () { const UNINIT : :: std :: mem :: MaybeUninit < _Mbstatet > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < _Mbstatet > () , 8usize , concat ! ("Size of: " , stringify ! (_Mbstatet))) ; assert_eq ! (:: std :: mem :: align_of :: < _Mbstatet > () , 4usize , concat ! ("Alignment of " , stringify ! (_Mbstatet))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . _Wchar) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (_Mbstatet) , "::" , stringify ! (_Wchar))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . _Byte) as usize - ptr as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (_Mbstatet) , "::" , stringify ! (_Byte))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . _State) as usize - ptr as usize } , 6usize , concat ! ("Offset of field: " , stringify ! (_Mbstatet) , "::" , stringify ! (_State))) ; } pub type mbstate_t = _Mbstatet ; pub type time_t = __time64_t ; pub type rsize_t = usize ; pub type _onexit_t = :: std :: option :: Option < unsafe extern "C" fn () -> :: std :: os :: raw :: c_int > ; pub type _purecall_handler = :: std :: option :: Option < unsafe extern "C" fn () > ; pub type _invalid_parameter_handler = :: std :: option :: Option < unsafe extern "C" fn (arg1 : * const wchar_t , arg2 : * const wchar_t , arg3 : * const wchar_t , arg4 : :: std :: os :: raw :: c_uint , arg5 : usize) > ; # [repr (C)] # [derive (Debug , Default , Copy , Clone)] pub struct _div_t { pub quot : :: std :: os :: raw :: c_int , pub rem : :: std :: os :: raw :: c_int , } # [test] fn bindgen_test_layout__div_t () { const UNINIT : :: std :: mem :: MaybeUninit < _div_t > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < _div_t > () , 8usize , concat ! ("Size of: " , stringify ! (_div_t))) ; assert_eq ! (:: std :: mem :: align_of :: < _div_t > () , 4usize , concat ! ("Alignment of " , stringify ! (_div_t))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . quot) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (_div_t) , "::" , stringify ! (quot))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . rem) as usize - ptr as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (_div_t) , "::" , stringify ! (rem))) ; } pub type div_t = _div_t ; # [repr (C)] # [derive (Debug , Default , Copy , Clone)] pub struct _ldiv_t { pub quot : :: std :: os :: raw :: c_long , pub rem : :: std :: os :: raw :: c_long , } # [test] fn bindgen_test_layout__ldiv_t () { const UNINIT : :: std :: mem :: MaybeUninit < _ldiv_t > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < _ldiv_t > () , 8usize , concat ! ("Size of: " , stringify ! (_ldiv_t))) ; assert_eq ! (:: std :: mem :: align_of :: < _ldiv_t > () , 4usize , concat ! ("Alignment of " , stringify ! (_ldiv_t))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . quot) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (_ldiv_t) , "::" , stringify ! (quot))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . rem) as usize - ptr as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (_ldiv_t) , "::" , stringify ! (rem))) ; } pub type ldiv_t = _ldiv_t ; # [repr (C)] # [derive (Debug , Default , Copy , Clone)] pub struct _lldiv_t { pub quot : :: std :: os :: raw :: c_longlong , pub rem : :: std :: os :: raw :: c_longlong , } # [test] fn bindgen_test_layout__lldiv_t () { const UNINIT : :: std :: mem :: MaybeUninit < _lldiv_t > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < _lldiv_t > () , 16usize , concat ! ("Size of: " , stringify ! (_lldiv_t))) ; assert_eq ! (:: std :: mem :: align_of :: < _lldiv_t > () , 8usize , concat ! ("Alignment of " , stringify ! (_lldiv_t))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . quot) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (_lldiv_t) , "::" , stringify ! (quot))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . rem) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (_lldiv_t) , "::" , stringify ! (rem))) ; } pub type lldiv_t = _lldiv_t ; # [repr (C)] # [derive (Debug , Default , Copy , Clone)] pub struct _LDOUBLE { pub ld : [:: std :: os :: raw :: c_uchar ; 10usize] , } # [test] fn bindgen_test_layout__LDOUBLE () { const UNINIT : :: std :: mem :: MaybeUninit < _LDOUBLE > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < _LDOUBLE > () , 10usize , concat ! ("Size of: " , stringify ! (_LDOUBLE))) ; assert_eq ! (:: std :: mem :: align_of :: < _LDOUBLE > () , 1usize , concat ! ("Alignment of " , stringify ! (_LDOUBLE))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . ld) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (_LDOUBLE) , "::" , stringify ! (ld))) ; } # [repr (C)] # [derive (Debug , Default , Copy , Clone)] pub struct _CRT_DOUBLE { pub x : f64 , } # [test] fn bindgen_test_layout__CRT_DOUBLE () { const UNINIT : :: std :: mem :: MaybeUninit < _CRT_DOUBLE > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < _CRT_DOUBLE > () , 8usize , concat ! ("Size of: " , stringify ! (_CRT_DOUBLE))) ; assert_eq ! (:: std :: mem :: align_of :: < _CRT_DOUBLE > () , 8usize , concat ! ("Alignment of " , stringify ! (_CRT_DOUBLE))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . x) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (_CRT_DOUBLE) , "::" , stringify ! (x))) ; } # [repr (C)] # [derive (Debug , Default , Copy , Clone)] pub struct _CRT_FLOAT { pub f : f32 , } # [test] fn bindgen_test_layout__CRT_FLOAT () { const UNINIT : :: std :: mem :: MaybeUninit < _CRT_FLOAT > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < _CRT_FLOAT > () , 4usize , concat ! ("Size of: " , stringify ! (_CRT_FLOAT))) ; assert_eq ! (:: std :: mem :: align_of :: < _CRT_FLOAT > () , 4usize , concat ! ("Alignment of " , stringify ! (_CRT_FLOAT))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . f) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (_CRT_FLOAT) , "::" , stringify ! (f))) ; } # [repr (C)] # [derive (Debug , Default , Copy , Clone)] pub struct _LONGDOUBLE { pub x : f64 , } # [test] fn bindgen_test_layout__LONGDOUBLE () { const UNINIT : :: std :: mem :: MaybeUninit < _LONGDOUBLE > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < _LONGDOUBLE > () , 8usize , concat ! ("Size of: " , stringify ! (_LONGDOUBLE))) ; assert_eq ! (:: std :: mem :: align_of :: < _LONGDOUBLE > () , 8usize , concat ! ("Alignment of " , stringify ! (_LONGDOUBLE))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . x) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (_LONGDOUBLE) , "::" , stringify ! (x))) ; } # [repr (C)] # [derive (Debug , Default , Copy , Clone)] pub struct _LDBL12 { pub ld12 : [:: std :: os :: raw :: c_uchar ; 12usize] , } # [test] fn bindgen_test_layout__LDBL12 () { const UNINIT : :: std :: mem :: MaybeUninit < _LDBL12 > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < _LDBL12 > () , 12usize , concat ! ("Size of: " , stringify ! (_LDBL12))) ; assert_eq ! (:: std :: mem :: align_of :: < _LDBL12 > () , 1usize , concat ! ("Alignment of " , stringify ! (_LDBL12))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . ld12) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (_LDBL12) , "::" , stringify ! (ld12))) ; } # [doc = " \\brief Enumeration type defining the action a calling function has to take after an MCD API function call.\n\nThe calling function has to evaluate the return value of an MCD API function call\nin order to check its success. If the function returned with an error an appropriate\naction has to be taken as defined by the return value.\nAll MCD API functions return a value of type \\ref mcd_return_et. The calling function\nhas to decide the further proceeding based on it.\n\nA few return codes have been reserved for future API use and must not be used. Any\nfurther value can be used for customized actions. All of these user defined actions\nneed to have values between \\c MCD_RET_ACT_CUSTOM_LO and \\c MCD_RET_ACT_CUSTOM_HI."] pub type mcd_return_et = u32 ; # [doc = "< No special action required."] pub const MCD_RET_ACT_NONE : _bindgen_ty_1 = 0 ; # [doc = "< Try to call the function again."] pub const MCD_RET_ACT_AGAIN : _bindgen_ty_1 = 1 ; # [doc = "< Handle the event or events."] pub const MCD_RET_ACT_HANDLE_EVENT : _bindgen_ty_1 = 2 ; # [doc = "< Handle the error."] pub const MCD_RET_ACT_HANDLE_ERROR : _bindgen_ty_1 = 3 ; # [doc = "< Begin Range: Action reserved for future API use."] pub const MCD_RET_ACT_RESERVED_LO : _bindgen_ty_1 = 4 ; # [doc = "< End   Range: Action reserved for future API use."] pub const MCD_RET_ACT_RESERVED_HI : _bindgen_ty_1 = 32768 ; # [doc = "< Begin Range: For user defined actions."] pub const MCD_RET_ACT_CUSTOM_LO : _bindgen_ty_1 = 65536 ; # [doc = "< End   Range: For user defined actions."] pub const MCD_RET_ACT_CUSTOM_HI : _bindgen_ty_1 = 1073741824 ; pub type _bindgen_ty_1 = :: std :: os :: raw :: c_int ; # [doc = " \\brief Enumeration type defining the detailed error codes that can be returned by an MCD API function call.\n\nThe calling function has to evaluate the return value of an MCD API function call\nin order to check its success. If the function returned with an error an appropriate\naction has to be taken as defined by the return value.\nAll MCD API functions return a value of type \\ref mcd_return_et. If the returned value\nindicates an error, the user has to retrieve the detailed information on the occurred\nerror by calling \\ref mcd_qry_error_info_f(). The following enumeration is part of this\ninformation and describes the detailed error codes.\n\nThe enumeration's values can be subdivided into the following categories:\n- GENERAL       (0x0000-0x0FFF)         : These errors can be returned by any MCD API function call.\n- API_SPECIFIC  (0x1000-0x10000000)     : These errors are specific to certain MCD API function calls.\nSome of them may be valid for multiple MCD API function calls.\n- CUSTOM        (0x10000000-0x7FFFFFFF) : These error codes can be defined by the user and carry user\ndefined semantics."] pub type mcd_error_code_et = u32 ; # [doc = "< No error."] pub const MCD_ERR_NONE : _bindgen_ty_2 = 0 ; # [doc = "< Called function is not implemented."] pub const MCD_ERR_FN_UNIMPLEMENTED : _bindgen_ty_2 = 256 ; # [doc = "< MCD API not correctly used."] pub const MCD_ERR_USAGE : _bindgen_ty_2 = 257 ; # [doc = "< Passed invalid parameter."] pub const MCD_ERR_PARAM : _bindgen_ty_2 = 258 ; # [doc = "< Server connection error."] pub const MCD_ERR_CONNECTION : _bindgen_ty_2 = 512 ; # [doc = "< Function call timed out."] pub const MCD_ERR_TIMED_OUT : _bindgen_ty_2 = 513 ; # [doc = "< General error."] pub const MCD_ERR_GENERAL : _bindgen_ty_2 = 3840 ; # [doc = "< String to return is longer than the provided character array."] pub const MCD_ERR_RESULT_TOO_LONG : _bindgen_ty_2 = 4096 ; # [doc = "< Could not start server."] pub const MCD_ERR_COULD_NOT_START_SERVER : _bindgen_ty_2 = 4352 ; # [doc = "< Server is locked."] pub const MCD_ERR_SERVER_LOCKED : _bindgen_ty_2 = 4353 ; # [doc = "< No memory spaces defined."] pub const MCD_ERR_NO_MEM_SPACES : _bindgen_ty_2 = 5121 ; # [doc = "< No memory blocks defined for the requested memory space."] pub const MCD_ERR_NO_MEM_BLOCKS : _bindgen_ty_2 = 5122 ; # [doc = "< No memory space with requested ID exists."] pub const MCD_ERR_MEM_SPACE_ID : _bindgen_ty_2 = 5136 ; # [doc = "< No register groups defined."] pub const MCD_ERR_NO_REG_GROUPS : _bindgen_ty_2 = 5184 ; # [doc = "< No register group with requested ID exists."] pub const MCD_ERR_REG_GROUP_ID : _bindgen_ty_2 = 5185 ; # [doc = "< Register is not a compound register."] pub const MCD_ERR_REG_NOT_COMPOUND : _bindgen_ty_2 = 5186 ; # [doc = "< Error retrieving overlay information."] pub const MCD_ERR_OVERLAYS : _bindgen_ty_2 = 5376 ; # [doc = "< Cannot access device (power-down, reset active, etc.)."] pub const MCD_ERR_DEVICE_ACCESS : _bindgen_ty_2 = 6400 ; # [doc = "< Device is locked."] pub const MCD_ERR_DEVICE_LOCKED : _bindgen_ty_2 = 6401 ; # [doc = "< Read transaction of transaction list has failed."] pub const MCD_ERR_TXLIST_READ : _bindgen_ty_2 = 8448 ; # [doc = "< Write transaction of transaction list has failed."] pub const MCD_ERR_TXLIST_WRITE : _bindgen_ty_2 = 8449 ; # [doc = "< Other error (no R/W failure) for a transaction of the\ntransaction list."] pub const MCD_ERR_TXLIST_TX : _bindgen_ty_2 = 8450 ; # [doc = "< Requested channel type is not supported by the implementation."] pub const MCD_ERR_CHL_TYPE_NOT_SUPPORTED : _bindgen_ty_2 = 12544 ; # [doc = "< Addressed target does not support communication channels."] pub const MCD_ERR_CHL_TARGET_NOT_SUPPORTED : _bindgen_ty_2 = 12545 ; # [doc = "< Channel setup is invalid or contains unsupported attributes."] pub const MCD_ERR_CHL_SETUP : _bindgen_ty_2 = 12546 ; # [doc = "< Sending or receiving of the last message has failed."] pub const MCD_ERR_CHL_MESSAGE_FAILED : _bindgen_ty_2 = 12608 ; # [doc = "< Trigger could not be created."] pub const MCD_ERR_TRIG_CREATE : _bindgen_ty_2 = 12800 ; # [doc = "< Error during trigger information access."] pub const MCD_ERR_TRIG_ACCESS : _bindgen_ty_2 = 12801 ; # [doc = "< Begin Range: For user defined errors."] pub const MCD_ERR_CUSTOM_LO : _bindgen_ty_2 = 268435456 ; # [doc = "< End   Range: For user defined errors."] pub const MCD_ERR_CUSTOM_HI : _bindgen_ty_2 = 2147483647 ; pub type _bindgen_ty_2 = :: std :: os :: raw :: c_int ; # [doc = " \\brief Enumeration type defining the error events that can be returned by an MCD API function call.\n\nThe calling function has to evaluate the return value of an MCD API function call\nin order to check its success. If the function returned with an error an appropriate\naction has to be taken as defined by the return value.\nAll MCD API functions return a value of type mcd_return_et. If the returned value\nindicates an event, the user has to retrieve the detailed information on the occurred\nerror by calling \\ref mcd_qry_error_info_f(). The following enumeration is part of this\ninformation and describes the detailed event codes.\n\nEvent codes are bitwise exclusive. This allows 32 different event codes. User defined\nevent codes need to have values between \\c MCD_ERR_EVT_CUSTOM_LO and \\c MCD_ERR_EVT_CUSTOM_HI.\nReserved error event codes must not be used."] pub type mcd_error_event_et = u32 ; # [doc = "< No action required due to an event."] pub const MCD_ERR_EVT_NONE : _bindgen_ty_3 = 0 ; # [doc = "< Target has been reset."] pub const MCD_ERR_EVT_RESET : _bindgen_ty_3 = 1 ; # [doc = "< Target has been a powered down."] pub const MCD_ERR_EVT_PWRDN : _bindgen_ty_3 = 2 ; # [doc = "< There has been a target hardware failure."] pub const MCD_ERR_EVT_HWFAILURE : _bindgen_ty_3 = 4 ; # [doc = "< Begin Range: Events reserved for future API use."] pub const MCD_ERR_EVT_RESERVED_LO : _bindgen_ty_3 = 8 ; # [doc = "< End   Range: Events reserved for future API use."] pub const MCD_ERR_EVT_RESERVED_HI : _bindgen_ty_3 = 32768 ; # [doc = "< Begin Range: User defined events."] pub const MCD_ERR_EVT_CUSTOM_LO : _bindgen_ty_3 = 65536 ; # [doc = "< End   Range: User defined events."] pub const MCD_ERR_EVT_CUSTOM_HI : _bindgen_ty_3 = 1073741824 ; pub type _bindgen_ty_3 = :: std :: os :: raw :: c_int ; # [doc = " \\brief Enumeration type defining the type of an address space ID.\n\nThe type of the address space ID defines the interpretation of an address space ID.\nThis type refers to the \\c addr_space_id member of \\c mcd_addr_st which is used to\nfurther extend the address information."] pub type mcd_addr_space_type_et = u32 ; # [doc = "< Address space ID is not used."] pub const MCD_NOTUSED_ID : _bindgen_ty_4 = 0 ; # [doc = "< Address space ID represents the memory overlay the address is valid in."] pub const MCD_OVERLAY_ID : _bindgen_ty_4 = 1 ; # [doc = "< Address space ID represents the memory bank the address is valid in."] pub const MCD_MEMBANK_ID : _bindgen_ty_4 = 2 ; # [doc = "< Address space ID represents the process the address is valid in."] pub const MCD_PROCESS_ID : _bindgen_ty_4 = 3 ; # [doc = "< Address space ID represents the hardware thread the address is valid in."] pub const MCD_HW_THREAD_ID : _bindgen_ty_4 = 4 ; pub type _bindgen_ty_4 = :: std :: os :: raw :: c_int ; # [doc = " \\brief Enumeration type defining the type of a memory space.\n\nDifferent types of memory spaces are possible. This enumeration type describes\nthem. The type values \\c MCD_MEM_SPACE_IS_REGISTERS, \\c MCD_MEM_SPACE_IS_PROGRAM,\n\\c MCD_MEM_SPACE_IS_VIRTUAL and \\c MCD_MEM_SPACE_IS_CACHE are bitwise mutually exclusive.\n\\c MCD_MEM_SPACE_IS_PHYSICAL or \\c MCD_MEM_SPACE_IS_LOGICAL should be set when the target contains a\nmemory memagement unit (MMU) that translates memory addresses between core and memory.\nE.g. use (MCD_MEM_SPACE_IS_PROGRAM|MCD_MEM_SPACE_IS_LOGICAL) to identify an logical addresses of the program memory.\nUser defined memory space types need to have values between \\c MCD_MEMSPACE_CUSTOM_HI and \\c MCD_MEMSPACE_CUSTOM_HI.\nReserved memory space types must not be used."] pub type mcd_mem_type_et = u32 ; # [doc = "< The memory space is of none of the types below."] pub const MCD_MEM_SPACE_DEFAULT : _bindgen_ty_5 = 0 ; # [doc = "< The memory space contains only registers."] pub const MCD_MEM_SPACE_IS_REGISTERS : _bindgen_ty_5 = 1 ; # [doc = "< The memory space is a program memory."] pub const MCD_MEM_SPACE_IS_PROGRAM : _bindgen_ty_5 = 2 ; # [doc = "< The memory space is virtual (resource not existing in target)."] pub const MCD_MEM_SPACE_IS_VIRTUAL : _bindgen_ty_5 = 4 ; # [doc = "< The memory space is a cache."] pub const MCD_MEM_SPACE_IS_CACHE : _bindgen_ty_5 = 8 ; # [doc = "< The memory space is physical memory (not translated by MMU)"] pub const MCD_MEM_SPACE_IS_PHYSICAL : _bindgen_ty_5 = 16 ; # [doc = "< The memory space is logical memory (translated by MMU)"] pub const MCD_MEM_SPACE_IS_LOGICAL : _bindgen_ty_5 = 32 ; # [doc = "< Begin Range: Reserved for future API use."] pub const MCD_MEM_SPACE_RESERVED_LO : _bindgen_ty_5 = 64 ; # [doc = "< End   Range: Reserved for future API use."] pub const MCD_MEM_SPACE_RESERVED_HI : _bindgen_ty_5 = 32768 ; # [doc = "< Begin Range: User defined memory types."] pub const MCD_MEM_SPACE_CUSTOM_LO : _bindgen_ty_5 = 65536 ; # [doc = "< End   Range: User defined memory types."] pub const MCD_MEM_SPACE_CUSTOM_HI : _bindgen_ty_5 = 1073741824 ; pub type _bindgen_ty_5 = :: std :: os :: raw :: c_int ; # [doc = " \\brief Enumeration type defining the endianness of a memory space or a memory block.\n\nThe endianness of a memory can be either Little Endian or Big Endian. This enumeration\ntype describes the two possible values of endianness and is used to set the corresponding\nproperty of a memory space and a memory block description. If memory blocks are\nsupported, the value of a memory block overrides the one for the memory space it is\npart of."] pub type mcd_endian_et = u32 ; # [doc = "< Endianness as defined by the target architecture\nor parent module (if available)."] pub const MCD_ENDIAN_DEFAULT : _bindgen_ty_6 = 0 ; # [doc = "< Little Endian data representation."] pub const MCD_ENDIAN_LITTLE : _bindgen_ty_6 = 1 ; # [doc = "< Big Endian data representation."] pub const MCD_ENDIAN_BIG : _bindgen_ty_6 = 2 ; pub type _bindgen_ty_6 = :: std :: os :: raw :: c_int ; # [doc = " \\brief Enumeration type defining the allowed register types.\n\nA register can be a simple register, a compound register or a partial register.\nThis enumeration type describes the three register types."] pub type mcd_reg_type_et = u32 ; # [doc = "< Simple register."] pub const MCD_REG_TYPE_SIMPLE : _bindgen_ty_7 = 0 ; # [doc = "< Compound register composed more than one simple register."] pub const MCD_REG_TYPE_COMPOUND : _bindgen_ty_7 = 1 ; # [doc = "< Register that is part of a simple register."] pub const MCD_REG_TYPE_PARTIAL : _bindgen_ty_7 = 2 ; pub type _bindgen_ty_7 = :: std :: os :: raw :: c_int ; # [doc = " \\brief Enumeration type defining the type of a trigger.\n\nThis enumeration type describes the possible types of triggers for the\ntarget. The type values are bitwise mutually exclusive and a member of\ntype \\ref mcd_trig_type_et may be a combination of several of them.\nThe type \\c MCD_TRIG_TYPE_CUSTOM refers to a custom trigger (not a custom trigger\ntype) using the standard format as defined by \\ref mcd_trig_custom_st. User defined\ntrigger types need to have values between \\c MCD_TRIG_TYPE_CUSTOM_LO and\n\\c MCD_TRIG_TYPE_CUSTOM_HI."] pub type mcd_trig_type_et = u32 ; # [doc = "< Undefined trigger type."] pub const MCD_TRIG_TYPE_UNDEFINED : _bindgen_ty_8 = 0 ; # [doc = "< Trigger on a changing instruction pointer."] pub const MCD_TRIG_TYPE_IP : _bindgen_ty_8 = 1 ; # [doc = "< Trigger on a read data access to a specific address or address range."] pub const MCD_TRIG_TYPE_READ : _bindgen_ty_8 = 2 ; # [doc = "< Trigger on a write data access to a specific address or address range."] pub const MCD_TRIG_TYPE_WRITE : _bindgen_ty_8 = 4 ; # [doc = "< Trigger on a read or a write data access to a specific address or\naddress range."] pub const MCD_TRIG_TYPE_RW : _bindgen_ty_8 = 8 ; # [doc = "< Trigger on core information other than an IP or data compare trigger."] pub const MCD_TRIG_TYPE_NOCYCLE : _bindgen_ty_8 = 16 ; # [doc = "< Trigger on a trigger bus combination."] pub const MCD_TRIG_TYPE_TRIG_BUS : _bindgen_ty_8 = 32 ; # [doc = "< Trigger on an elapsed trigger counter."] pub const MCD_TRIG_TYPE_COUNTER : _bindgen_ty_8 = 64 ; # [doc = "< Custom trigger using standard format as defined by \\ref mcd_trig_custom_st."] pub const MCD_TRIG_TYPE_CUSTOM : _bindgen_ty_8 = 128 ; # [doc = "< Begin Range: User defined trigger types."] pub const MCD_TRIG_TYPE_CUSTOM_LO : _bindgen_ty_8 = 65536 ; # [doc = "< End   Range: User defined trigger types."] pub const MCD_TRIG_TYPE_CUSTOM_HI : _bindgen_ty_8 = 1073741824 ; pub type _bindgen_ty_8 = :: std :: os :: raw :: c_int ; # [doc = " \\brief Enumeration type defining additional options for a trigger.\n\nThis enumeration type describes the additionally possible options for\ntriggers in a target. The type values are bitwise mutually exclusive\nand a member of type \\ref mcd_trig_opt_et may be a combination of several\nof them. User defined trigger options need to have values between\n\\c MCD_TRIG_OPT_CUSTOM_LO and \\c MCD_TRIG_OPT_CUSTOM_HI."] pub type mcd_trig_opt_et = u32 ; # [doc = "< Default trigger options, e.g. chosen by the platform."] pub const MCD_TRIG_OPT_DEFAULT : _bindgen_ty_9 = 0 ; # [doc = "< The trigger shall be implemented by hardware."] pub const MCD_TRIG_OPT_IMPL_HARDWARE : _bindgen_ty_9 = 1 ; # [doc = "< The trigger shall be implemented by software (code substitution)."] pub const MCD_TRIG_OPT_IMPL_SOFTWARE : _bindgen_ty_9 = 2 ; # [doc = "< The trigger is activated when a data access is performed outside\nthe specified range."] pub const MCD_TRIG_OPT_OUT_OF_RANGE : _bindgen_ty_9 = 4 ; # [doc = "< The value of a data access is part of the trigger condition."] pub const MCD_TRIG_OPT_DATA_IS_CONDITION : _bindgen_ty_9 = 8 ; # [doc = "< The size of a data access is part of the trigger condition."] pub const MCD_TRIG_OPT_DATASIZE_IS_CONDITION : _bindgen_ty_9 = 16 ; # [doc = "< The data comparison done in a trigger condition is negated."] pub const MCD_TRIG_OPT_NOT_DATA : _bindgen_ty_9 = 32 ; # [doc = "< The data values are considered as signed for the trigger\ncondition. This usually requires the setting of\n\\c MCD_TRIG_OPT_DATASIZE_IS_CONDITION."] pub const MCD_TRIG_OPT_SIGNED_DATA : _bindgen_ty_9 = 64 ; # [doc = "< The hardware thread ID is part of the trigger condition."] pub const MCD_TRIG_OPT_HW_THREAD_IS_CONDITION : _bindgen_ty_9 = 128 ; # [doc = "< The comparison of the hardware thread ID is negated."] pub const MCD_TRIG_OPT_NOT_HW_THREAD : _bindgen_ty_9 = 256 ; # [doc = "< The software thread ID is part of the trigger condition."] pub const MCD_TRIG_OPT_SW_THREAD_IS_CONDITION : _bindgen_ty_9 = 512 ; # [doc = "< The comparison of the software thread ID is negated."] pub const MCD_TRIG_OPT_NOT_SW_THREAD : _bindgen_ty_9 = 1024 ; # [doc = "< The data value of the cycle must change the value of the target location.\nThis applies only to triggers on write cycles.\nThe \\c data_mask field defines which bits are considered for the comparison."] pub const MCD_TRIG_OPT_DATA_MUST_CHANGE : _bindgen_ty_9 = 2048 ; # [doc = "< The core mode as defined by the member \\c core_mode_mask of a\n\\ref mcd_trig_complex_core_st is part of the trigger condition.\nEach set bit prevents the related core mode from activating\nthe trigger."] pub const MCD_TRIG_OPT_CORE_MODE_IS_CONDITION : _bindgen_ty_9 = 131072 ; # [doc = "< The state of the trigger set's state machine is part of the trigger\ncondition."] pub const MCD_TRIG_OPT_STATE_IS_CONDITION : _bindgen_ty_9 = 262144 ; # [doc = "< The trigger condition is negated, i.e. action is taken if the\nwhole trigger condition is NOT met. This should not be mixed up with\n\\c MCD_TRIG_OPT_OUT_OF_RANGE which inverts just the address range."] pub const MCD_TRIG_OPT_NOT : _bindgen_ty_9 = 524288 ; # [doc = "< Begin Range: User defined trigger options."] pub const MCD_TRIG_OPT_CUSTOM_LO : _bindgen_ty_9 = 1048576 ; # [doc = "< End   Range: User defined trigger options."] pub const MCD_TRIG_OPT_CUSTOM_HI : _bindgen_ty_9 = 1073741824 ; pub type _bindgen_ty_9 = :: std :: os :: raw :: c_int ; # [doc = " \\brief Enumeration type defining the trigger action types.\n\nThis enumeration type describes the possible actions for triggers\nin a target. The type values are bitwise mutually exclusive and\na member of type \\c mcd_trig_action_et may be a combination of\nseveral of them. User defined trigger actions need to have values\nbetween \\c MCD_TRIG_ACTION_CUSTOM_LO and \\c MCD_TRIG_ACTION_CUSTOM_HI."] pub type mcd_trig_action_et = u32 ; # [doc = "< No action has to be taken except from setting the\ntrigger to be captured."] pub const MCD_TRIG_ACTION_DEFAULT : _bindgen_ty_10 = 0 ; # [doc = "< Stop this core and bring it into debug mode."] pub const MCD_TRIG_ACTION_DBG_DEBUG : _bindgen_ty_10 = 1 ; # [doc = "< Stop all cores and bring them into debug mode."] pub const MCD_TRIG_ACTION_DBG_GLOBAL : _bindgen_ty_10 = 2 ; # [doc = "< Issue an exception (monitor interrupt) on this core\nin order to execute the monitor code."] pub const MCD_TRIG_ACTION_DBG_MONITOR : _bindgen_ty_10 = 4 ; # [doc = "< Signal the according event on the trigger bus (for\nthe duration of one core cycle). The corresponding\nbitmask is specified by the member \\c action_param\nof the used trigger data structure."] pub const MCD_TRIG_ACTION_TRIG_BUS_EVENT : _bindgen_ty_10 = 16 ; # [doc = "< Set bits on the trigger bus. The corresponding bitmask\nis specified by the member \\c action_param of the used\ntrigger data structure."] pub const MCD_TRIG_ACTION_TRIG_BUS_SET : _bindgen_ty_10 = 32 ; # [doc = "< Clear bits on the trigger bus. The corresponding bitmask\nis specified by the member \\c action_param of the used\ntrigger data structure."] pub const MCD_TRIG_ACTION_TRIG_BUS_CLEAR : _bindgen_ty_10 = 64 ; # [doc = "< Trace this cycle."] pub const MCD_TRIG_ACTION_TRACE_QUALIFY : _bindgen_ty_10 = 256 ; # [doc = "< Trace this cycle, affects program trace only."] pub const MCD_TRIG_ACTION_TRACE_QUALIFY_PROGRAM : _bindgen_ty_10 = 512 ; # [doc = "< Trace this cycle, affects data trace only."] pub const MCD_TRIG_ACTION_TRACE_QUALIFY_DATA : _bindgen_ty_10 = 1024 ; # [doc = "< Start tracing."] pub const MCD_TRIG_ACTION_TRACE_START : _bindgen_ty_10 = 2048 ; # [doc = "< Stop tracing."] pub const MCD_TRIG_ACTION_TRACE_STOP : _bindgen_ty_10 = 4096 ; # [doc = "< Trigger trace unit."] pub const MCD_TRIG_ACTION_TRACE_TRIGGER : _bindgen_ty_10 = 8192 ; # [doc = "< Start performance analysis or profiling."] pub const MCD_TRIG_ACTION_ANA_START_PERFM : _bindgen_ty_10 = 65536 ; # [doc = "< Stop performance analysis or profiling."] pub const MCD_TRIG_ACTION_ANA_STOP_PERFM : _bindgen_ty_10 = 131072 ; # [doc = "< Set the trigger set's state machine to a new state. The\ncorresponding state is specified by the member\n\\c action_param of the used trigger data structure."] pub const MCD_TRIG_ACTION_STATE_CHANGE : _bindgen_ty_10 = 262144 ; # [doc = "< Increment the counter specified by the member\n\\c action_param of the used trigger data structure."] pub const MCD_TRIG_ACTION_COUNT_QUALIFY : _bindgen_ty_10 = 524288 ; # [doc = "< Start the counter specified by the member \\c action_param\nof the used trigger data structure."] pub const MCD_TRIG_ACTION_COUNT_START : _bindgen_ty_10 = 1048576 ; # [doc = "< Stop the counter specified by the member \\c action_param\nof the used trigger data structure."] pub const MCD_TRIG_ACTION_COUNT_STOP : _bindgen_ty_10 = 2097152 ; # [doc = "< Restart the counter specified by the member \\c action_param\nof the used trigger data structure."] pub const MCD_TRIG_ACTION_COUNT_RESTART : _bindgen_ty_10 = 4194304 ; # [doc = "< Begin Range: User defined trigger actions."] pub const MCD_TRIG_ACTION_CUSTOM_LO : _bindgen_ty_10 = 16777216 ; # [doc = "< End   Range: User defined trigger actions."] pub const MCD_TRIG_ACTION_CUSTOM_HI : _bindgen_ty_10 = 1073741824 ; pub type _bindgen_ty_10 = :: std :: os :: raw :: c_int ; # [doc = " \\brief Enumeration type defining access types for transactions of transaction lists.\n\nThis enumeration type describes the four possible access types for transactions\nof a transaction list."] pub type mcd_tx_access_type_et = u32 ; # [doc = "< Read access transaction."] pub const MCD_TX_AT_R : _bindgen_ty_11 = 1 ; # [doc = "< Write access transaction."] pub const MCD_TX_AT_W : _bindgen_ty_11 = 2 ; # [doc = "< Read then write access transaction (atomic swap)."] pub const MCD_TX_AT_RW : _bindgen_ty_11 = 3 ; # [doc = "< Write then read access transaction (write and verify)."] pub const MCD_TX_AT_WR : _bindgen_ty_11 = 4 ; pub type _bindgen_ty_11 = :: std :: os :: raw :: c_int ; # [doc = " \\brief Enumeration type defining access options for transactions of transaction lists.\n\nThis enumeration type describes the possible access options for transactions of a\ntransaction list. The type values are bitwise mutually exclusive and a member of\ntype \\c mcd_tx_access_opt_et may be a combination of several of them. User defined\naccess options need to have values between \\c MCD_TX_OPT_CUSTOM_LO and\n\\c MCD_TX_OPT_CUSTOM_HI. Reserved access options must not be used.\n\nMarking the last transaction of a transaction list with \\c MCD_TX_OPT_ATOMIC_WITH_NEXT\ncauses it to be atomic with the first transaction of the next list to be executed\nfor this core connection."] pub type mcd_tx_access_opt_et = u32 ; # [doc = "< MCD implementation decides on applied access options."] pub const MCD_TX_OPT_DEFAULT : _bindgen_ty_12 = 0 ; # [doc = "< Trigger side effects for the access."] pub const MCD_TX_OPT_SIDE_EFFECTS : _bindgen_ty_12 = 1 ; # [doc = "< Omit side effects for the access."] pub const MCD_TX_OPT_NO_SIDE_EFFECTS : _bindgen_ty_12 = 2 ; # [doc = "< Perform burst accesses if possible."] pub const MCD_TX_OPT_BURST_ACCESSES : _bindgen_ty_12 = 4 ; # [doc = "< Avoid burst accesses if possible."] pub const MCD_TX_OPT_NO_BURST_ACCESSES : _bindgen_ty_12 = 8 ; # [doc = "< Dual port or DAP memory access."] pub const MCD_TX_OPT_ALTERNATE_PATH : _bindgen_ty_12 = 16 ; # [doc = "< High priority access."] pub const MCD_TX_OPT_PRIORITY_ACCESS : _bindgen_ty_12 = 32 ; # [doc = "< Force D-cache and unified caches to be write-through."] pub const MCD_TX_OPT_DCACHE_WRITE_THRU : _bindgen_ty_12 = 64 ; # [doc = "< Bypass caches and read/write directly to the memory."] pub const MCD_TX_OPT_CACHE_BYPASS : _bindgen_ty_12 = 128 ; # [doc = "< Do not increment address after each cycle. Useful for\nreading or writing to FIFOs."] pub const MCD_TX_OPT_NOINCREMENT : _bindgen_ty_12 = 256 ; # [doc = "< Transaction is executed atomic with the next one."] pub const MCD_TX_OPT_ATOMIC_WITH_NEXT : _bindgen_ty_12 = 512 ; # [doc = "< Memory is accessed in user mode (instead of\nsupervisor mode) Only set this bit in mcd_memblock_st\nor mcd_memspace_st, if the memory can be accessed in\nboth supervisor and user mode."] pub const MCD_TX_OPT_USERMODE : _bindgen_ty_12 = 1024 ; # [doc = "< Begin Range: Reserved for future API use."] pub const MCD_TX_OPT_RESERVED_LO : _bindgen_ty_12 = 2048 ; # [doc = "< End   Range: Reserved for future API use."] pub const MCD_TX_OPT_RESERVED_HI : _bindgen_ty_12 = 32768 ; # [doc = "< Begin Range: User defined access options."] pub const MCD_TX_OPT_CUSTOM_LO : _bindgen_ty_12 = 65536 ; # [doc = "< End   Range: User defined access options."] pub const MCD_TX_OPT_CUSTOM_HI : _bindgen_ty_12 = 1073741824 ; pub type _bindgen_ty_12 = :: std :: os :: raw :: c_int ; # [doc = " \\brief Enumeration type defining step types for a target core.\n\nThis enumeration type describes the possible step types for a target core. The\nstep type depends on the core type. A programmable core can be for example\nstepped in terms of cycles or instructions.\nUser defined step types need to have values between \\c MCD_CORE_STEP_TYPE_CUSTOM_LO\nand \\c MCD_CORE_STEP_TYPE_CUSTOM_HI. They for example can be based on specifications\nprovided by the IP developer of a core.\nThe step type values \\c MCD_CORE_STEP_TYPE_RESERVED_LO to \\c MCD_CORE_STEP_TYPE_RESERVED_HI\nare reserved for future API extensions and must not be used."] pub type mcd_core_step_type_et = u32 ; # [doc = "< Step the core for core specific cycles."] pub const MCD_CORE_STEP_TYPE_CYCLES : _bindgen_ty_13 = 1 ; # [doc = "< Step the core for core specific instructions."] pub const MCD_CORE_STEP_TYPE_INSTR : _bindgen_ty_13 = 2 ; # [doc = "< Begin Range: Reserved for future API use."] pub const MCD_CORE_STEP_TYPE_RESERVED_LO : _bindgen_ty_13 = 4 ; # [doc = "< End   Range: Reserved for future API use."] pub const MCD_CORE_STEP_TYPE_RESERVED_HI : _bindgen_ty_13 = 255 ; # [doc = "< Begin Range: User defined step types."] pub const MCD_CORE_STEP_TYPE_CUSTOM_LO : _bindgen_ty_13 = 256 ; # [doc = "< End   Range: User defined step types."] pub const MCD_CORE_STEP_TYPE_CUSTOM_HI : _bindgen_ty_13 = 3840 ; # [doc = "< Maximum number of supported step types."] pub const MCD_CORE_STEP_TYPE_MAX_TYPES : _bindgen_ty_13 = 2147483647 ; pub type _bindgen_ty_13 = :: std :: os :: raw :: c_int ; # [doc = " \\brief Enumeration type defining the execution states of a target core.\n\nThis enumeration type describes the possible execution states of a target core from\na debugger perspective. The HALTED state is defined to differ from the DEBUG state\nby the fact that a core in debug mode is under debugger control. In contrast to this\na core in HALTED state is not under the execution control of the debugger but in a\nstate from which the debugger can only push it to DEBUG state. The same applies to\nthe RUNNING state.\nUser defined core states need to have values between \\c MCD_CORE_STATE_CUSTOM_LO\nand \\c MCD_CORE_STATE_CUSTOM_HI."] pub type mcd_core_state_et = u32 ; # [doc = "< Target core state is unknown."] pub const MCD_CORE_STATE_UNKNOWN : _bindgen_ty_14 = 0 ; # [doc = "< Target core is running."] pub const MCD_CORE_STATE_RUNNING : _bindgen_ty_14 = 1 ; # [doc = "< Target core is halted."] pub const MCD_CORE_STATE_HALTED : _bindgen_ty_14 = 2 ; # [doc = "< Target core is in debug mode."] pub const MCD_CORE_STATE_DEBUG : _bindgen_ty_14 = 3 ; # [doc = "< Begin Range: User defined core states."] pub const MCD_CORE_STATE_CUSTOM_LO : _bindgen_ty_14 = 256 ; # [doc = "< End   Range: User defined core states."] pub const MCD_CORE_STATE_CUSTOM_HI : _bindgen_ty_14 = 2048 ; # [doc = "< Maximum number of supported core states."] pub const MCD_CORE_STATE_MAX_STATES : _bindgen_ty_14 = 2147483647 ; pub type _bindgen_ty_14 = :: std :: os :: raw :: c_int ; # [doc = " \\brief Enumeration type defining the possible events for a target core.\n\nThis enumeration type describes the possible core events for a target core\nfrom a debugger perspective. These allow to optimize the polling of specific\ntarget information and to support multiple clients connected to one target\ncore. Some core events may be reported just once.\nUser defined core events need to have values between \\c MCD_CORE_EVENT_CUSTOM_LO\nand \\c MCD_CORE_EVENT_CUSTOM_HI."] pub type mcd_core_event_et = u32 ; # [doc = "< No since the last poll."] pub const MCD_CORE_EVENT_NONE : _bindgen_ty_15 = 0 ; # [doc = "< Memory content has changed."] pub const MCD_CORE_EVENT_MEMORY_CHANGE : _bindgen_ty_15 = 1 ; # [doc = "< Register contents have changed."] pub const MCD_CORE_EVENT_REGISTER_CHANGE : _bindgen_ty_15 = 2 ; # [doc = "< Trace contents or states have changed."] pub const MCD_CORE_EVENT_TRACE_CHANGE : _bindgen_ty_15 = 4 ; # [doc = "< Triggers or trigger states have changed."] pub const MCD_CORE_EVENT_TRIGGER_CHANGE : _bindgen_ty_15 = 8 ; # [doc = "< Target was stopped at least once since the last poll,\nit may already be running again."] pub const MCD_CORE_EVENT_STOPPED : _bindgen_ty_15 = 16 ; # [doc = "< A target communication channel request from the target\nis pending."] pub const MCD_CORE_EVENT_CHL_PENDING : _bindgen_ty_15 = 32 ; # [doc = "< Begin Range: User defined core events."] pub const MCD_CORE_EVENT_CUSTOM_LO : _bindgen_ty_15 = 65536 ; # [doc = "< End   Range: User defined core events."] pub const MCD_CORE_EVENT_CUSTOM_HI : _bindgen_ty_15 = 1073741824 ; pub type _bindgen_ty_15 = :: std :: os :: raw :: c_int ; # [doc = " \\brief Enumeration type defining the communication channel types.\n\nThere can be different types of communication channels between a host side\ntool and the target. This enumeration desribes these possible types of\ncommunication channels. User defined communication channel types need to\nhave values between \\c MCD_CHL_TYPE_CUSTOM_LO and \\c MCD_CHL_TYPE_CUSTOM_HI."] pub type mcd_chl_type_et = u32 ; # [doc = "<Common communication channel to the target."] pub const MCD_CHL_TYPE_COMMON : _bindgen_ty_16 = 1 ; # [doc = "<Communication channel for configuration purposes,\ne.g. to configure the analysis setup."] pub const MCD_CHL_TYPE_CONFIG : _bindgen_ty_16 = 2 ; # [doc = "<Communication channel to an application running\non the target, e.g. for semi-hosting purposes."] pub const MCD_CHL_TYPE_APPLI : _bindgen_ty_16 = 3 ; # [doc = "<Begin Range: User defined communication channel types."] pub const MCD_CHL_TYPE_CUSTOM_LO : _bindgen_ty_16 = 256 ; # [doc = "<End   Range: User defined communication channel types."] pub const MCD_CHL_TYPE_CUSTOM_HI : _bindgen_ty_16 = 3840 ; pub type _bindgen_ty_16 = :: std :: os :: raw :: c_int ; # [doc = " \\brief Enumeration type defining communication channel attributes.\n\nA communication channel can be defined with several attributes concerning\nthe channel's direction, accessibility and priority. This enumeration\ntype describes them. The type values are bitwise mutually exclusive and\na member of type \\ref mcd_chl_attributes_et may be a combination of several\nof them."] pub type mcd_chl_attributes_et = u32 ; # [doc = "< Receive channel."] pub const MCD_CHL_AT_RCV : _bindgen_ty_17 = 1 ; # [doc = "< Send channel."] pub const MCD_CHL_AT_SND : _bindgen_ty_17 = 2 ; # [doc = "< Channel is memory mapped."] pub const MCD_CHL_AT_MEM_MAPPED : _bindgen_ty_17 = 64 ; # [doc = "< Channel has a defined priority."] pub const MCD_CHL_AT_HAS_PRIO : _bindgen_ty_17 = 2048 ; pub type _bindgen_ty_17 = :: std :: os :: raw :: c_int ; # [doc = " \\brief Enumeration type defining basic trace types.\n\nThis enumeration type describes the type of a trace source. The\ntype values are bitwise mutually exclusive. User defined trace\ntypes need to have values between \\c MCD_TRACE_TYPE_CUSTOM_LO\nand \\c MCD_TRACE_TYPE_CUSTOM_HI."] pub type mcd_trace_type_et = u32 ; # [doc = "< Unknown trace source."] pub const MCD_TRACE_TYPE_UNKNOWN : _bindgen_ty_18 = 0 ; # [doc = "< Traces the instruction and (optional)\ndata trace stream as seen from the core."] pub const MCD_TRACE_TYPE_CORE : _bindgen_ty_18 = 1 ; # [doc = "< Traces a bus that is not related to the\nprogram flow."] pub const MCD_TRACE_TYPE_BUS : _bindgen_ty_18 = 2 ; # [doc = "< Traces logical signals (can include buses)\nthat have an asynchronous nature."] pub const MCD_TRACE_TYPE_EVENT : _bindgen_ty_18 = 4 ; # [doc = "< Traces statistical or profiling information."] pub const MCD_TRACE_TYPE_STAT : _bindgen_ty_18 = 8 ; # [doc = "< Begin Range: User defined trace types."] pub const MCD_TRACE_TYPE_CUSTOM_LO : _bindgen_ty_18 = 256 ; # [doc = "< End   Range: User defined trace types."] pub const MCD_TRACE_TYPE_CUSTOM_HI : _bindgen_ty_18 = 1073741824 ; pub type _bindgen_ty_18 = :: std :: os :: raw :: c_int ; # [doc = " \\brief Enumeration type defining trace data formats.\n\nThis enumeration type describes the format of the trace data. Each\ntrace source can deliver data in exactly one format, only. Standard\nformats should be used whenever possible. User defined trace types\nneed to have values between \\c MCD_TRACE_FORMAT_CUSTOM_LO and\n\\c MCD_TRACE_FORMAT_CUSTOM_HI."] pub type mcd_trace_format_et = u32 ; # [doc = "< Trace data format not readable via API."] pub const MCD_TRACE_FORMAT_UNKNOWN : _bindgen_ty_19 = 0 ; # [doc = "< Execution trace extracted from bus fetch cycles\n(use struct \\ref mcd_trace_data_core_st for this format)."] pub const MCD_TRACE_FORMAT_CORE_FETCH : _bindgen_ty_19 = 1 ; # [doc = "< Execution trace\n(use struct \\ref mcd_trace_data_core_st for this format)."] pub const MCD_TRACE_FORMAT_CORE_EXECUTE : _bindgen_ty_19 = 2 ; # [doc = "< Flowtrace data format similar to NEXUS traces, instruction count\n(use struct \\ref mcd_trace_data_core_st for this format)."] pub const MCD_TRACE_FORMAT_CORE_FLOW_ICOUNT : _bindgen_ty_19 = 3 ; # [doc = "< Flowtrace data format similar to NEXUS traces, bytes count\n(use struct \\ref mcd_trace_data_core_st for this format)."] pub const MCD_TRACE_FORMAT_CORE_FLOW_BCOUNT : _bindgen_ty_19 = 4 ; # [doc = "< Flowtrace data format with predicates and instruction count\n(use struct \\ref mcd_trace_data_core_st for this format)."] pub const MCD_TRACE_FORMAT_CORE_FLOW_IPREDICATE : _bindgen_ty_19 = 5 ; # [doc = "< Logic and system event trace\n(use struct \\ref mcd_trace_data_event_st for this format)."] pub const MCD_TRACE_FORMAT_EVENT : _bindgen_ty_19 = 16 ; # [doc = "< Statistics trace\n(use struct \\ref mcd_trace_data_stat_st for this format)."] pub const MCD_TRACE_FORMAT_STAT : _bindgen_ty_19 = 32 ; # [doc = "< Begin Range: User defined trace data formats."] pub const MCD_TRACE_FORMAT_CUSTOM_LO : _bindgen_ty_19 = 256 ; # [doc = "< End   Range: User defined trace data formats."] pub const MCD_TRACE_FORMAT_CUSTOM_HI : _bindgen_ty_19 = 2147483647 ; pub type _bindgen_ty_19 = :: std :: os :: raw :: c_int ; # [doc = " \\brief Enumeration type defining operation modes of a trace buffer.\n\nThis enumeration type describes the possible operation modes of a\ntrace buffer. The type values are bitwise mutually exclusive. User\ndefined operation modes need to have values between\n\\c MCD_TRACE_MODE_CUSTOM_LO and \\c MCD_TRACE_MODE_CUSTOM_HI."] pub type mcd_trace_mode_et = u32 ; # [doc = "< Do not change trace buffer mode."] pub const MCD_TRACE_MODE_NOCHANGE : _bindgen_ty_20 = 0 ; # [doc = "< Circular trace buffer."] pub const MCD_TRACE_MODE_FIFO : _bindgen_ty_20 = 1 ; # [doc = "< Trace stops when buffer is full."] pub const MCD_TRACE_MODE_STACK : _bindgen_ty_20 = 2 ; # [doc = "< Target is stopped (brought into debug state)\nwhen buffer is almost full."] pub const MCD_TRACE_MODE_LEACH : _bindgen_ty_20 = 4 ; # [doc = "< Trace data are continuously streamed through\nAPI, buffer is a FIFO for temporary storage."] pub const MCD_TRACE_MODE_PIPE : _bindgen_ty_20 = 8 ; # [doc = "< Begin Range: User defined operation modes."] pub const MCD_TRACE_MODE_CUSTOM_LO : _bindgen_ty_20 = 256 ; # [doc = "< End   Range: User defined operation modes."] pub const MCD_TRACE_MODE_CUSTOM_HI : _bindgen_ty_20 = 1073741824 ; pub type _bindgen_ty_20 = :: std :: os :: raw :: c_int ; # [doc = " \\brief Enumeration type defining trace states.\n\nThis enumeration type describes the possible states of a trace.\nUser defined trace states need to have values between\n\\c MCD_TRACE_STATE_CUSTOM_LO and \\c MCD_TRACE_STATE_CUSTOM_HI."] pub type mcd_trace_state_et = u32 ; # [doc = "< Do not change state (only for \\ref mcd_set_trace_state_f())."] pub const MCD_TRACE_STATE_NOCHANGE : _bindgen_ty_21 = 0 ; # [doc = "< Trace is disabled and no resources are allocated."] pub const MCD_TRACE_STATE_DISABLE : _bindgen_ty_21 = 1 ; # [doc = "< Trace is off and does not trace data, but is ready for tracing."] pub const MCD_TRACE_STATE_OFF : _bindgen_ty_21 = 2 ; # [doc = "< Trace is armed."] pub const MCD_TRACE_STATE_ARM : _bindgen_ty_21 = 3 ; # [doc = "< Trace is triggered and waits for the post trigger delay."] pub const MCD_TRACE_STATE_TRIGGER : _bindgen_ty_21 = 4 ; # [doc = "< Trace has stopped (after trigger and post trigger delay have elapsed)."] pub const MCD_TRACE_STATE_STOP : _bindgen_ty_21 = 5 ; # [doc = "< Clears trace buffer and goes into OFF state (only for \\ref mcd_set_trace_state_f())."] pub const MCD_TRACE_STATE_INIT : _bindgen_ty_21 = 16 ; # [doc = "< Begin Range: User defined trace states."] pub const MCD_TRACE_STATE_CUSTOM_LO : _bindgen_ty_21 = 256 ; # [doc = "< End   Range: User defined trace states."] pub const MCD_TRACE_STATE_CUSTOM_HI : _bindgen_ty_21 = 2147483647 ; pub type _bindgen_ty_21 = :: std :: os :: raw :: c_int ; # [doc = " \\brief Enumeration type defining trace markers.\n\nThis enumeration type describes markers associated with a single\ntrace frame. The type values are bitwise mutually exclusive and\na member of type \\ref mcd_trace_marker_et may be a combination of\nseveral of them. User defined trace markers need to have values\nbetween \\c MCD_TRACE_MARKER_CUSTOM_LO and \\c MCD_TRACE_MARKER_CUSTOM_HI.\n"] pub type mcd_trace_marker_et = u32 ; # [doc = "< No marker set."] pub const MCD_TRACE_MARKER_NONE : _bindgen_ty_22 = 0 ; # [doc = "< Core has started execution in this trace frame (first cycle)."] pub const MCD_TRACE_MARKER_RUN : _bindgen_ty_22 = 1 ; # [doc = "< Core has stopped execution in this trace frame (last cycle)."] pub const MCD_TRACE_MARKER_DEBUG : _bindgen_ty_22 = 2 ; # [doc = "< Tracing has started in this trace frame (controlled by trigger)."] pub const MCD_TRACE_MARKER_START : _bindgen_ty_22 = 4 ; # [doc = "< Tracing has stopped in this trace frame (controlled by trigger)."] pub const MCD_TRACE_MARKER_STOP : _bindgen_ty_22 = 8 ; # [doc = "< Error marker (hardware failure or program flow reconstruction error)."] pub const MCD_TRACE_MARKER_ERROR : _bindgen_ty_22 = 16 ; # [doc = "< Gap in trace (caused by bandwidth limitation on trace port)."] pub const MCD_TRACE_MARKER_GAP : _bindgen_ty_22 = 32 ; # [doc = "< Begin Range: User defined trace markers."] pub const MCD_TRACE_MARKER_CUSTOM_LO : _bindgen_ty_22 = 256 ; # [doc = "< End   Range: User defined trace markers."] pub const MCD_TRACE_MARKER_CUSTOM_HI : _bindgen_ty_22 = 1073741824 ; pub type _bindgen_ty_22 = :: std :: os :: raw :: c_int ; # [doc = " \\brief Enumeration type defining basic trace cycles.\n\nThis enumeration type describes the basic trace cycle types for bus\nand core traces. User defined trace cycle types need to have values\nbetween \\c MCD_TRACE_CYCLE_CUSTOM_LO and \\c MCD_TRACE_CYCLE_CUSTOM_HI."] pub type mcd_trace_cycle_et = u32 ; # [doc = "< Trave cycle contains no valid data for this core."] pub const MCD_TRACE_CYCLE_UNKNOWN : _bindgen_ty_23 = 0 ; # [doc = "< No trace cycle, control information (marker, timestamp) is valid."] pub const MCD_TRACE_CYCLE_NONE : _bindgen_ty_23 = 1 ; # [doc = "< Program execution cycle, marks the execution of one instruction.\nFor a program flow trace this marks the execution of a block\nwhich is ended with a taken branch."] pub const MCD_TRACE_CYCLE_EXECUTE : _bindgen_ty_23 = 2 ; # [doc = "< Program execution cycle, marks the execution of one conditional\ninstruction with a \"failing\" condition code. For a program flow\ntrace this marks the execution of a block which is ended without\na branch."] pub const MCD_TRACE_CYCLE_NOTEXECUTE : _bindgen_ty_23 = 3 ; # [doc = "< Program fetch cycle, the instruction related to the cycle may\njust be prefetched."] pub const MCD_TRACE_CYCLE_FETCH : _bindgen_ty_23 = 4 ; # [doc = "< Data read cycle."] pub const MCD_TRACE_CYCLE_READ : _bindgen_ty_23 = 5 ; # [doc = "< Data write cycle."] pub const MCD_TRACE_CYCLE_WRITE : _bindgen_ty_23 = 6 ; # [doc = "< Ownership change cycle, usually indicates a change of the executed\nsoftware thread."] pub const MCD_TRACE_CYCLE_OWNERSHIP : _bindgen_ty_23 = 7 ; # [doc = "< Begin Range: User defined trace cycles."] pub const MCD_TRACE_CYCLE_CUSTOM_LO : _bindgen_ty_23 = 256 ; # [doc = "< End   Range: User defined trace cycles."] pub const MCD_TRACE_CYCLE_CUSTOM_HI : _bindgen_ty_23 = 2147483647 ; pub type _bindgen_ty_23 = :: std :: os :: raw :: c_int ; # [doc = " \\brief Structure type containing the MCD API version information of the tool.\n\nThis structure type contains version information about the MCD API implementation\nof the tool.\nReference version at end of SPRINT project is:\n-  v_api_major = 1\n-  v_api_minor = 0\n-  author = \"SPRINT Release\""] # [repr (C)] # [derive (Debug , Default , Copy , Clone)] pub struct mcd_api_version_st { # [doc = "< API major version."] pub v_api_major : u16 , # [doc = "< API minor version."] pub v_api_minor : u16 , # [doc = "< API name of the author of this MCD API version"] pub author : [mcd_char_t ; 32usize] , } # [test] fn bindgen_test_layout_mcd_api_version_st () { const UNINIT : :: std :: mem :: MaybeUninit < mcd_api_version_st > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < mcd_api_version_st > () , 36usize , concat ! ("Size of: " , stringify ! (mcd_api_version_st))) ; assert_eq ! (:: std :: mem :: align_of :: < mcd_api_version_st > () , 2usize , concat ! ("Alignment of " , stringify ! (mcd_api_version_st))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . v_api_major) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (mcd_api_version_st) , "::" , stringify ! (v_api_major))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . v_api_minor) as usize - ptr as usize } , 2usize , concat ! ("Offset of field: " , stringify ! (mcd_api_version_st) , "::" , stringify ! (v_api_minor))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . author) as usize - ptr as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (mcd_api_version_st) , "::" , stringify ! (author))) ; } # [doc = " \\brief Structure type containing the MCD API implementation information.\n\nThis structure type contains important information about the particular implementation\nof the MCD API."] # [repr (C)] # [derive (Debug , Default , Copy , Clone)] pub struct mcd_impl_version_info_st { # [doc = "< Implemented API version."] pub v_api : mcd_api_version_st , # [doc = "< Major version number of this implementation."] pub v_imp_major : u16 , # [doc = "< Minor version number of this implementation."] pub v_imp_minor : u16 , # [doc = "< Build number of this implementation."] pub v_imp_build : u16 , # [doc = "< Name of vendor of the implementation."] pub vendor : [mcd_char_t ; 32usize] , # [doc = "< String from __DATE__ macro at compile time."] pub date : [mcd_char_t ; 16usize] , } # [test] fn bindgen_test_layout_mcd_impl_version_info_st () { const UNINIT : :: std :: mem :: MaybeUninit < mcd_impl_version_info_st > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < mcd_impl_version_info_st > () , 90usize , concat ! ("Size of: " , stringify ! (mcd_impl_version_info_st))) ; assert_eq ! (:: std :: mem :: align_of :: < mcd_impl_version_info_st > () , 2usize , concat ! ("Alignment of " , stringify ! (mcd_impl_version_info_st))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . v_api) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (mcd_impl_version_info_st) , "::" , stringify ! (v_api))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . v_imp_major) as usize - ptr as usize } , 36usize , concat ! ("Offset of field: " , stringify ! (mcd_impl_version_info_st) , "::" , stringify ! (v_imp_major))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . v_imp_minor) as usize - ptr as usize } , 38usize , concat ! ("Offset of field: " , stringify ! (mcd_impl_version_info_st) , "::" , stringify ! (v_imp_minor))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . v_imp_build) as usize - ptr as usize } , 40usize , concat ! ("Offset of field: " , stringify ! (mcd_impl_version_info_st) , "::" , stringify ! (v_imp_build))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . vendor) as usize - ptr as usize } , 42usize , concat ! ("Offset of field: " , stringify ! (mcd_impl_version_info_st) , "::" , stringify ! (vendor))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . date) as usize - ptr as usize } , 74usize , concat ! ("Offset of field: " , stringify ! (mcd_impl_version_info_st) , "::" , stringify ! (date))) ; } # [doc = " \\brief Structure type containing the error status and error event notification.\n\nAll API functions return a value of type \\c mcd_return_et. If this value indicates an error or an\nerror event that has happened during the last API call, the calling function has to handle it\nappropriately. This can be achieved by asking for more information about the occurred error or error\nevent. This structure type contains all the required details about the error and/or the error event\nas reported by the target."] # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct mcd_error_info_st { # [doc = "< Return status from the last API call."] pub return_status : mcd_return_et , # [doc = "< Detailed error code from the last API call."] pub error_code : mcd_error_code_et , # [doc = "< Detailed event code from the last API call."] pub error_events : mcd_error_event_et , # [doc = "< Detailed error text string from the last API call."] pub error_str : [mcd_char_t ; 256usize] , } # [test] fn bindgen_test_layout_mcd_error_info_st () { const UNINIT : :: std :: mem :: MaybeUninit < mcd_error_info_st > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < mcd_error_info_st > () , 268usize , concat ! ("Size of: " , stringify ! (mcd_error_info_st))) ; assert_eq ! (:: std :: mem :: align_of :: < mcd_error_info_st > () , 4usize , concat ! ("Alignment of " , stringify ! (mcd_error_info_st))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . return_status) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (mcd_error_info_st) , "::" , stringify ! (return_status))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . error_code) as usize - ptr as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (mcd_error_info_st) , "::" , stringify ! (error_code))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . error_events) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (mcd_error_info_st) , "::" , stringify ! (error_events))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . error_str) as usize - ptr as usize } , 12usize , concat ! ("Offset of field: " , stringify ! (mcd_error_info_st) , "::" , stringify ! (error_str))) ; } impl Default for mcd_error_info_st { fn default () -> Self { let mut s = :: std :: mem :: MaybeUninit :: < Self > :: uninit () ; unsafe { :: std :: ptr :: write_bytes (s . as_mut_ptr () , 0 , 1) ; s . assume_init () } } } # [doc = " \\brief Structure type containing the server information.\n\nThis structure type contains the information about a running or an installed server.\n\n\\c server contains a string with the server name. For a running simulation server, \\c system_instance has\nthe same value as \\c system_instance in \\ref mcd_core_con_info_st, and \\c acc_hw contains an empty string.\nFor a real hardware server it is the other way around."] # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct mcd_server_info_st { # [doc = "< String containing the server name."] pub server : [mcd_char_t ; 64usize] , # [doc = "< String containing the unique system instance identifier."] pub system_instance : [mcd_char_t ; 64usize] , # [doc = "< String containing the unique device access hardware name."] pub acc_hw : [mcd_char_t ; 64usize] , } # [test] fn bindgen_test_layout_mcd_server_info_st () { const UNINIT : :: std :: mem :: MaybeUninit < mcd_server_info_st > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < mcd_server_info_st > () , 192usize , concat ! ("Size of: " , stringify ! (mcd_server_info_st))) ; assert_eq ! (:: std :: mem :: align_of :: < mcd_server_info_st > () , 1usize , concat ! ("Alignment of " , stringify ! (mcd_server_info_st))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . server) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (mcd_server_info_st) , "::" , stringify ! (server))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . system_instance) as usize - ptr as usize } , 64usize , concat ! ("Offset of field: " , stringify ! (mcd_server_info_st) , "::" , stringify ! (system_instance))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . acc_hw) as usize - ptr as usize } , 128usize , concat ! ("Offset of field: " , stringify ! (mcd_server_info_st) , "::" , stringify ! (acc_hw))) ; } impl Default for mcd_server_info_st { fn default () -> Self { let mut s = :: std :: mem :: MaybeUninit :: < Self > :: uninit () ; unsafe { :: std :: ptr :: write_bytes (s . as_mut_ptr () , 0 , 1) ; s . assume_init () } } } # [doc = " \\brief Structure type containing the server connection instance.\n\nThis structure type contains a server connection instance.\n\nFor the MCD API a server provides the capability to connect to a system, its devices and/or cores.\nA server can arrange connections to several systems. A system again consists of devices and cores,\nwhere devices may subsume several cores, e.g. a SoC on a real hardware board. Consequently, a\nmulti-core simulation is a system with several processor cores."] # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct mcd_server_st { # [doc = "< Server connection instance of an implementation at lower level."] pub instance : * mut :: std :: os :: raw :: c_void , # [doc = "< String containing the host name."] pub host : * const mcd_char_t , # [doc = "< Server configuration information."] pub config_string : * const mcd_char_t , } # [test] fn bindgen_test_layout_mcd_server_st () { const UNINIT : :: std :: mem :: MaybeUninit < mcd_server_st > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < mcd_server_st > () , 24usize , concat ! ("Size of: " , stringify ! (mcd_server_st))) ; assert_eq ! (:: std :: mem :: align_of :: < mcd_server_st > () , 8usize , concat ! ("Alignment of " , stringify ! (mcd_server_st))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . instance) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (mcd_server_st) , "::" , stringify ! (instance))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . host) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (mcd_server_st) , "::" , stringify ! (host))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . config_string) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (mcd_server_st) , "::" , stringify ! (config_string))) ; } impl Default for mcd_server_st { fn default () -> Self { let mut s = :: std :: mem :: MaybeUninit :: < Self > :: uninit () ; unsafe { :: std :: ptr :: write_bytes (s . as_mut_ptr () , 0 , 1) ; s . assume_init () } } } # [doc = " \\brief Structure type containing the core connection information.\n\nThe MCD hierarchy's top-level is a system. The next level are devices and followed by cores at the\nlowest level are cores. The MCD API is core centric, i.e. connections are established to specific\ncores and not to a device or a system. The core connection information is used to open this connection\nwith \\ref mcd_open_core_f().\nIn order to establish a core connection, the core connection information does not have to complete\nbut it has to be unambiguous. A set of hierarchical query functions, starting at system level, allows\nto parse each system top down.\nIt is recommended to exclude unnecessary and redundant hierarchy information from \\c core and \\c device.\n\\c device needs to be readable and unambigious within a \\c system. \\c core again has to be readable and\nunambigious within its superior \\c device instance.\n\nThis structure type contains all information required to establish a core connection.\n\nA detailed description for a few member fields of \\ref mcd_core_con_info_st is provided below:\n- \\c system          : String containing the system name. Predefined value is \"Real HW\" for physical\ndevices. Note that in case of \"Real HW\" the \\c acc_hw always needs to be defined.\n- \\c system_instance : Allows to differentiate between several system instances with the same name. A\ntypical use case is a simulator where different instances can be distinguished\nby their process ID. (For example \\c system_instance could be: \"Process ID: 1234\".\n- \\c device          : String containing the system unique device instance name. For Real HW this is\nusually the sales name of the device. If the access hardware operates a multi device\ntarget system (e.g. over IEEE1149.7), this device string can contain an index to\ndifferentiate between several devices of the same type."] # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct mcd_core_con_info_st { # [doc = "< String containing the IP host name."] pub host : [mcd_char_t ; 64usize] , # [doc = "< Port number of the server."] pub server_port : u32 , # [doc = "< String containing the server key as provided by \\ref mcd_open_server_f()."] pub server_key : [mcd_char_t ; 64usize] , # [doc = "< String containing the system key as provided by \\ref mcd_open_server_f()."] pub system_key : [mcd_char_t ; 64usize] , # [doc = "< String containing the device key, optional for \\ref mcd_open_core_f()."] pub device_key : [mcd_char_t ; 64usize] , # [doc = "< String containing the system name."] pub system : [mcd_char_t ; 64usize] , # [doc = "< String containing the unique system instance identifier."] pub system_instance : [mcd_char_t ; 64usize] , # [doc = "< String containing the unique device access hardware name."] pub acc_hw : [mcd_char_t ; 64usize] , # [doc = "< Device type identifier (IEEE 1149.1 device ID)."] pub device_type : u32 , # [doc = "< String containing the system unique device instance name."] pub device : [mcd_char_t ; 64usize] , # [doc = "< Unique device ID."] pub device_id : u32 , # [doc = "< String containing the device unique core name."] pub core : [mcd_char_t ; 64usize] , # [doc = "< Core type identifier (taken from ELF predefined architecture)."] pub core_type : u32 , # [doc = "< Unique core ID representing the core version."] pub core_id : u32 , } # [test] fn bindgen_test_layout_mcd_core_con_info_st () { const UNINIT : :: std :: mem :: MaybeUninit < mcd_core_con_info_st > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < mcd_core_con_info_st > () , 596usize , concat ! ("Size of: " , stringify ! (mcd_core_con_info_st))) ; assert_eq ! (:: std :: mem :: align_of :: < mcd_core_con_info_st > () , 4usize , concat ! ("Alignment of " , stringify ! (mcd_core_con_info_st))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . host) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (mcd_core_con_info_st) , "::" , stringify ! (host))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . server_port) as usize - ptr as usize } , 64usize , concat ! ("Offset of field: " , stringify ! (mcd_core_con_info_st) , "::" , stringify ! (server_port))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . server_key) as usize - ptr as usize } , 68usize , concat ! ("Offset of field: " , stringify ! (mcd_core_con_info_st) , "::" , stringify ! (server_key))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . system_key) as usize - ptr as usize } , 132usize , concat ! ("Offset of field: " , stringify ! (mcd_core_con_info_st) , "::" , stringify ! (system_key))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . device_key) as usize - ptr as usize } , 196usize , concat ! ("Offset of field: " , stringify ! (mcd_core_con_info_st) , "::" , stringify ! (device_key))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . system) as usize - ptr as usize } , 260usize , concat ! ("Offset of field: " , stringify ! (mcd_core_con_info_st) , "::" , stringify ! (system))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . system_instance) as usize - ptr as usize } , 324usize , concat ! ("Offset of field: " , stringify ! (mcd_core_con_info_st) , "::" , stringify ! (system_instance))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . acc_hw) as usize - ptr as usize } , 388usize , concat ! ("Offset of field: " , stringify ! (mcd_core_con_info_st) , "::" , stringify ! (acc_hw))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . device_type) as usize - ptr as usize } , 452usize , concat ! ("Offset of field: " , stringify ! (mcd_core_con_info_st) , "::" , stringify ! (device_type))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . device) as usize - ptr as usize } , 456usize , concat ! ("Offset of field: " , stringify ! (mcd_core_con_info_st) , "::" , stringify ! (device))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . device_id) as usize - ptr as usize } , 520usize , concat ! ("Offset of field: " , stringify ! (mcd_core_con_info_st) , "::" , stringify ! (device_id))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . core) as usize - ptr as usize } , 524usize , concat ! ("Offset of field: " , stringify ! (mcd_core_con_info_st) , "::" , stringify ! (core))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . core_type) as usize - ptr as usize } , 588usize , concat ! ("Offset of field: " , stringify ! (mcd_core_con_info_st) , "::" , stringify ! (core_type))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . core_id) as usize - ptr as usize } , 592usize , concat ! ("Offset of field: " , stringify ! (mcd_core_con_info_st) , "::" , stringify ! (core_id))) ; } impl Default for mcd_core_con_info_st { fn default () -> Self { let mut s = :: std :: mem :: MaybeUninit :: < Self > :: uninit () ; unsafe { :: std :: ptr :: write_bytes (s . as_mut_ptr () , 0 , 1) ; s . assume_init () } } } # [doc = " \\brief Structure type containing the core connection instance.\n\nThis structure type contains a core connection instance.\n\nA detailed description for a few member fields of \\ref mcd_core_st is provided below:\n- \\c instance : The core connection instance of an implementation at a lower level.\nThis void pointer must not be null except from function calls\nconcerning communication channels. For these calls, null pointers\nare allowed in order to address hierarchical levels higher than core\nlevel."] # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct mcd_core_st { # [doc = "< Core connection instance of an implementation at lower level."] pub instance : * mut :: std :: os :: raw :: c_void , # [doc = "< Core connection information of the core instance."] pub core_con_info : * const mcd_core_con_info_st , } # [test] fn bindgen_test_layout_mcd_core_st () { const UNINIT : :: std :: mem :: MaybeUninit < mcd_core_st > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < mcd_core_st > () , 16usize , concat ! ("Size of: " , stringify ! (mcd_core_st))) ; assert_eq ! (:: std :: mem :: align_of :: < mcd_core_st > () , 8usize , concat ! ("Alignment of " , stringify ! (mcd_core_st))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . instance) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (mcd_core_st) , "::" , stringify ! (instance))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . core_con_info) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (mcd_core_st) , "::" , stringify ! (core_con_info))) ; } impl Default for mcd_core_st { fn default () -> Self { let mut s = :: std :: mem :: MaybeUninit :: < Self > :: uninit () ; unsafe { :: std :: ptr :: write_bytes (s . as_mut_ptr () , 0 , 1) ; s . assume_init () } } } # [doc = " \\brief Structure type containing information about a core mode.\n\nThis structure type contains information about a specific core mode. Most cores have for example \"supervisor\"\nor \"user\" operation modes. \\c core_mode can be a value within the range of 1 to 32. Some API structures\ncontain bitmasks of which each bit corresponds to \\c core_mode of exactly one core mode (bit 0 corresponds\nto core mode 1).\nCore mode 0 is used to define a default core mode - usually the most permissive core mode."] # [repr (C)] # [derive (Debug , Default , Copy , Clone)] pub struct mcd_core_mode_info_st { # [doc = "< Contains one of the 32 possible core modes,\nvalues can be 1 to 32."] pub core_mode : u8 , # [doc = "< The name of this core mode."] pub name : [mcd_char_t ; 32usize] , } # [test] fn bindgen_test_layout_mcd_core_mode_info_st () { const UNINIT : :: std :: mem :: MaybeUninit < mcd_core_mode_info_st > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < mcd_core_mode_info_st > () , 33usize , concat ! ("Size of: " , stringify ! (mcd_core_mode_info_st))) ; assert_eq ! (:: std :: mem :: align_of :: < mcd_core_mode_info_st > () , 1usize , concat ! ("Alignment of " , stringify ! (mcd_core_mode_info_st))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . core_mode) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (mcd_core_mode_info_st) , "::" , stringify ! (core_mode))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . name) as usize - ptr as usize } , 1usize , concat ! ("Offset of field: " , stringify ! (mcd_core_mode_info_st) , "::" , stringify ! (name))) ; } # [doc = " \\brief Structure type containing a completely resolved logical or physical memory address.\n\nThis structure type contains a completely resolved logical or physical memory address. The \\c address\nis always expressed in bytes, even if the minimum access unit (MAU) size is larger than a byte. The\n\\c addr_space_id can be used for different purposes as defined by \\c addr_space_type."] # [repr (C)] # [derive (Debug , Default , Copy , Clone)] pub struct mcd_addr_st { # [doc = "< Address value within a memory space, expressed in bytes."] pub address : u64 , # [doc = "< ID of the memory space associated with this address,\ne.g. a program memory, a data memory or registers ."] pub mem_space_id : u32 , # [doc = "< ID of the address space in which this address is valid."] pub addr_space_id : u32 , # [doc = "< Type of the address space in which this address is valid."] pub addr_space_type : mcd_addr_space_type_et , } # [test] fn bindgen_test_layout_mcd_addr_st () { const UNINIT : :: std :: mem :: MaybeUninit < mcd_addr_st > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < mcd_addr_st > () , 24usize , concat ! ("Size of: " , stringify ! (mcd_addr_st))) ; assert_eq ! (:: std :: mem :: align_of :: < mcd_addr_st > () , 8usize , concat ! ("Alignment of " , stringify ! (mcd_addr_st))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . address) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (mcd_addr_st) , "::" , stringify ! (address))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . mem_space_id) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (mcd_addr_st) , "::" , stringify ! (mem_space_id))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . addr_space_id) as usize - ptr as usize } , 12usize , concat ! ("Offset of field: " , stringify ! (mcd_addr_st) , "::" , stringify ! (addr_space_id))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . addr_space_type) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (mcd_addr_st) , "::" , stringify ! (addr_space_type))) ; } # [doc = " \\brief Structure type containing information about a memory space.\n\nThis structure type contains information about a memory space. of a target core. A memory space defines\na region of memory used in different processor architectures, e.g. \"program\" and \"data\" memory of a\nHarvard architecture or \"P\"/\"X\"/\"Y\"/\"Z\" of a DSP architecture.\n\nUsers must note that the sematics used in order to access a cache memory are the same as for accessing\nregular memory. On the target side, each cache memory implementation must be provided as a different\nmemory space with a unique memory space ID. All accesses to such a memory space must be understood by\nthe target as debug access to the cache.\n\nA detailed description for a few member fields of \\ref mcd_memspace_st is provided below:\n- \\c bits_per_mau    : The minimum addressable unit of a memory is defined as the size in bits of its\nbasic block that may have a unique address. For example for a byte addressable\nmemory this value would be set to '8' according to the 8 bits of a byte block.\n- \\c invariance      : The total number of bytes in a memory word, which is \\c bits_per_mau divided\nby 8, consists of groups of \"invariant\" bytes. These groups can be arranged in\nBig Endian or Little Endian order. For example an \\c invariance of '2' and '64'\n\\c bits_per_mau, a Little Endian word are represented as b0 b1 b2 b3 b4 b5 b6 b7.\nIn contrast to this, a Big Endian word is represented as b6 b7 b4 b5 b2 b3 b0 b1.\n- \\c num_mem_blocks  : Each memory space may have a certain number of memory blocks. Memory blocks contain\nadditional information pertaining to the intended purpose of the memory. This\ninformation may be used as a hint for memory data representation within a tool's\nmemory view. This field specifies the number of memory blocks present in this\nmemory space."] # [repr (C)] # [derive (Debug , Default , Copy , Clone)] pub struct mcd_memspace_st { # [doc = "< ID of this memory space, ID 0 is reserved."] pub mem_space_id : u32 , # [doc = "< Unique name of the memory space."] pub mem_space_name : [mcd_char_t ; 32usize] , # [doc = "< Type of the memory space."] pub mem_type : mcd_mem_type_et , # [doc = "< Bits per minimum addressable unit (MAU)."] pub bits_per_mau : u32 , # [doc = "< Number of invariant bytes."] pub invariance : u8 , # [doc = "< Endianness of this memory space. Can be overriden by \\c endian\nof a \\ref mcd_memblock_st."] pub endian : mcd_endian_et , # [doc = "< Minimum address of this memory space."] pub min_addr : u64 , # [doc = "< Maximum address of this memory space."] pub max_addr : u64 , # [doc = "< Number of memory blocks in this memory space."] pub num_mem_blocks : u32 , # [doc = "< Supported memory access options (OR'ed bitmask). Can be overriden\nby \\c supported_access_options of a \\c mcd_memblock_st."] pub supported_access_options : mcd_tx_access_opt_et , # [doc = "< Mask of core modes for which read accesses are impossible.\nA set bit indicates that read accesses are denied in this mode.\nBit 0 represents core mode '1', bit 31 represents core mode '32'.\nCan be overriden by \\c core_mode_mask_read of a \\ref mcd_memblock_st."] pub core_mode_mask_read : u32 , # [doc = "< Mask of core modes for which write accesses are impossible;\na set bit indicates that write accesses are denied in this mode.\nBit 0 represents core mode '1', bit 31 represents core mode '32'.\nCan be overriden by \\c core_mode_mask_write of a \\ref mcd_memblock_st."] pub core_mode_mask_write : u32 , } # [test] fn bindgen_test_layout_mcd_memspace_st () { const UNINIT : :: std :: mem :: MaybeUninit < mcd_memspace_st > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < mcd_memspace_st > () , 88usize , concat ! ("Size of: " , stringify ! (mcd_memspace_st))) ; assert_eq ! (:: std :: mem :: align_of :: < mcd_memspace_st > () , 8usize , concat ! ("Alignment of " , stringify ! (mcd_memspace_st))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . mem_space_id) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (mcd_memspace_st) , "::" , stringify ! (mem_space_id))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . mem_space_name) as usize - ptr as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (mcd_memspace_st) , "::" , stringify ! (mem_space_name))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . mem_type) as usize - ptr as usize } , 36usize , concat ! ("Offset of field: " , stringify ! (mcd_memspace_st) , "::" , stringify ! (mem_type))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . bits_per_mau) as usize - ptr as usize } , 40usize , concat ! ("Offset of field: " , stringify ! (mcd_memspace_st) , "::" , stringify ! (bits_per_mau))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . invariance) as usize - ptr as usize } , 44usize , concat ! ("Offset of field: " , stringify ! (mcd_memspace_st) , "::" , stringify ! (invariance))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . endian) as usize - ptr as usize } , 48usize , concat ! ("Offset of field: " , stringify ! (mcd_memspace_st) , "::" , stringify ! (endian))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . min_addr) as usize - ptr as usize } , 56usize , concat ! ("Offset of field: " , stringify ! (mcd_memspace_st) , "::" , stringify ! (min_addr))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . max_addr) as usize - ptr as usize } , 64usize , concat ! ("Offset of field: " , stringify ! (mcd_memspace_st) , "::" , stringify ! (max_addr))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . num_mem_blocks) as usize - ptr as usize } , 72usize , concat ! ("Offset of field: " , stringify ! (mcd_memspace_st) , "::" , stringify ! (num_mem_blocks))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . supported_access_options) as usize - ptr as usize } , 76usize , concat ! ("Offset of field: " , stringify ! (mcd_memspace_st) , "::" , stringify ! (supported_access_options))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . core_mode_mask_read) as usize - ptr as usize } , 80usize , concat ! ("Offset of field: " , stringify ! (mcd_memspace_st) , "::" , stringify ! (core_mode_mask_read))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . core_mode_mask_write) as usize - ptr as usize } , 84usize , concat ! ("Offset of field: " , stringify ! (mcd_memspace_st) , "::" , stringify ! (core_mode_mask_write))) ; } # [doc = " \\brief Structure type containing information about a memory block.\n\nThis structure type contains information about a memory block. A memory block is defined as\na continuous range of memory addresses with same properties. A memory block is owned by a\nmemory space.\n\nDetailed description for a few member fields of \\ref mcd_memblock_st is provided below:\n- \\c parent_id          : Memory blocks by definition can be hierarchical. This field describes\nthe ID of the parent memory block. In case this memory block is at\nroot level (and therefore has no parent) the \\c parent_id field has\nto be set to \\c MCD_MEM_BLOCK_NOPARENT.\n- \\c supported_au_sizes : This array has a maximum of \\c MCD_MEM_AUSIZE_NUM entries. Each entry\ndifferent from '0' indicates the permissible size of an addressable\nmemory unit in bits. All entries represent an allowed multiple of the\n\\c bits_per_mau field in the corresponding \\c mcd_memspace_st data\nstructure. For example, the supported addressable unit sizes for a\nmemory block in a memory space with '32' \\c bits_per_mau would be\n{32, 64, 96, 128}. This array field would then contain the values\n{1, 2, 3, 4}."] # [repr (C)] # [derive (Debug , Default , Copy , Clone)] pub struct mcd_memblock_st { # [doc = "< ID of this memory block, ID 0 is reserved."] pub mem_block_id : u32 , # [doc = "< Memory block name."] pub mem_block_name : [mcd_char_t ; 32usize] , # [doc = "< Indicating that this block has children."] pub has_children : mcd_bool_t , # [doc = "< ID of this block's parent (\\c MCD_MEM_BLOCK_NOPARENT\nif no parent exists)."] pub parent_id : u32 , # [doc = "< Start address of this block."] pub start_addr : u64 , # [doc = "< End address of this block."] pub end_addr : u64 , # [doc = "< Endianness of this memory block. Overrides \\c endian of the\ncorresponding \\ref mcd_memspace_st."] pub endian : mcd_endian_et , # [doc = "< Array of supported addressable unit sizes"] pub supported_au_sizes : [u32 ; 8usize] , # [doc = "< Supported memory access options (OR'ed bitmask).\nOverrides \\c supported_access_options of the\ncorresponding \\ref mcd_memspace_st."] pub supported_access_options : mcd_tx_access_opt_et , # [doc = "< Mask of core modes for which read accesses are impossible.\nA set bit indicates that read accesses are denied in this\nmode. Bit 0 represents core mode '1', bit 31 represents\ncore mode '32'. Overrides \\c core_mode_mask_read of the\ncorresponding \\ref mcd_memspace_st."] pub core_mode_mask_read : u32 , # [doc = "< Mask of core modes for which write accesses are impossible.\nA set bit indicates that write accesses are denied in this\nmode. Bit 0 represents core mode '1', bit 31 represents\ncore mode '32'. Overrides \\c core_mode_mask_write of the\ncorresponding \\ref mcd_memspace_st."] pub core_mode_mask_write : u32 , } # [test] fn bindgen_test_layout_mcd_memblock_st () { const UNINIT : :: std :: mem :: MaybeUninit < mcd_memblock_st > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < mcd_memblock_st > () , 112usize , concat ! ("Size of: " , stringify ! (mcd_memblock_st))) ; assert_eq ! (:: std :: mem :: align_of :: < mcd_memblock_st > () , 8usize , concat ! ("Alignment of " , stringify ! (mcd_memblock_st))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . mem_block_id) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (mcd_memblock_st) , "::" , stringify ! (mem_block_id))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . mem_block_name) as usize - ptr as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (mcd_memblock_st) , "::" , stringify ! (mem_block_name))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . has_children) as usize - ptr as usize } , 36usize , concat ! ("Offset of field: " , stringify ! (mcd_memblock_st) , "::" , stringify ! (has_children))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . parent_id) as usize - ptr as usize } , 40usize , concat ! ("Offset of field: " , stringify ! (mcd_memblock_st) , "::" , stringify ! (parent_id))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . start_addr) as usize - ptr as usize } , 48usize , concat ! ("Offset of field: " , stringify ! (mcd_memblock_st) , "::" , stringify ! (start_addr))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . end_addr) as usize - ptr as usize } , 56usize , concat ! ("Offset of field: " , stringify ! (mcd_memblock_st) , "::" , stringify ! (end_addr))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . endian) as usize - ptr as usize } , 64usize , concat ! ("Offset of field: " , stringify ! (mcd_memblock_st) , "::" , stringify ! (endian))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . supported_au_sizes) as usize - ptr as usize } , 68usize , concat ! ("Offset of field: " , stringify ! (mcd_memblock_st) , "::" , stringify ! (supported_au_sizes))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . supported_access_options) as usize - ptr as usize } , 100usize , concat ! ("Offset of field: " , stringify ! (mcd_memblock_st) , "::" , stringify ! (supported_access_options))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . core_mode_mask_read) as usize - ptr as usize } , 104usize , concat ! ("Offset of field: " , stringify ! (mcd_memblock_st) , "::" , stringify ! (core_mode_mask_read))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . core_mode_mask_write) as usize - ptr as usize } , 108usize , concat ! ("Offset of field: " , stringify ! (mcd_memblock_st) , "::" , stringify ! (core_mode_mask_write))) ; } # [doc = " \\brief Structure type containing register group information.\n\nThis structure type contains the properties of a register group of a target core.\n\nDetailed description for a few member fields of \\ref mcd_register_group_st is provided below:\n- \\c reg_group_id   : Contains the ID of this register group. A register group ID must be\nunique within the scope of a target core. ID '0' is reserved.\n- \\c reg_group_name : The name of a register group. A register group name cannot be longer\nthan \\c MCD_REGNAME_LEN characters (use representative names)."] # [repr (C)] # [derive (Debug , Default , Copy , Clone)] pub struct mcd_register_group_st { # [doc = "< ID of the register group, ID 0 is reserved."] pub reg_group_id : u32 , # [doc = "< Register group name."] pub reg_group_name : [mcd_char_t ; 32usize] , # [doc = "< Number of registers part of this group."] pub n_registers : u32 , } # [test] fn bindgen_test_layout_mcd_register_group_st () { const UNINIT : :: std :: mem :: MaybeUninit < mcd_register_group_st > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < mcd_register_group_st > () , 40usize , concat ! ("Size of: " , stringify ! (mcd_register_group_st))) ; assert_eq ! (:: std :: mem :: align_of :: < mcd_register_group_st > () , 4usize , concat ! ("Alignment of " , stringify ! (mcd_register_group_st))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . reg_group_id) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (mcd_register_group_st) , "::" , stringify ! (reg_group_id))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . reg_group_name) as usize - ptr as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (mcd_register_group_st) , "::" , stringify ! (reg_group_name))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . n_registers) as usize - ptr as usize } , 36usize , concat ! ("Offset of field: " , stringify ! (mcd_register_group_st) , "::" , stringify ! (n_registers))) ; } # [doc = " \\brief Structure type containing register information for a single register.\n\nThis structure contains the properties of a single register of a target core.\n\nDetailed description for a few member fields of \\ref mcd_register_group_st is provided below:\n- \\c addr         : Address of the register, not memory mapped registers are handled like memory mapped\ninto a \"register\" memory space (with \\c mem_type of the corresponding \\ref mcd_memspace_st\nset to \\c MCD_MEM_SPACE_IS_REGISTERS).\n- \\c regname      : The name of a register. A register name cannot be longer than \\c MCD_REGNAME_LEN\ncharacters (use representative names).\n- \\c hw_thread_id : The hardware thread ID the register belongs to. The ID must be set to '0'\nif the register is not assigned to a hardware thread."] # [repr (C)] # [derive (Debug , Default , Copy , Clone)] pub struct mcd_register_info_st { # [doc = "< Either the address of a memory mapped register or the register\naddress in a dedicated \"register memory space\"."] pub addr : mcd_addr_st , # [doc = "< ID of the group this register belongs to."] pub reg_group_id : u32 , # [doc = "< Register name."] pub regname : [mcd_char_t ; 32usize] , # [doc = "< Register size in bits."] pub regsize : u32 , # [doc = "< Mask of core modes for which read accesses are impossible.\nA set bit indicates that read accesses are denied in this mode.\nBit 0 represents core mode '1', bit 31 represents core mode 32.\nOverrides \\c core_mode_mask_read of the corresponding \\ref mcd_memspace_st."] pub core_mode_mask_read : u32 , # [doc = "< Mask of core modes for which write accesses are impossible.\nA set bit indicates that write accesses are denied in this mode.\nBit 0 represents core mode '1', bit 31 represents core mode '32'.\nOverrides \\c core_mode_mask_write of the corresponding \\ref mcd_memspace_st."] pub core_mode_mask_write : u32 , # [doc = "< Reading this register can trigger side effects."] pub has_side_effects_read : mcd_bool_t , # [doc = "< Writing this register can trigger side effects."] pub has_side_effects_write : mcd_bool_t , # [doc = "< Register type (simple, compound or partial)."] pub reg_type : mcd_reg_type_et , # [doc = "< Hardware thread ID this register belongs to."] pub hw_thread_id : u32 , } # [test] fn bindgen_test_layout_mcd_register_info_st () { const UNINIT : :: std :: mem :: MaybeUninit < mcd_register_info_st > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < mcd_register_info_st > () , 88usize , concat ! ("Size of: " , stringify ! (mcd_register_info_st))) ; assert_eq ! (:: std :: mem :: align_of :: < mcd_register_info_st > () , 8usize , concat ! ("Alignment of " , stringify ! (mcd_register_info_st))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . addr) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (mcd_register_info_st) , "::" , stringify ! (addr))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . reg_group_id) as usize - ptr as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (mcd_register_info_st) , "::" , stringify ! (reg_group_id))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . regname) as usize - ptr as usize } , 28usize , concat ! ("Offset of field: " , stringify ! (mcd_register_info_st) , "::" , stringify ! (regname))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . regsize) as usize - ptr as usize } , 60usize , concat ! ("Offset of field: " , stringify ! (mcd_register_info_st) , "::" , stringify ! (regsize))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . core_mode_mask_read) as usize - ptr as usize } , 64usize , concat ! ("Offset of field: " , stringify ! (mcd_register_info_st) , "::" , stringify ! (core_mode_mask_read))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . core_mode_mask_write) as usize - ptr as usize } , 68usize , concat ! ("Offset of field: " , stringify ! (mcd_register_info_st) , "::" , stringify ! (core_mode_mask_write))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . has_side_effects_read) as usize - ptr as usize } , 72usize , concat ! ("Offset of field: " , stringify ! (mcd_register_info_st) , "::" , stringify ! (has_side_effects_read))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . has_side_effects_write) as usize - ptr as usize } , 76usize , concat ! ("Offset of field: " , stringify ! (mcd_register_info_st) , "::" , stringify ! (has_side_effects_write))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . reg_type) as usize - ptr as usize } , 80usize , concat ! ("Offset of field: " , stringify ! (mcd_register_info_st) , "::" , stringify ! (reg_type))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . hw_thread_id) as usize - ptr as usize } , 84usize , concat ! ("Offset of field: " , stringify ! (mcd_register_info_st) , "::" , stringify ! (hw_thread_id))) ; } # [doc = " \\brief Structure type containing information about trigger capabilities.\n\nThis structure type contains information about the trigger capabilities of a target.\n\nNote: \\c trig_number, \\c state_number and \\c counter_number should NOT be used to determine\nif the appropriate trigger resource is available. It can just provide hints about the\nmaximum number. The availability should be checked evaluating \\c action."] # [repr (C)] # [derive (Debug , Default , Copy , Clone)] pub struct mcd_trig_info_st { # [doc = "< Supported trigger types (OR'ed bitmask)."] pub type_ : mcd_trig_type_et , # [doc = "< Supported trigger options (OR'ed bitmask)."] pub option : mcd_trig_opt_et , # [doc = "< Supported trigger actions (OR'ed bitmask)."] pub action : mcd_trig_action_et , # [doc = "< Number of usable triggers (or 0 if number not known)."] pub trig_number : u32 , # [doc = "< Number of states of the trigger set's state machine (or 0 if not known)."] pub state_number : u32 , # [doc = "< Number of usable counters (or 0 if not known)."] pub counter_number : u32 , # [doc = "< True if software breakpoints via code patch are available."] pub sw_breakpoints : mcd_bool_t , } # [test] fn bindgen_test_layout_mcd_trig_info_st () { const UNINIT : :: std :: mem :: MaybeUninit < mcd_trig_info_st > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < mcd_trig_info_st > () , 28usize , concat ! ("Size of: " , stringify ! (mcd_trig_info_st))) ; assert_eq ! (:: std :: mem :: align_of :: < mcd_trig_info_st > () , 4usize , concat ! ("Alignment of " , stringify ! (mcd_trig_info_st))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . type_) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (mcd_trig_info_st) , "::" , stringify ! (type_))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . option) as usize - ptr as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (mcd_trig_info_st) , "::" , stringify ! (option))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . action) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (mcd_trig_info_st) , "::" , stringify ! (action))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . trig_number) as usize - ptr as usize } , 12usize , concat ! ("Offset of field: " , stringify ! (mcd_trig_info_st) , "::" , stringify ! (trig_number))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . state_number) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (mcd_trig_info_st) , "::" , stringify ! (state_number))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . counter_number) as usize - ptr as usize } , 20usize , concat ! ("Offset of field: " , stringify ! (mcd_trig_info_st) , "::" , stringify ! (counter_number))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . sw_breakpoints) as usize - ptr as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (mcd_trig_info_st) , "::" , stringify ! (sw_breakpoints))) ; } # [doc = " \\brief Structure type containing information about a custom trigger.\n\nThis structure type contains information about a custom trigger. These custom triggers can be used\nvia the \\ref mcd_trig_custom_st structure type.\n\nNote: This is NOT related to custom trigger formats - they use a format not defined by the MCD API."] # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct mcd_ctrig_info_st { # [doc = "< Custom trigger ID, ID 0 is reserved."] pub ctrig_id : u32 , # [doc = "< Description of the custom trigger."] pub info_str : [mcd_char_t ; 256usize] , } # [test] fn bindgen_test_layout_mcd_ctrig_info_st () { const UNINIT : :: std :: mem :: MaybeUninit < mcd_ctrig_info_st > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < mcd_ctrig_info_st > () , 260usize , concat ! ("Size of: " , stringify ! (mcd_ctrig_info_st))) ; assert_eq ! (:: std :: mem :: align_of :: < mcd_ctrig_info_st > () , 4usize , concat ! ("Alignment of " , stringify ! (mcd_ctrig_info_st))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . ctrig_id) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (mcd_ctrig_info_st) , "::" , stringify ! (ctrig_id))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . info_str) as usize - ptr as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (mcd_ctrig_info_st) , "::" , stringify ! (info_str))) ; } impl Default for mcd_ctrig_info_st { fn default () -> Self { let mut s = :: std :: mem :: MaybeUninit :: < Self > :: uninit () ; unsafe { :: std :: ptr :: write_bytes (s . as_mut_ptr () , 0 , 1) ; s . assume_init () } } } # [doc = " \\brief Structure type containing information about a complex core trigger condition.\n\nThis structure type contains information about a complex core based trigger of the target system."] # [repr (C)] # [derive (Debug , Default , Copy , Clone)] pub struct mcd_trig_complex_core_st { # [doc = "< Size of this structure in bytes."] pub struct_size : u32 , # [doc = "< Trigger type, for this structure type it must be one of:\n- \\c MCD_TRIG_TYPE_IP\n- \\c MCD_TRIG_TYPE_READ\n- \\c MCD_TRIG_TYPE_WRITE\n- \\c MCD_TRIG_TYPE_RW\n- \\c MCD_TRIG_TYPE_NOCYCLE"] pub type_ : mcd_trig_type_et , # [doc = "< Adds further qualifiers to the trigger or overrides the behaviour\n(multiple options possible)."] pub option : mcd_trig_opt_et , # [doc = "< Action to be taken on trigger. Only one per trigger allowed."] pub action : mcd_trig_action_et , # [doc = "< Parameter for action - depends on the selected action."] pub action_param : u32 , # [doc = "< Set to \"TRUE\" on return of \\ref mcd_create_trig_f() if trigger was\nmodified by implementation, untouched otherwise."] pub modified : mcd_bool_t , # [doc = "< Set bits indicate that this trigger is inactive when reaching the\ncorresponding state of the state machine. Bit 0 represents state '1'\nof the state machine. Only to be considered if\n\\c MCD_TRIG_OPT_STATE_IS_CONDITION is set in \\c option."] pub state_mask : u32 , # [doc = "< Start address for the address range the trigger shall be activated for."] pub addr_start : mcd_addr_st , # [doc = "< Size of the address range for the trigger (in bytes).\nIf it is set to '0', the trigger is activated by an access to a single\naddress.\nIf it is set to '1', the range of addresses is two (\\c addr_start + 1).\nThe address range can be \"inverted\" if \\c MCD_TRIG_OPT_OUT_OF_RANGE is\nset in \\c option."] pub addr_range : u64 , # [doc = "< Data comparison value of the trigger. Only considered if\n\\c MCD_TRIG_OPT_DATA_IS_CONDITION is set in \\c option.\nSetting option \\c MCD_TRIG_OPT_NOT_DATA activates the trigger\non a data mismatch."] pub data_start : u64 , # [doc = "< Size of the data value range for the trigger.\nIf it is set to '0', the trigger is activated on a match with a single\nvalue.\nIf it is set to '1', the range of values is two (\\c data_range + 1).\nOption \\c MCD_TRIG_OPT_SIGNED_DATA may be set in \\c option if the data\nshall be interpreted as signed. This usually also requires the option\n\\c MCD_TRIG_OPT_DATASIZE_IS_CONDITION to be set in \\c option."] pub data_range : u64 , # [doc = "< Only value bits are considered for which the mask is set to '0'."] pub data_mask : u64 , # [doc = "< Size of the access in bytes. If set to '0' the size shall not be\nconsidered.\nShall be only considered if \\c MCD_TRIG_OPT_DATASIZE_IS_CONDITION\nis set in \\c option."] pub data_size : u32 , # [doc = "< ID of the hardware thread this trigger is associated with."] pub hw_thread_id : u32 , # [doc = "< ID of the software thread this trigger is associated with."] pub sw_thread_id : u64 , # [doc = "< Mask of core modes for which the trigger shall not be activated.\nA set bit disables the trigger for the corresponding mode.\nBit 0 represents core mode '1', bit 31 represents core mode '32'."] pub core_mode_mask : u32 , } # [test] fn bindgen_test_layout_mcd_trig_complex_core_st () { const UNINIT : :: std :: mem :: MaybeUninit < mcd_trig_complex_core_st > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < mcd_trig_complex_core_st > () , 112usize , concat ! ("Size of: " , stringify ! (mcd_trig_complex_core_st))) ; assert_eq ! (:: std :: mem :: align_of :: < mcd_trig_complex_core_st > () , 8usize , concat ! ("Alignment of " , stringify ! (mcd_trig_complex_core_st))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . struct_size) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (mcd_trig_complex_core_st) , "::" , stringify ! (struct_size))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . type_) as usize - ptr as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (mcd_trig_complex_core_st) , "::" , stringify ! (type_))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . option) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (mcd_trig_complex_core_st) , "::" , stringify ! (option))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . action) as usize - ptr as usize } , 12usize , concat ! ("Offset of field: " , stringify ! (mcd_trig_complex_core_st) , "::" , stringify ! (action))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . action_param) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (mcd_trig_complex_core_st) , "::" , stringify ! (action_param))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . modified) as usize - ptr as usize } , 20usize , concat ! ("Offset of field: " , stringify ! (mcd_trig_complex_core_st) , "::" , stringify ! (modified))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . state_mask) as usize - ptr as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (mcd_trig_complex_core_st) , "::" , stringify ! (state_mask))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . addr_start) as usize - ptr as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (mcd_trig_complex_core_st) , "::" , stringify ! (addr_start))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . addr_range) as usize - ptr as usize } , 56usize , concat ! ("Offset of field: " , stringify ! (mcd_trig_complex_core_st) , "::" , stringify ! (addr_range))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . data_start) as usize - ptr as usize } , 64usize , concat ! ("Offset of field: " , stringify ! (mcd_trig_complex_core_st) , "::" , stringify ! (data_start))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . data_range) as usize - ptr as usize } , 72usize , concat ! ("Offset of field: " , stringify ! (mcd_trig_complex_core_st) , "::" , stringify ! (data_range))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . data_mask) as usize - ptr as usize } , 80usize , concat ! ("Offset of field: " , stringify ! (mcd_trig_complex_core_st) , "::" , stringify ! (data_mask))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . data_size) as usize - ptr as usize } , 88usize , concat ! ("Offset of field: " , stringify ! (mcd_trig_complex_core_st) , "::" , stringify ! (data_size))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . hw_thread_id) as usize - ptr as usize } , 92usize , concat ! ("Offset of field: " , stringify ! (mcd_trig_complex_core_st) , "::" , stringify ! (hw_thread_id))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . sw_thread_id) as usize - ptr as usize } , 96usize , concat ! ("Offset of field: " , stringify ! (mcd_trig_complex_core_st) , "::" , stringify ! (sw_thread_id))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . core_mode_mask) as usize - ptr as usize } , 104usize , concat ! ("Offset of field: " , stringify ! (mcd_trig_complex_core_st) , "::" , stringify ! (core_mode_mask))) ; } # [doc = " \\brief Structure type containing information about a simple core trigger condition.\n\nThis structure type contains information about a simple core based trigger of the target system.\nIt is a subset of \\ref mcd_trig_complex_core_st."] # [repr (C)] # [derive (Debug , Default , Copy , Clone)] pub struct mcd_trig_simple_core_st { # [doc = "< Size of this structure in bytes."] pub struct_size : u32 , # [doc = "< Trigger type, for this structure type it must be one of:\n- \\c MCD_TRIG_TYPE_IP\n- \\c MCD_TRIG_TYPE_READ\n- \\c MCD_TRIG_TYPE_WRITE\n- \\c MCD_TRIG_TYPE_RW\n- \\c MCD_TRIG_TYPE_NOCYCLE"] pub type_ : mcd_trig_type_et , # [doc = "< Adds further qualifiers to the trigger or overrides the behaviour\n(multiple options possible)."] pub option : mcd_trig_opt_et , # [doc = "< Action to be taken on trigger. Only one per trigger allowed."] pub action : mcd_trig_action_et , # [doc = "< Parameter for action - depends on the selected action."] pub action_param : u32 , # [doc = "< Set to \"TRUE\" on return of \\ref mcd_create_trig_f() if trigger was\nmodified by implementation, untouched otherwise."] pub modified : mcd_bool_t , # [doc = "< Set bits indicate that this trigger is inactive when reaching the\ncorresponding state of the state machine. Bit 0 represents state '1'\nof the state machine. Only to be considered if\n\\c MCD_TRIG_OPT_STATE_IS_CONDITION is set in \\c option."] pub state_mask : u32 , # [doc = "< Start address for the address range the trigger shall be activated for."] pub addr_start : mcd_addr_st , # [doc = "< Size of the address range for the trigger (in bytes).\nIf it is set to '0', the trigger is activated by an access to a single\naddress.\nIf it is set to '1', the range of addresses is two (\\c addr_start + 1).\nThe address range can be \"inverted\" if \\c MCD_TRIG_OPT_OUT_OF_RANGE is\nset in \\c option."] pub addr_range : u64 , } # [test] fn bindgen_test_layout_mcd_trig_simple_core_st () { const UNINIT : :: std :: mem :: MaybeUninit < mcd_trig_simple_core_st > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < mcd_trig_simple_core_st > () , 64usize , concat ! ("Size of: " , stringify ! (mcd_trig_simple_core_st))) ; assert_eq ! (:: std :: mem :: align_of :: < mcd_trig_simple_core_st > () , 8usize , concat ! ("Alignment of " , stringify ! (mcd_trig_simple_core_st))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . struct_size) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (mcd_trig_simple_core_st) , "::" , stringify ! (struct_size))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . type_) as usize - ptr as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (mcd_trig_simple_core_st) , "::" , stringify ! (type_))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . option) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (mcd_trig_simple_core_st) , "::" , stringify ! (option))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . action) as usize - ptr as usize } , 12usize , concat ! ("Offset of field: " , stringify ! (mcd_trig_simple_core_st) , "::" , stringify ! (action))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . action_param) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (mcd_trig_simple_core_st) , "::" , stringify ! (action_param))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . modified) as usize - ptr as usize } , 20usize , concat ! ("Offset of field: " , stringify ! (mcd_trig_simple_core_st) , "::" , stringify ! (modified))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . state_mask) as usize - ptr as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (mcd_trig_simple_core_st) , "::" , stringify ! (state_mask))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . addr_start) as usize - ptr as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (mcd_trig_simple_core_st) , "::" , stringify ! (addr_start))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . addr_range) as usize - ptr as usize } , 56usize , concat ! ("Offset of field: " , stringify ! (mcd_trig_simple_core_st) , "::" , stringify ! (addr_range))) ; } # [doc = " \\brief Structure type containing information about a trigger bus based trigger condition.\n\nTrigger buses exist that can be optionally activated. This structure type contains information\nabout a trigger on the target system based on such a trigger bus.\n\nA trigger bus is split into a core local trigger (bits 0 to 15) and a global trigger (bits 16 to 31).\nOn real silicon some bits of the trigger bus may also be available on device pins."] # [repr (C)] # [derive (Debug , Default , Copy , Clone)] pub struct mcd_trig_trig_bus_st { # [doc = "< Size of this structure in bytes."] pub struct_size : u32 , # [doc = "< Trigger type, for this structure type it must be:\n- \\c MCD_TRIG_TYPE_TRIG_BUS"] pub type_ : mcd_trig_type_et , # [doc = "< Trigger options, for this structure the following are allowed:\n- \\c MCD_TRIG_OPT_NOT\n- \\c MCD_TRIG_OPT_STATE_IS_CONDITION"] pub option : mcd_trig_opt_et , # [doc = "< Action to be taken on trigger. Only one per trigger allowed."] pub action : mcd_trig_action_et , # [doc = "< Parameter for action - depends on the selected action."] pub action_param : u32 , # [doc = "< Set to \"TRUE\" on return of \\ref mcd_create_trig_f() if trigger was\nmodified by implementation, untouched otherwise."] pub modified : mcd_bool_t , # [doc = "< Set bits indicate that this trigger is inactive when reaching the\ncorresponding state of the state machine. Bit 0 represents state '1'\nof the state machine. Only to be considered if\n\\c MCD_TRIG_OPT_STATE_IS_CONDITION is set in \\c option."] pub state_mask : u32 , # [doc = "< Trigger bus value."] pub trig_bus_value : u32 , # [doc = "< Only value bits are considered for which the bitmask is set to '0'."] pub trig_bus_mask : u32 , } # [test] fn bindgen_test_layout_mcd_trig_trig_bus_st () { const UNINIT : :: std :: mem :: MaybeUninit < mcd_trig_trig_bus_st > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < mcd_trig_trig_bus_st > () , 36usize , concat ! ("Size of: " , stringify ! (mcd_trig_trig_bus_st))) ; assert_eq ! (:: std :: mem :: align_of :: < mcd_trig_trig_bus_st > () , 4usize , concat ! ("Alignment of " , stringify ! (mcd_trig_trig_bus_st))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . struct_size) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (mcd_trig_trig_bus_st) , "::" , stringify ! (struct_size))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . type_) as usize - ptr as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (mcd_trig_trig_bus_st) , "::" , stringify ! (type_))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . option) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (mcd_trig_trig_bus_st) , "::" , stringify ! (option))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . action) as usize - ptr as usize } , 12usize , concat ! ("Offset of field: " , stringify ! (mcd_trig_trig_bus_st) , "::" , stringify ! (action))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . action_param) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (mcd_trig_trig_bus_st) , "::" , stringify ! (action_param))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . modified) as usize - ptr as usize } , 20usize , concat ! ("Offset of field: " , stringify ! (mcd_trig_trig_bus_st) , "::" , stringify ! (modified))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . state_mask) as usize - ptr as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (mcd_trig_trig_bus_st) , "::" , stringify ! (state_mask))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . trig_bus_value) as usize - ptr as usize } , 28usize , concat ! ("Offset of field: " , stringify ! (mcd_trig_trig_bus_st) , "::" , stringify ! (trig_bus_value))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . trig_bus_mask) as usize - ptr as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (mcd_trig_trig_bus_st) , "::" , stringify ! (trig_bus_mask))) ; } # [doc = " \\brief Structure type containing information about a trigger counter on the target.\n\nThis structure type contains information about a trigger counter on the target system."] # [repr (C)] # [derive (Debug , Default , Copy , Clone)] pub struct mcd_trig_counter_st { # [doc = "< Size of this structure in bytes."] pub struct_size : u32 , # [doc = "< Trigger type, for this structure type it must be:\n- \\c MCD_TRIG_TYPE_TRIG_COUNTER"] pub type_ : mcd_trig_type_et , # [doc = "< Trigger options, for this structure the following are allowed:\n- \\c MCD_TRIG_OPT_NOT\n- \\c MCD_TRIG_OPT_STATE_IS_CONDITION"] pub option : mcd_trig_opt_et , # [doc = "< Action to be taken on trigger. Only one per trigger allowed."] pub action : mcd_trig_action_et , # [doc = "< Parameter for action - depends on the selected action."] pub action_param : u32 , # [doc = "< Set to \"TRUE\" on return of \\ref mcd_create_trig_f() if trigger was\nmodified by implementation, untouched otherwise."] pub modified : mcd_bool_t , # [doc = "< Set bits indicate that this trigger is inactive when reaching the\ncorresponding state of the state machine. Bit 0 represents state '1'\nof the state machine. Only to be considered if\n\\c MCD_TRIG_OPT_STATE_IS_CONDITION is set in \\c option."] pub state_mask : u32 , # [doc = "< Current value of counter."] pub count_value : u64 , # [doc = "< Reload value of counter."] pub reload_value : u64 , } # [test] fn bindgen_test_layout_mcd_trig_counter_st () { const UNINIT : :: std :: mem :: MaybeUninit < mcd_trig_counter_st > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < mcd_trig_counter_st > () , 48usize , concat ! ("Size of: " , stringify ! (mcd_trig_counter_st))) ; assert_eq ! (:: std :: mem :: align_of :: < mcd_trig_counter_st > () , 8usize , concat ! ("Alignment of " , stringify ! (mcd_trig_counter_st))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . struct_size) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (mcd_trig_counter_st) , "::" , stringify ! (struct_size))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . type_) as usize - ptr as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (mcd_trig_counter_st) , "::" , stringify ! (type_))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . option) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (mcd_trig_counter_st) , "::" , stringify ! (option))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . action) as usize - ptr as usize } , 12usize , concat ! ("Offset of field: " , stringify ! (mcd_trig_counter_st) , "::" , stringify ! (action))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . action_param) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (mcd_trig_counter_st) , "::" , stringify ! (action_param))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . modified) as usize - ptr as usize } , 20usize , concat ! ("Offset of field: " , stringify ! (mcd_trig_counter_st) , "::" , stringify ! (modified))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . state_mask) as usize - ptr as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (mcd_trig_counter_st) , "::" , stringify ! (state_mask))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . count_value) as usize - ptr as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (mcd_trig_counter_st) , "::" , stringify ! (count_value))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . reload_value) as usize - ptr as usize } , 40usize , concat ! ("Offset of field: " , stringify ! (mcd_trig_counter_st) , "::" , stringify ! (reload_value))) ; } # [doc = " \\brief Structure type containing information about a custom trigger on the target.\n\nThis structure type contains information about a custom trigger on the target system."] # [repr (C)] # [derive (Debug , Default , Copy , Clone)] pub struct mcd_trig_custom_st { # [doc = "< Size of this structure in bytes."] pub struct_size : u32 , # [doc = "< Trigger type, for this structure type it must be:\n- \\c MCD_TRIG_TYPE_CUSTOM"] pub type_ : mcd_trig_type_et , # [doc = "< Trigger options, for this structure the following are allowed:\n- \\c MCD_TRIG_OPT_NOT\n- \\c MCD_TRIG_OPT_STATE_IS_CONDITION"] pub option : mcd_trig_opt_et , # [doc = "< Action to be taken on trigger. Only one per trigger allowed."] pub action : mcd_trig_action_et , # [doc = "< Parameter for action - depends on the selected action."] pub action_param : u32 , # [doc = "< Set to \"TRUE\" on return of \\ref mcd_create_trig_f() if trigger was\nmodified by implementation, untouched otherwise."] pub modified : mcd_bool_t , # [doc = "< Set bits indicate that this trigger is inactive when reaching the\ncorresponding state of the state machine. Bit 0 represents state '1'\nof the state machine. Only to be considered if\n\\c MCD_TRIG_OPT_STATE_IS_CONDITION is set in \\c option."] pub state_mask : u32 , # [doc = "< Custom trigger ID."] pub ctrig_id : u32 , # [doc = "< Custom trigger arguments."] pub ctrig_args : [u32 ; 4usize] , } # [test] fn bindgen_test_layout_mcd_trig_custom_st () { const UNINIT : :: std :: mem :: MaybeUninit < mcd_trig_custom_st > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < mcd_trig_custom_st > () , 48usize , concat ! ("Size of: " , stringify ! (mcd_trig_custom_st))) ; assert_eq ! (:: std :: mem :: align_of :: < mcd_trig_custom_st > () , 4usize , concat ! ("Alignment of " , stringify ! (mcd_trig_custom_st))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . struct_size) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (mcd_trig_custom_st) , "::" , stringify ! (struct_size))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . type_) as usize - ptr as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (mcd_trig_custom_st) , "::" , stringify ! (type_))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . option) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (mcd_trig_custom_st) , "::" , stringify ! (option))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . action) as usize - ptr as usize } , 12usize , concat ! ("Offset of field: " , stringify ! (mcd_trig_custom_st) , "::" , stringify ! (action))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . action_param) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (mcd_trig_custom_st) , "::" , stringify ! (action_param))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . modified) as usize - ptr as usize } , 20usize , concat ! ("Offset of field: " , stringify ! (mcd_trig_custom_st) , "::" , stringify ! (modified))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . state_mask) as usize - ptr as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (mcd_trig_custom_st) , "::" , stringify ! (state_mask))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . ctrig_id) as usize - ptr as usize } , 28usize , concat ! ("Offset of field: " , stringify ! (mcd_trig_custom_st) , "::" , stringify ! (ctrig_id))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . ctrig_args) as usize - ptr as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (mcd_trig_custom_st) , "::" , stringify ! (ctrig_args))) ; } # [doc = " \\brief Structure type containing a trigger state.\n\nThis structure type contains the state of a single trigger on the target system."] # [repr (C)] # [derive (Debug , Default , Copy , Clone)] pub struct mcd_trig_state_st { # [doc = "< Was active at the point of time the trigger set was uploaded."] pub active : mcd_bool_t , # [doc = "< Activated at least once after trigger got downloaded to the target."] pub captured : mcd_bool_t , # [doc = "< The information in \\c captured is valid."] pub captured_valid : mcd_bool_t , # [doc = "< Current value of the counter (for counter triggers)."] pub count_value : u64 , # [doc = "< The information in \\c count_value is valid."] pub count_valid : mcd_bool_t , } # [test] fn bindgen_test_layout_mcd_trig_state_st () { const UNINIT : :: std :: mem :: MaybeUninit < mcd_trig_state_st > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < mcd_trig_state_st > () , 32usize , concat ! ("Size of: " , stringify ! (mcd_trig_state_st))) ; assert_eq ! (:: std :: mem :: align_of :: < mcd_trig_state_st > () , 8usize , concat ! ("Alignment of " , stringify ! (mcd_trig_state_st))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . active) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (mcd_trig_state_st) , "::" , stringify ! (active))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . captured) as usize - ptr as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (mcd_trig_state_st) , "::" , stringify ! (captured))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . captured_valid) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (mcd_trig_state_st) , "::" , stringify ! (captured_valid))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . count_value) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (mcd_trig_state_st) , "::" , stringify ! (count_value))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . count_valid) as usize - ptr as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (mcd_trig_state_st) , "::" , stringify ! (count_valid))) ; } # [doc = " \\brief Structure type containing a trigger set state.\n\nThis structure type contains the state of the trigger set of the target system."] # [repr (C)] # [derive (Debug , Default , Copy , Clone)] pub struct mcd_trig_set_state_st { # [doc = "< Set if the trigger set is currently active."] pub active : mcd_bool_t , # [doc = "< Current state of the trigger set's state machine."] pub state : u32 , # [doc = "< Current state is valid."] pub state_valid : mcd_bool_t , # [doc = "< Current state of trigger bus."] pub trig_bus : u32 , # [doc = "< Current state of trig_bus is valid."] pub trig_bus_valid : mcd_bool_t , # [doc = "< Current state of trace start/stop."] pub trace : mcd_bool_t , # [doc = "< Current state is valid."] pub trace_valid : mcd_bool_t , # [doc = "< Current state of performance analysis start/stop."] pub analysis : mcd_bool_t , # [doc = "< Current state is valid."] pub analysis_valid : mcd_bool_t , } # [test] fn bindgen_test_layout_mcd_trig_set_state_st () { const UNINIT : :: std :: mem :: MaybeUninit < mcd_trig_set_state_st > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < mcd_trig_set_state_st > () , 36usize , concat ! ("Size of: " , stringify ! (mcd_trig_set_state_st))) ; assert_eq ! (:: std :: mem :: align_of :: < mcd_trig_set_state_st > () , 4usize , concat ! ("Alignment of " , stringify ! (mcd_trig_set_state_st))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . active) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (mcd_trig_set_state_st) , "::" , stringify ! (active))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . state) as usize - ptr as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (mcd_trig_set_state_st) , "::" , stringify ! (state))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . state_valid) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (mcd_trig_set_state_st) , "::" , stringify ! (state_valid))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . trig_bus) as usize - ptr as usize } , 12usize , concat ! ("Offset of field: " , stringify ! (mcd_trig_set_state_st) , "::" , stringify ! (trig_bus))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . trig_bus_valid) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (mcd_trig_set_state_st) , "::" , stringify ! (trig_bus_valid))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . trace) as usize - ptr as usize } , 20usize , concat ! ("Offset of field: " , stringify ! (mcd_trig_set_state_st) , "::" , stringify ! (trace))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . trace_valid) as usize - ptr as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (mcd_trig_set_state_st) , "::" , stringify ! (trace_valid))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . analysis) as usize - ptr as usize } , 28usize , concat ! ("Offset of field: " , stringify ! (mcd_trig_set_state_st) , "::" , stringify ! (analysis))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . analysis_valid) as usize - ptr as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (mcd_trig_set_state_st) , "::" , stringify ! (analysis_valid))) ; } # [doc = " \\brief Structure type containing information about a single transaction.\n\nThis structure type contains all information required for a single transaction. The\ntransaction itself can be a memory read/write operation or a register read/write operation.\n\nFor memory access transactions, the data is stored to the buffer in the target's endianess format.\nFor register access transaction, the data is stored to the buffer in Little Endian format. Targets\nneed to read/fill the buffer, accordingly."] # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct mcd_tx_st { # [doc = "< The address of the first memory cell/register."] pub addr : mcd_addr_st , # [doc = "< Type of access: Read/Write/Read+Write/Write+Verify."] pub access_type : mcd_tx_access_type_et , # [doc = "< Access options: burst, side-effects, alternate path, cache, etc."] pub options : mcd_tx_access_opt_et , # [doc = "< Access size in bytes (or 0 if access size does not matter)."] pub access_width : u8 , # [doc = "< The core mode in which the access should be performed (or 0 for\nmost permissive mode)."] pub core_mode : u8 , # [doc = "< Byte array of size \\c num_bytes storing the access data."] pub data : * mut u8 , # [doc = "< Size of the memory/register access. The buffer \\c data needs to\nbe of this size."] pub num_bytes : u32 , # [doc = "< Number of successfully received/sent bytes."] pub num_bytes_ok : u32 , } # [test] fn bindgen_test_layout_mcd_tx_st () { const UNINIT : :: std :: mem :: MaybeUninit < mcd_tx_st > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < mcd_tx_st > () , 56usize , concat ! ("Size of: " , stringify ! (mcd_tx_st))) ; assert_eq ! (:: std :: mem :: align_of :: < mcd_tx_st > () , 8usize , concat ! ("Alignment of " , stringify ! (mcd_tx_st))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . addr) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (mcd_tx_st) , "::" , stringify ! (addr))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . access_type) as usize - ptr as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (mcd_tx_st) , "::" , stringify ! (access_type))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . options) as usize - ptr as usize } , 28usize , concat ! ("Offset of field: " , stringify ! (mcd_tx_st) , "::" , stringify ! (options))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . access_width) as usize - ptr as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (mcd_tx_st) , "::" , stringify ! (access_width))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . core_mode) as usize - ptr as usize } , 33usize , concat ! ("Offset of field: " , stringify ! (mcd_tx_st) , "::" , stringify ! (core_mode))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . data) as usize - ptr as usize } , 40usize , concat ! ("Offset of field: " , stringify ! (mcd_tx_st) , "::" , stringify ! (data))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . num_bytes) as usize - ptr as usize } , 48usize , concat ! ("Offset of field: " , stringify ! (mcd_tx_st) , "::" , stringify ! (num_bytes))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . num_bytes_ok) as usize - ptr as usize } , 52usize , concat ! ("Offset of field: " , stringify ! (mcd_tx_st) , "::" , stringify ! (num_bytes_ok))) ; } impl Default for mcd_tx_st { fn default () -> Self { let mut s = :: std :: mem :: MaybeUninit :: < Self > :: uninit () ; unsafe { :: std :: ptr :: write_bytes (s . as_mut_ptr () , 0 , 1) ; s . assume_init () } } } # [doc = " \\brief Structure type containing a transaction list.\n\nThis structure type contains a transaction list."] # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct mcd_txlist_st { # [doc = "< Array of size \\c num_tx storing the transactions."] pub tx : * mut mcd_tx_st , # [doc = "< Number of transactions."] pub num_tx : u32 , # [doc = "< Number of transactions which succeeded without any errors."] pub num_tx_ok : u32 , } # [test] fn bindgen_test_layout_mcd_txlist_st () { const UNINIT : :: std :: mem :: MaybeUninit < mcd_txlist_st > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < mcd_txlist_st > () , 16usize , concat ! ("Size of: " , stringify ! (mcd_txlist_st))) ; assert_eq ! (:: std :: mem :: align_of :: < mcd_txlist_st > () , 8usize , concat ! ("Alignment of " , stringify ! (mcd_txlist_st))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . tx) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (mcd_txlist_st) , "::" , stringify ! (tx))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . num_tx) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (mcd_txlist_st) , "::" , stringify ! (num_tx))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . num_tx_ok) as usize - ptr as usize } , 12usize , concat ! ("Offset of field: " , stringify ! (mcd_txlist_st) , "::" , stringify ! (num_tx_ok))) ; } impl Default for mcd_txlist_st { fn default () -> Self { let mut s = :: std :: mem :: MaybeUninit :: < Self > :: uninit () ; unsafe { :: std :: ptr :: write_bytes (s . as_mut_ptr () , 0 , 1) ; s . assume_init () } } } # [doc = " \\brief Structure type containing the state of a core.\n\nThis structure type contains information about the state of a core.\n\nNote that the additional information provided in \\c info_str is not a repetition of the\ngeneral core state provided by \\c state."] # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct mcd_core_state_st { # [doc = "< Core state."] pub state : mcd_core_state_et , # [doc = "< Core events (OR'ed bitmask)"] pub event : mcd_core_event_et , # [doc = "< ID of the hardware thread that caused the core to stop."] pub hw_thread_id : u32 , # [doc = "< ID of the trigger that caused the core to stop."] pub trig_id : u32 , # [doc = "< Detailed description of a special stop reason."] pub stop_str : [mcd_char_t ; 256usize] , # [doc = "< Detailed description of the core state."] pub info_str : [mcd_char_t ; 256usize] , } # [test] fn bindgen_test_layout_mcd_core_state_st () { const UNINIT : :: std :: mem :: MaybeUninit < mcd_core_state_st > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < mcd_core_state_st > () , 528usize , concat ! ("Size of: " , stringify ! (mcd_core_state_st))) ; assert_eq ! (:: std :: mem :: align_of :: < mcd_core_state_st > () , 4usize , concat ! ("Alignment of " , stringify ! (mcd_core_state_st))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . state) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (mcd_core_state_st) , "::" , stringify ! (state))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . event) as usize - ptr as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (mcd_core_state_st) , "::" , stringify ! (event))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . hw_thread_id) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (mcd_core_state_st) , "::" , stringify ! (hw_thread_id))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . trig_id) as usize - ptr as usize } , 12usize , concat ! ("Offset of field: " , stringify ! (mcd_core_state_st) , "::" , stringify ! (trig_id))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . stop_str) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (mcd_core_state_st) , "::" , stringify ! (stop_str))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . info_str) as usize - ptr as usize } , 272usize , concat ! ("Offset of field: " , stringify ! (mcd_core_state_st) , "::" , stringify ! (info_str))) ; } impl Default for mcd_core_state_st { fn default () -> Self { let mut s = :: std :: mem :: MaybeUninit :: < Self > :: uninit () ; unsafe { :: std :: ptr :: write_bytes (s . as_mut_ptr () , 0 , 1) ; s . assume_init () } } } # [doc = " \\brief Structure type containing information about a particular reset class.\n\nThis structure type contains information about a particular reset class. Only a single bit of the\n32 bit field \\c class_vector can be '1'. It represents the reset class for this particular reset.\nAt target system level, there cannot be two objects of type \\ref mcd_rst_info_st bound to the same\nreset class."] # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct mcd_rst_info_st { # [doc = "< Reset class vector which issues this\nreset. Exactly one bit may be set."] pub class_vector : u32 , # [doc = "< Description of the reset class."] pub info_str : [mcd_char_t ; 256usize] , } # [test] fn bindgen_test_layout_mcd_rst_info_st () { const UNINIT : :: std :: mem :: MaybeUninit < mcd_rst_info_st > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < mcd_rst_info_st > () , 260usize , concat ! ("Size of: " , stringify ! (mcd_rst_info_st))) ; assert_eq ! (:: std :: mem :: align_of :: < mcd_rst_info_st > () , 4usize , concat ! ("Alignment of " , stringify ! (mcd_rst_info_st))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . class_vector) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (mcd_rst_info_st) , "::" , stringify ! (class_vector))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . info_str) as usize - ptr as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (mcd_rst_info_st) , "::" , stringify ! (info_str))) ; } impl Default for mcd_rst_info_st { fn default () -> Self { let mut s = :: std :: mem :: MaybeUninit :: < Self > :: uninit () ; unsafe { :: std :: ptr :: write_bytes (s . as_mut_ptr () , 0 , 1) ; s . assume_init () } } } # [doc = " \\brief Structure type containing information about communication channels.\n\nThis structure type contains information about the setup of a communication channel\nand about its properties."] # [repr (C)] # [derive (Debug , Default , Copy , Clone)] pub struct mcd_chl_st { # [doc = "< Channel ID."] pub chl_id : u32 , # [doc = "< Type of the requested channel."] pub type_ : mcd_chl_type_et , # [doc = "< Attributes the requested channel has to provide."] pub attributes : mcd_chl_attributes_et , # [doc = "< Maximum message length (e.g. size of the message buffer\nas specified by \\c msg_buffer_addr)"] pub max_msg_len : u32 , # [doc = "< Address of the message buffer for memory mapped channels."] pub msg_buffer_addr : mcd_addr_st , # [doc = "< Channel priority for a prioritized channel.\nRange is from 0 (highest priority) to MCD_CHL_LOWEST_PRIO."] pub prio : u8 , } # [test] fn bindgen_test_layout_mcd_chl_st () { const UNINIT : :: std :: mem :: MaybeUninit < mcd_chl_st > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < mcd_chl_st > () , 48usize , concat ! ("Size of: " , stringify ! (mcd_chl_st))) ; assert_eq ! (:: std :: mem :: align_of :: < mcd_chl_st > () , 8usize , concat ! ("Alignment of " , stringify ! (mcd_chl_st))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . chl_id) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (mcd_chl_st) , "::" , stringify ! (chl_id))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . type_) as usize - ptr as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (mcd_chl_st) , "::" , stringify ! (type_))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . attributes) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (mcd_chl_st) , "::" , stringify ! (attributes))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . max_msg_len) as usize - ptr as usize } , 12usize , concat ! ("Offset of field: " , stringify ! (mcd_chl_st) , "::" , stringify ! (max_msg_len))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . msg_buffer_addr) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (mcd_chl_st) , "::" , stringify ! (msg_buffer_addr))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . prio) as usize - ptr as usize } , 40usize , concat ! ("Offset of field: " , stringify ! (mcd_chl_st) , "::" , stringify ! (prio))) ; } # [doc = " \\brief Structure type containing information about a trace.\n\nThis structure type contains information about a trace.\n\nA detailed description for a few member fields of \\ref mcd_trace_info_st is provided below:\n- \\c trace_id            : This ID is used to identify the trace by all trace related functions.\n- \\c trace_no_timestamps : Is set if the target has no global \"time\" concept. It may still provide\nclock cycle information.\n- \\c trace_shared        : Is set if the trace buffer used by this trace is shared with other traces.\n- \\c trace_size_is_bytes : Is set when the tracebuffer size (in \\ref mcd_trace_state_st) is defined in\nbytes instead of frames."] # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct mcd_trace_info_st { # [doc = "< ID of this trace source, ID 0 is reserved."] pub trace_id : u32 , # [doc = "< Trace source name."] pub trace_name : [mcd_char_t ; 256usize] , # [doc = "< Type of this trace."] pub trace_type : mcd_trace_type_et , # [doc = "< Used trace data format."] pub trace_format : mcd_trace_format_et , # [doc = "< Possible modes of this trace (OR'ed bitmask)."] pub trace_modes : mcd_trace_mode_et , # [doc = "< Target has no real timestamping."] pub trace_no_timestamps : mcd_bool_t , # [doc = "< Trace buffer is shared between cores."] pub trace_shared : mcd_bool_t , # [doc = "< Trace size is defined in bytes instead of frames."] pub trace_size_is_bytes : mcd_bool_t , } # [test] fn bindgen_test_layout_mcd_trace_info_st () { const UNINIT : :: std :: mem :: MaybeUninit < mcd_trace_info_st > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < mcd_trace_info_st > () , 284usize , concat ! ("Size of: " , stringify ! (mcd_trace_info_st))) ; assert_eq ! (:: std :: mem :: align_of :: < mcd_trace_info_st > () , 4usize , concat ! ("Alignment of " , stringify ! (mcd_trace_info_st))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . trace_id) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (mcd_trace_info_st) , "::" , stringify ! (trace_id))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . trace_name) as usize - ptr as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (mcd_trace_info_st) , "::" , stringify ! (trace_name))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . trace_type) as usize - ptr as usize } , 260usize , concat ! ("Offset of field: " , stringify ! (mcd_trace_info_st) , "::" , stringify ! (trace_type))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . trace_format) as usize - ptr as usize } , 264usize , concat ! ("Offset of field: " , stringify ! (mcd_trace_info_st) , "::" , stringify ! (trace_format))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . trace_modes) as usize - ptr as usize } , 268usize , concat ! ("Offset of field: " , stringify ! (mcd_trace_info_st) , "::" , stringify ! (trace_modes))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . trace_no_timestamps) as usize - ptr as usize } , 272usize , concat ! ("Offset of field: " , stringify ! (mcd_trace_info_st) , "::" , stringify ! (trace_no_timestamps))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . trace_shared) as usize - ptr as usize } , 276usize , concat ! ("Offset of field: " , stringify ! (mcd_trace_info_st) , "::" , stringify ! (trace_shared))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . trace_size_is_bytes) as usize - ptr as usize } , 280usize , concat ! ("Offset of field: " , stringify ! (mcd_trace_info_st) , "::" , stringify ! (trace_size_is_bytes))) ; } impl Default for mcd_trace_info_st { fn default () -> Self { let mut s = :: std :: mem :: MaybeUninit :: < Self > :: uninit () ; unsafe { :: std :: ptr :: write_bytes (s . as_mut_ptr () , 0 , 1) ; s . assume_init () } } } # [doc = " \\brief Structure type containing the trace state.\n\nThis structure type contains information about the trace state.\n\nNote that the additional information provided by \\c info_str is no repitition of the\ngeneral trace state provided by \\c state.\n\nA detailed description for a few member fields of \\ref mcd_trace_state_st is provided below:\n- \\c wraparound          : Set if the frame counter has wrapped around (in FIFO mode) or overflowed\n(in PIPE mode).\n- \\c count               : Counts frames, but is not reset due to a wraparound if running in FIFO\nmode (serves as progress indicator).\n- \\c size                : Maximum size of trace, either in frames or in bytes.\n- \\c trigger_delay       : Trigger delay. Input has the same unit as \\c size (frames or bytes).\nOutput is the actually elapsed number of frames.\n- \\c timestamp_accuracy  : Accuracy of timestamping in percent (0 to 100). Higher values indicate\nmore accurate timestamps.\n- \\c timestamp_is_time   : Set when timestamp is a time value (in picoseconds). Otherwise it\nrepresents clock cycles.\n- \\c modified            : Set on return from \\ref mcd_set_trace_state_f when implementation could not\nexactly match requests.\n- \\c info_str            : Additional information about the trace (only special state information)."] # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct mcd_trace_state_st { # [doc = "< Trace state."] pub state : mcd_trace_state_et , # [doc = "< Trace buffer mode."] pub mode : mcd_trace_mode_et , # [doc = "< Trace's ARM/OFF state follows core run state."] pub autoarm : mcd_bool_t , # [doc = "< Set if trace buffer has wrapped around."] pub wraparound : mcd_bool_t , # [doc = "< Number of valid trace frames in the buffer."] pub frames : u64 , # [doc = "< Number of valid trace frames, continues after\nwraparound."] pub count : u64 , # [doc = "< Maximum size of trace (frames or bytes)."] pub size : u64 , # [doc = "< Trigger delay."] pub trigger_delay : u64 , # [doc = "< Accuracy of timestamping in percent (0 to 100)."] pub timestamp_accuracy : u8 , # [doc = "< Timestamp is in picoseconds."] pub timestamp_is_time : mcd_bool_t , # [doc = "< Implementation specific options."] pub options : u32 , # [doc = "< Settings have been modified by implementation."] pub modified : mcd_bool_t , # [doc = "< Optional description of the trace state."] pub info_str : [mcd_char_t ; 256usize] , } # [test] fn bindgen_test_layout_mcd_trace_state_st () { const UNINIT : :: std :: mem :: MaybeUninit < mcd_trace_state_st > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < mcd_trace_state_st > () , 320usize , concat ! ("Size of: " , stringify ! (mcd_trace_state_st))) ; assert_eq ! (:: std :: mem :: align_of :: < mcd_trace_state_st > () , 8usize , concat ! ("Alignment of " , stringify ! (mcd_trace_state_st))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . state) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (mcd_trace_state_st) , "::" , stringify ! (state))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . mode) as usize - ptr as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (mcd_trace_state_st) , "::" , stringify ! (mode))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . autoarm) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (mcd_trace_state_st) , "::" , stringify ! (autoarm))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . wraparound) as usize - ptr as usize } , 12usize , concat ! ("Offset of field: " , stringify ! (mcd_trace_state_st) , "::" , stringify ! (wraparound))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . frames) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (mcd_trace_state_st) , "::" , stringify ! (frames))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . count) as usize - ptr as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (mcd_trace_state_st) , "::" , stringify ! (count))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . size) as usize - ptr as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (mcd_trace_state_st) , "::" , stringify ! (size))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . trigger_delay) as usize - ptr as usize } , 40usize , concat ! ("Offset of field: " , stringify ! (mcd_trace_state_st) , "::" , stringify ! (trigger_delay))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . timestamp_accuracy) as usize - ptr as usize } , 48usize , concat ! ("Offset of field: " , stringify ! (mcd_trace_state_st) , "::" , stringify ! (timestamp_accuracy))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . timestamp_is_time) as usize - ptr as usize } , 52usize , concat ! ("Offset of field: " , stringify ! (mcd_trace_state_st) , "::" , stringify ! (timestamp_is_time))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . options) as usize - ptr as usize } , 56usize , concat ! ("Offset of field: " , stringify ! (mcd_trace_state_st) , "::" , stringify ! (options))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . modified) as usize - ptr as usize } , 60usize , concat ! ("Offset of field: " , stringify ! (mcd_trace_state_st) , "::" , stringify ! (modified))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . info_str) as usize - ptr as usize } , 64usize , concat ! ("Offset of field: " , stringify ! (mcd_trace_state_st) , "::" , stringify ! (info_str))) ; } impl Default for mcd_trace_state_st { fn default () -> Self { let mut s = :: std :: mem :: MaybeUninit :: < Self > :: uninit () ; unsafe { :: std :: ptr :: write_bytes (s . as_mut_ptr () , 0 , 1) ; s . assume_init () } } } # [doc = " \\brief Structure type containing simple core trace data.\n\nThis structure type contains simple trace data of cores and buses.\n\nA detailed description for a few member fields of \\ref mcd_trace_data_core_st is provided below:\n- \\c data_width            : Data width (in bytes), zero if \\c data_mask is used.\n- \\c data_mask             : Data bitmask, set bits indicate that the related byte in \"data\" is valid.\nZero if \\c data_width is used.\n- \\c source                : Additional source information (hardware thread ID, bus initiator, etc.).\n- \\c aux_info              : Auxiliary information, e.g. endianess, burst information or core execution mode."] # [repr (C)] # [derive (Debug , Default , Copy , Clone)] pub struct mcd_trace_data_core_st { # [doc = "< Timestamp of this cycle (picoseconds or clock cycles)."] pub timestamp : u64 , # [doc = "< Markers for this cycle."] pub marker : mcd_trace_marker_et , # [doc = "< Basic cycle type."] pub cycle : mcd_trace_cycle_et , # [doc = "< Address."] pub addr : mcd_addr_st , # [doc = "< Data (code length for program flow)."] pub data : u64 , # [doc = "< Width of data (in bytes)."] pub data_width : u8 , # [doc = "< Bitmask for valid bytes in \\c data."] pub data_mask : u8 , # [doc = "< Additional source information."] pub source : u16 , # [doc = "< Auxiliary information."] pub aux_info : u32 , } # [test] fn bindgen_test_layout_mcd_trace_data_core_st () { const UNINIT : :: std :: mem :: MaybeUninit < mcd_trace_data_core_st > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < mcd_trace_data_core_st > () , 56usize , concat ! ("Size of: " , stringify ! (mcd_trace_data_core_st))) ; assert_eq ! (:: std :: mem :: align_of :: < mcd_trace_data_core_st > () , 8usize , concat ! ("Alignment of " , stringify ! (mcd_trace_data_core_st))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . timestamp) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (mcd_trace_data_core_st) , "::" , stringify ! (timestamp))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . marker) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (mcd_trace_data_core_st) , "::" , stringify ! (marker))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . cycle) as usize - ptr as usize } , 12usize , concat ! ("Offset of field: " , stringify ! (mcd_trace_data_core_st) , "::" , stringify ! (cycle))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . addr) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (mcd_trace_data_core_st) , "::" , stringify ! (addr))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . data) as usize - ptr as usize } , 40usize , concat ! ("Offset of field: " , stringify ! (mcd_trace_data_core_st) , "::" , stringify ! (data))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . data_width) as usize - ptr as usize } , 48usize , concat ! ("Offset of field: " , stringify ! (mcd_trace_data_core_st) , "::" , stringify ! (data_width))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . data_mask) as usize - ptr as usize } , 49usize , concat ! ("Offset of field: " , stringify ! (mcd_trace_data_core_st) , "::" , stringify ! (data_mask))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . source) as usize - ptr as usize } , 50usize , concat ! ("Offset of field: " , stringify ! (mcd_trace_data_core_st) , "::" , stringify ! (source))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . aux_info) as usize - ptr as usize } , 52usize , concat ! ("Offset of field: " , stringify ! (mcd_trace_data_core_st) , "::" , stringify ! (aux_info))) ; } # [doc = " \\brief Structure type containing logic analyzer trace data.\n\nThis structure type contains \"logic analyzer\"-like trace data (256 channels)."] # [repr (C)] # [derive (Debug , Default , Copy , Clone)] pub struct mcd_trace_data_event_st { # [doc = "< Timestamp of this cycle (either picoseconds or clock cycles)."] pub timestamp : u64 , # [doc = "< Markers for this cycle."] pub marker : mcd_trace_marker_et , # [doc = "< User data, array of 256 bits. LSB of data[0] represents channel 0."] pub data : [u32 ; 8usize] , } # [test] fn bindgen_test_layout_mcd_trace_data_event_st () { const UNINIT : :: std :: mem :: MaybeUninit < mcd_trace_data_event_st > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < mcd_trace_data_event_st > () , 48usize , concat ! ("Size of: " , stringify ! (mcd_trace_data_event_st))) ; assert_eq ! (:: std :: mem :: align_of :: < mcd_trace_data_event_st > () , 8usize , concat ! ("Alignment of " , stringify ! (mcd_trace_data_event_st))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . timestamp) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (mcd_trace_data_event_st) , "::" , stringify ! (timestamp))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . marker) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (mcd_trace_data_event_st) , "::" , stringify ! (marker))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . data) as usize - ptr as usize } , 12usize , concat ! ("Offset of field: " , stringify ! (mcd_trace_data_event_st) , "::" , stringify ! (data))) ; } # [doc = " \\brief Structure type containing statistic counter data.\n\nThis structure type contains \"logic analyzer\"-like trace data (8 channels)."] # [repr (C)] # [derive (Debug , Default , Copy , Clone)] pub struct mcd_trace_data_stat_st { # [doc = "< Timestamp of this cycle (either picoseconds or clock cycles)."] pub timestamp : u64 , # [doc = "< Markers for this cycle."] pub marker : mcd_trace_marker_et , # [doc = "< Array of 8 statistic counters ('-1' represents an invalid value)."] pub count : [u64 ; 8usize] , } # [test] fn bindgen_test_layout_mcd_trace_data_stat_st () { const UNINIT : :: std :: mem :: MaybeUninit < mcd_trace_data_stat_st > = :: std :: mem :: MaybeUninit :: uninit () ; let ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: < mcd_trace_data_stat_st > () , 80usize , concat ! ("Size of: " , stringify ! (mcd_trace_data_stat_st))) ; assert_eq ! (:: std :: mem :: align_of :: < mcd_trace_data_stat_st > () , 8usize , concat ! ("Alignment of " , stringify ! (mcd_trace_data_stat_st))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . timestamp) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (mcd_trace_data_stat_st) , "::" , stringify ! (timestamp))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . marker) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (mcd_trace_data_stat_st) , "::" , stringify ! (marker))) ; assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . count) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (mcd_trace_data_stat_st) , "::" , stringify ! (count))) ; } # [repr (C)] # [derive (Debug , Default , Copy , Clone)] pub struct __crt_locale_data { pub _address : u8 , } # [repr (C)] # [derive (Debug , Default , Copy , Clone)] pub struct __crt_multibyte_data { pub _address : u8 , } extern crate libloading ; pub struct DynamicMCDxDAS { __library : :: libloading :: Library , pub __va_start : Result < unsafe extern "C" fn (arg1 : * mut * mut :: std :: os :: raw :: c_char , ...) , :: libloading :: Error > , pub __security_init_cookie : Result < unsafe extern "C" fn () , :: libloading :: Error > , pub __security_check_cookie : Result < unsafe extern "C" fn (_StackCookie : usize) , :: libloading :: Error > , pub __report_gsfailure : Result < unsafe extern "C" fn (_StackCookie : usize) -> ! , :: libloading :: Error > , pub _invalid_parameter_noinfo : Result < unsafe extern "C" fn () , :: libloading :: Error > , pub _invalid_parameter_noinfo_noreturn : Result < unsafe extern "C" fn () -> ! , :: libloading :: Error > , pub _invoke_watson : Result < unsafe extern "C" fn (arg1 : * const wchar_t , arg2 : * const wchar_t , arg3 : * const wchar_t , arg4 : :: std :: os :: raw :: c_uint , arg5 : usize) -> ! , :: libloading :: Error > , pub _calloc_base : Result < unsafe extern "C" fn (_Count : usize , _Size : usize) -> * mut :: std :: os :: raw :: c_void , :: libloading :: Error > , pub calloc : Result < unsafe extern "C" fn (_Count : :: std :: os :: raw :: c_ulonglong , _Size : :: std :: os :: raw :: c_ulonglong) -> * mut :: std :: os :: raw :: c_void , :: libloading :: Error > , pub _callnewh : Result < unsafe extern "C" fn (_Size : usize) -> :: std :: os :: raw :: c_int , :: libloading :: Error > , pub _expand : Result < unsafe extern "C" fn (_Block : * mut :: std :: os :: raw :: c_void , _Size : usize) -> * mut :: std :: os :: raw :: c_void , :: libloading :: Error > , pub _free_base : Result < unsafe extern "C" fn (_Block : * mut :: std :: os :: raw :: c_void) , :: libloading :: Error > , pub free : Result < unsafe extern "C" fn (_Block : * mut :: std :: os :: raw :: c_void) , :: libloading :: Error > , pub _malloc_base : Result < unsafe extern "C" fn (_Size : usize) -> * mut :: std :: os :: raw :: c_void , :: libloading :: Error > , pub malloc : Result < unsafe extern "C" fn (_Size : :: std :: os :: raw :: c_ulonglong) -> * mut :: std :: os :: raw :: c_void , :: libloading :: Error > , pub _msize : Result < unsafe extern "C" fn (_Block : * mut :: std :: os :: raw :: c_void) -> usize , :: libloading :: Error > , pub _realloc_base : Result < unsafe extern "C" fn (_Block : * mut :: std :: os :: raw :: c_void , _Size : usize) -> * mut :: std :: os :: raw :: c_void , :: libloading :: Error > , pub realloc : Result < unsafe extern "C" fn (_Block : * mut :: std :: os :: raw :: c_void , _Size : :: std :: os :: raw :: c_ulonglong) -> * mut :: std :: os :: raw :: c_void , :: libloading :: Error > , pub _recalloc : Result < unsafe extern "C" fn (_Block : * mut :: std :: os :: raw :: c_void , _Count : usize , _Size : usize) -> * mut :: std :: os :: raw :: c_void , :: libloading :: Error > , pub _aligned_free : Result < unsafe extern "C" fn (_Block : * mut :: std :: os :: raw :: c_void) , :: libloading :: Error > , pub _aligned_malloc : Result < unsafe extern "C" fn (_Size : usize , _Alignment : usize) -> * mut :: std :: os :: raw :: c_void , :: libloading :: Error > , pub _aligned_offset_malloc : Result < unsafe extern "C" fn (_Size : usize , _Alignment : usize , _Offset : usize) -> * mut :: std :: os :: raw :: c_void , :: libloading :: Error > , pub _aligned_msize : Result < unsafe extern "C" fn (_Block : * mut :: std :: os :: raw :: c_void , _Alignment : usize , _Offset : usize) -> usize , :: libloading :: Error > , pub _aligned_offset_realloc : Result < unsafe extern "C" fn (_Block : * mut :: std :: os :: raw :: c_void , _Size : usize , _Alignment : usize , _Offset : usize) -> * mut :: std :: os :: raw :: c_void , :: libloading :: Error > , pub _aligned_offset_recalloc : Result < unsafe extern "C" fn (_Block : * mut :: std :: os :: raw :: c_void , _Count : usize , _Size : usize , _Alignment : usize , _Offset : usize) -> * mut :: std :: os :: raw :: c_void , :: libloading :: Error > , pub _aligned_realloc : Result < unsafe extern "C" fn (_Block : * mut :: std :: os :: raw :: c_void , _Size : usize , _Alignment : usize) -> * mut :: std :: os :: raw :: c_void , :: libloading :: Error > , pub _aligned_recalloc : Result < unsafe extern "C" fn (_Block : * mut :: std :: os :: raw :: c_void , _Count : usize , _Size : usize , _Alignment : usize) -> * mut :: std :: os :: raw :: c_void , :: libloading :: Error > , pub _errno : Result < unsafe extern "C" fn () -> * mut :: std :: os :: raw :: c_int , :: libloading :: Error > , pub _set_errno : Result < unsafe extern "C" fn (_Value : :: std :: os :: raw :: c_int) -> errno_t , :: libloading :: Error > , pub _get_errno : Result < unsafe extern "C" fn (_Value : * mut :: std :: os :: raw :: c_int) -> errno_t , :: libloading :: Error > , pub __threadid : Result < unsafe extern "C" fn () -> :: std :: os :: raw :: c_ulong , :: libloading :: Error > , pub __threadhandle : Result < unsafe extern "C" fn () -> usize , :: libloading :: Error > , pub bsearch_s : Result < unsafe extern "C" fn (_Key : * const :: std :: os :: raw :: c_void , _Base : * const :: std :: os :: raw :: c_void , _NumOfElements : rsize_t , _SizeOfElements : rsize_t , _PtFuncCompare : :: std :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: std :: os :: raw :: c_void , arg2 : * const :: std :: os :: raw :: c_void , arg3 : * const :: std :: os :: raw :: c_void) -> :: std :: os :: raw :: c_int > , _Context : * mut :: std :: os :: raw :: c_void) -> * mut :: std :: os :: raw :: c_void , :: libloading :: Error > , pub qsort_s : Result < unsafe extern "C" fn (_Base : * mut :: std :: os :: raw :: c_void , _NumOfElements : rsize_t , _SizeOfElements : rsize_t , _PtFuncCompare : :: std :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: std :: os :: raw :: c_void , arg2 : * const :: std :: os :: raw :: c_void , arg3 : * const :: std :: os :: raw :: c_void) -> :: std :: os :: raw :: c_int > , _Context : * mut :: std :: os :: raw :: c_void) , :: libloading :: Error > , pub bsearch : Result < unsafe extern "C" fn (_Key : * const :: std :: os :: raw :: c_void , _Base : * const :: std :: os :: raw :: c_void , _NumOfElements : usize , _SizeOfElements : usize , _PtFuncCompare : :: std :: option :: Option < unsafe extern "C" fn (arg1 : * const :: std :: os :: raw :: c_void , arg2 : * const :: std :: os :: raw :: c_void) -> :: std :: os :: raw :: c_int >) -> * mut :: std :: os :: raw :: c_void , :: libloading :: Error > , pub qsort : Result < unsafe extern "C" fn (_Base : * mut :: std :: os :: raw :: c_void , _NumOfElements : usize , _SizeOfElements : usize , _PtFuncCompare : :: std :: option :: Option < unsafe extern "C" fn (arg1 : * const :: std :: os :: raw :: c_void , arg2 : * const :: std :: os :: raw :: c_void) -> :: std :: os :: raw :: c_int >) , :: libloading :: Error > , pub _lfind_s : Result < unsafe extern "C" fn (_Key : * const :: std :: os :: raw :: c_void , _Base : * const :: std :: os :: raw :: c_void , _NumOfElements : * mut :: std :: os :: raw :: c_uint , _SizeOfElements : usize , _PtFuncCompare : :: std :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: std :: os :: raw :: c_void , arg2 : * const :: std :: os :: raw :: c_void , arg3 : * const :: std :: os :: raw :: c_void) -> :: std :: os :: raw :: c_int > , _Context : * mut :: std :: os :: raw :: c_void) -> * mut :: std :: os :: raw :: c_void , :: libloading :: Error > , pub _lfind : Result < unsafe extern "C" fn (_Key : * const :: std :: os :: raw :: c_void , _Base : * const :: std :: os :: raw :: c_void , _NumOfElements : * mut :: std :: os :: raw :: c_uint , _SizeOfElements : :: std :: os :: raw :: c_uint , _PtFuncCompare : :: std :: option :: Option < unsafe extern "C" fn (arg1 : * const :: std :: os :: raw :: c_void , arg2 : * const :: std :: os :: raw :: c_void) -> :: std :: os :: raw :: c_int >) -> * mut :: std :: os :: raw :: c_void , :: libloading :: Error > , pub _lsearch_s : Result < unsafe extern "C" fn (_Key : * const :: std :: os :: raw :: c_void , _Base : * mut :: std :: os :: raw :: c_void , _NumOfElements : * mut :: std :: os :: raw :: c_uint , _SizeOfElements : usize , _PtFuncCompare : :: std :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: std :: os :: raw :: c_void , arg2 : * const :: std :: os :: raw :: c_void , arg3 : * const :: std :: os :: raw :: c_void) -> :: std :: os :: raw :: c_int > , _Context : * mut :: std :: os :: raw :: c_void) -> * mut :: std :: os :: raw :: c_void , :: libloading :: Error > , pub _lsearch : Result < unsafe extern "C" fn (_Key : * const :: std :: os :: raw :: c_void , _Base : * mut :: std :: os :: raw :: c_void , _NumOfElements : * mut :: std :: os :: raw :: c_uint , _SizeOfElements : :: std :: os :: raw :: c_uint , _PtFuncCompare : :: std :: option :: Option < unsafe extern "C" fn (arg1 : * const :: std :: os :: raw :: c_void , arg2 : * const :: std :: os :: raw :: c_void) -> :: std :: os :: raw :: c_int >) -> * mut :: std :: os :: raw :: c_void , :: libloading :: Error > , pub lfind : Result < unsafe extern "C" fn (_Key : * const :: std :: os :: raw :: c_void , _Base : * const :: std :: os :: raw :: c_void , _NumOfElements : * mut :: std :: os :: raw :: c_uint , _SizeOfElements : :: std :: os :: raw :: c_uint , _PtFuncCompare : :: std :: option :: Option < unsafe extern "C" fn (arg1 : * const :: std :: os :: raw :: c_void , arg2 : * const :: std :: os :: raw :: c_void) -> :: std :: os :: raw :: c_int >) -> * mut :: std :: os :: raw :: c_void , :: libloading :: Error > , pub lsearch : Result < unsafe extern "C" fn (_Key : * const :: std :: os :: raw :: c_void , _Base : * mut :: std :: os :: raw :: c_void , _NumOfElements : * mut :: std :: os :: raw :: c_uint , _SizeOfElements : :: std :: os :: raw :: c_uint , _PtFuncCompare : :: std :: option :: Option < unsafe extern "C" fn (arg1 : * const :: std :: os :: raw :: c_void , arg2 : * const :: std :: os :: raw :: c_void) -> :: std :: os :: raw :: c_int >) -> * mut :: std :: os :: raw :: c_void , :: libloading :: Error > , pub _itow_s : Result < unsafe extern "C" fn (_Value : :: std :: os :: raw :: c_int , _Buffer : * mut wchar_t , _BufferCount : usize , _Radix : :: std :: os :: raw :: c_int) -> errno_t , :: libloading :: Error > , pub _itow : Result < unsafe extern "C" fn (_Value : :: std :: os :: raw :: c_int , _Buffer : * mut wchar_t , _Radix : :: std :: os :: raw :: c_int) -> * mut wchar_t , :: libloading :: Error > , pub _ltow_s : Result < unsafe extern "C" fn (_Value : :: std :: os :: raw :: c_long , _Buffer : * mut wchar_t , _BufferCount : usize , _Radix : :: std :: os :: raw :: c_int) -> errno_t , :: libloading :: Error > , pub _ltow : Result < unsafe extern "C" fn (_Value : :: std :: os :: raw :: c_long , _Buffer : * mut wchar_t , _Radix : :: std :: os :: raw :: c_int) -> * mut wchar_t , :: libloading :: Error > , pub _ultow_s : Result < unsafe extern "C" fn (_Value : :: std :: os :: raw :: c_ulong , _Buffer : * mut wchar_t , _BufferCount : usize , _Radix : :: std :: os :: raw :: c_int) -> errno_t , :: libloading :: Error > , pub _ultow : Result < unsafe extern "C" fn (_Value : :: std :: os :: raw :: c_ulong , _Buffer : * mut wchar_t , _Radix : :: std :: os :: raw :: c_int) -> * mut wchar_t , :: libloading :: Error > , pub wcstod : Result < unsafe extern "C" fn (_String : * const wchar_t , _EndPtr : * mut * mut wchar_t) -> f64 , :: libloading :: Error > , pub _wcstod_l : Result < unsafe extern "C" fn (_String : * const wchar_t , _EndPtr : * mut * mut wchar_t , _Locale : _locale_t) -> f64 , :: libloading :: Error > , pub wcstol : Result < unsafe extern "C" fn (_String : * const wchar_t , _EndPtr : * mut * mut wchar_t , _Radix : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_long , :: libloading :: Error > , pub _wcstol_l : Result < unsafe extern "C" fn (_String : * const wchar_t , _EndPtr : * mut * mut wchar_t , _Radix : :: std :: os :: raw :: c_int , _Locale : _locale_t) -> :: std :: os :: raw :: c_long , :: libloading :: Error > , pub wcstoll : Result < unsafe extern "C" fn (_String : * const wchar_t , _EndPtr : * mut * mut wchar_t , _Radix : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_longlong , :: libloading :: Error > , pub _wcstoll_l : Result < unsafe extern "C" fn (_String : * const wchar_t , _EndPtr : * mut * mut wchar_t , _Radix : :: std :: os :: raw :: c_int , _Locale : _locale_t) -> :: std :: os :: raw :: c_longlong , :: libloading :: Error > , pub wcstoul : Result < unsafe extern "C" fn (_String : * const wchar_t , _EndPtr : * mut * mut wchar_t , _Radix : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_ulong , :: libloading :: Error > , pub _wcstoul_l : Result < unsafe extern "C" fn (_String : * const wchar_t , _EndPtr : * mut * mut wchar_t , _Radix : :: std :: os :: raw :: c_int , _Locale : _locale_t) -> :: std :: os :: raw :: c_ulong , :: libloading :: Error > , pub wcstoull : Result < unsafe extern "C" fn (_String : * const wchar_t , _EndPtr : * mut * mut wchar_t , _Radix : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_ulonglong , :: libloading :: Error > , pub _wcstoull_l : Result < unsafe extern "C" fn (_String : * const wchar_t , _EndPtr : * mut * mut wchar_t , _Radix : :: std :: os :: raw :: c_int , _Locale : _locale_t) -> :: std :: os :: raw :: c_ulonglong , :: libloading :: Error > , pub wcstold : Result < unsafe extern "C" fn (_String : * const wchar_t , _EndPtr : * mut * mut wchar_t) -> f64 , :: libloading :: Error > , pub _wcstold_l : Result < unsafe extern "C" fn (_String : * const wchar_t , _EndPtr : * mut * mut wchar_t , _Locale : _locale_t) -> f64 , :: libloading :: Error > , pub wcstof : Result < unsafe extern "C" fn (_String : * const wchar_t , _EndPtr : * mut * mut wchar_t) -> f32 , :: libloading :: Error > , pub _wcstof_l : Result < unsafe extern "C" fn (_String : * const wchar_t , _EndPtr : * mut * mut wchar_t , _Locale : _locale_t) -> f32 , :: libloading :: Error > , pub _wtof : Result < unsafe extern "C" fn (_String : * const wchar_t) -> f64 , :: libloading :: Error > , pub _wtof_l : Result < unsafe extern "C" fn (_String : * const wchar_t , _Locale : _locale_t) -> f64 , :: libloading :: Error > , pub _wtoi : Result < unsafe extern "C" fn (_String : * const wchar_t) -> :: std :: os :: raw :: c_int , :: libloading :: Error > , pub _wtoi_l : Result < unsafe extern "C" fn (_String : * const wchar_t , _Locale : _locale_t) -> :: std :: os :: raw :: c_int , :: libloading :: Error > , pub _wtol : Result < unsafe extern "C" fn (_String : * const wchar_t) -> :: std :: os :: raw :: c_long , :: libloading :: Error > , pub _wtol_l : Result < unsafe extern "C" fn (_String : * const wchar_t , _Locale : _locale_t) -> :: std :: os :: raw :: c_long , :: libloading :: Error > , pub _wtoll : Result < unsafe extern "C" fn (_String : * const wchar_t) -> :: std :: os :: raw :: c_longlong , :: libloading :: Error > , pub _wtoll_l : Result < unsafe extern "C" fn (_String : * const wchar_t , _Locale : _locale_t) -> :: std :: os :: raw :: c_longlong , :: libloading :: Error > , pub _i64tow_s : Result < unsafe extern "C" fn (_Value : :: std :: os :: raw :: c_longlong , _Buffer : * mut wchar_t , _BufferCount : usize , _Radix : :: std :: os :: raw :: c_int) -> errno_t , :: libloading :: Error > , pub _i64tow : Result < unsafe extern "C" fn (_Value : :: std :: os :: raw :: c_longlong , _Buffer : * mut wchar_t , _Radix : :: std :: os :: raw :: c_int) -> * mut wchar_t , :: libloading :: Error > , pub _ui64tow_s : Result < unsafe extern "C" fn (_Value : :: std :: os :: raw :: c_ulonglong , _Buffer : * mut wchar_t , _BufferCount : usize , _Radix : :: std :: os :: raw :: c_int) -> errno_t , :: libloading :: Error > , pub _ui64tow : Result < unsafe extern "C" fn (_Value : :: std :: os :: raw :: c_ulonglong , _Buffer : * mut wchar_t , _Radix : :: std :: os :: raw :: c_int) -> * mut wchar_t , :: libloading :: Error > , pub _wtoi64 : Result < unsafe extern "C" fn (_String : * const wchar_t) -> :: std :: os :: raw :: c_longlong , :: libloading :: Error > , pub _wtoi64_l : Result < unsafe extern "C" fn (_String : * const wchar_t , _Locale : _locale_t) -> :: std :: os :: raw :: c_longlong , :: libloading :: Error > , pub _wcstoi64 : Result < unsafe extern "C" fn (_String : * const wchar_t , _EndPtr : * mut * mut wchar_t , _Radix : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_longlong , :: libloading :: Error > , pub _wcstoi64_l : Result < unsafe extern "C" fn (_String : * const wchar_t , _EndPtr : * mut * mut wchar_t , _Radix : :: std :: os :: raw :: c_int , _Locale : _locale_t) -> :: std :: os :: raw :: c_longlong , :: libloading :: Error > , pub _wcstoui64 : Result < unsafe extern "C" fn (_String : * const wchar_t , _EndPtr : * mut * mut wchar_t , _Radix : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_ulonglong , :: libloading :: Error > , pub _wcstoui64_l : Result < unsafe extern "C" fn (_String : * const wchar_t , _EndPtr : * mut * mut wchar_t , _Radix : :: std :: os :: raw :: c_int , _Locale : _locale_t) -> :: std :: os :: raw :: c_ulonglong , :: libloading :: Error > , pub _wfullpath : Result < unsafe extern "C" fn (_Buffer : * mut wchar_t , _Path : * const wchar_t , _BufferCount : usize) -> * mut wchar_t , :: libloading :: Error > , pub _wmakepath_s : Result < unsafe extern "C" fn (_Buffer : * mut wchar_t , _BufferCount : usize , _Drive : * const wchar_t , _Dir : * const wchar_t , _Filename : * const wchar_t , _Ext : * const wchar_t) -> errno_t , :: libloading :: Error > , pub _wmakepath : Result < unsafe extern "C" fn (_Buffer : * mut wchar_t , _Drive : * const wchar_t , _Dir : * const wchar_t , _Filename : * const wchar_t , _Ext : * const wchar_t) , :: libloading :: Error > , pub _wperror : Result < unsafe extern "C" fn (_ErrMsg : * const wchar_t) , :: libloading :: Error > , pub _wsplitpath : Result < unsafe extern "C" fn (_FullPath : * const wchar_t , _Drive : * mut wchar_t , _Dir : * mut wchar_t , _Filename : * mut wchar_t , _Ext : * mut wchar_t) , :: libloading :: Error > , pub _wsplitpath_s : Result < unsafe extern "C" fn (_FullPath : * const wchar_t , _Drive : * mut wchar_t , _DriveCount : usize , _Dir : * mut wchar_t , _DirCount : usize , _Filename : * mut wchar_t , _FilenameCount : usize , _Ext : * mut wchar_t , _ExtCount : usize) -> errno_t , :: libloading :: Error > , pub _wdupenv_s : Result < unsafe extern "C" fn (_Buffer : * mut * mut wchar_t , _BufferCount : * mut usize , _VarName : * const wchar_t) -> errno_t , :: libloading :: Error > , pub _wgetenv : Result < unsafe extern "C" fn (_VarName : * const wchar_t) -> * mut wchar_t , :: libloading :: Error > , pub _wgetenv_s : Result < unsafe extern "C" fn (_RequiredCount : * mut usize , _Buffer : * mut wchar_t , _BufferCount : usize , _VarName : * const wchar_t) -> errno_t , :: libloading :: Error > , pub _wputenv : Result < unsafe extern "C" fn (_EnvString : * const wchar_t) -> :: std :: os :: raw :: c_int , :: libloading :: Error > , pub _wputenv_s : Result < unsafe extern "C" fn (_Name : * const wchar_t , _Value : * const wchar_t) -> errno_t , :: libloading :: Error > , pub _wsearchenv_s : Result < unsafe extern "C" fn (_Filename : * const wchar_t , _VarName : * const wchar_t , _Buffer : * mut wchar_t , _BufferCount : usize) -> errno_t , :: libloading :: Error > , pub _wsearchenv : Result < unsafe extern "C" fn (_Filename : * const wchar_t , _VarName : * const wchar_t , _ResultPath : * mut wchar_t) , :: libloading :: Error > , pub _wsystem : Result < unsafe extern "C" fn (_Command : * const wchar_t) -> :: std :: os :: raw :: c_int , :: libloading :: Error > , pub _swab : Result < unsafe extern "C" fn (_Buf1 : * mut :: std :: os :: raw :: c_char , _Buf2 : * mut :: std :: os :: raw :: c_char , _SizeInBytes : :: std :: os :: raw :: c_int) , :: libloading :: Error > , pub exit : Result < unsafe extern "C" fn (_Code : :: std :: os :: raw :: c_int) -> ! , :: libloading :: Error > , pub _exit : Result < unsafe extern "C" fn (_Code : :: std :: os :: raw :: c_int) -> ! , :: libloading :: Error > , pub _Exit : Result < unsafe extern "C" fn (_Code : :: std :: os :: raw :: c_int) -> ! , :: libloading :: Error > , pub quick_exit : Result < unsafe extern "C" fn (_Code : :: std :: os :: raw :: c_int) -> ! , :: libloading :: Error > , pub abort : Result < unsafe extern "C" fn () -> ! , :: libloading :: Error > , pub _set_abort_behavior : Result < unsafe extern "C" fn (_Flags : :: std :: os :: raw :: c_uint , _Mask : :: std :: os :: raw :: c_uint) -> :: std :: os :: raw :: c_uint , :: libloading :: Error > , pub atexit : Result < unsafe extern "C" fn (arg1 : :: std :: option :: Option < unsafe extern "C" fn () >) -> :: std :: os :: raw :: c_int , :: libloading :: Error > , pub _onexit : Result < unsafe extern "C" fn (_Func : _onexit_t) -> _onexit_t , :: libloading :: Error > , pub at_quick_exit : Result < unsafe extern "C" fn (arg1 : :: std :: option :: Option < unsafe extern "C" fn () >) -> :: std :: os :: raw :: c_int , :: libloading :: Error > , pub _set_purecall_handler : Result < unsafe extern "C" fn (_Handler : _purecall_handler) -> _purecall_handler , :: libloading :: Error > , pub _get_purecall_handler : Result < unsafe extern "C" fn () -> _purecall_handler , :: libloading :: Error > , pub _set_invalid_parameter_handler : Result < unsafe extern "C" fn (_Handler : _invalid_parameter_handler) -> _invalid_parameter_handler , :: libloading :: Error > , pub _get_invalid_parameter_handler : Result < unsafe extern "C" fn () -> _invalid_parameter_handler , :: libloading :: Error > , pub _set_thread_local_invalid_parameter_handler : Result < unsafe extern "C" fn (_Handler : _invalid_parameter_handler) -> _invalid_parameter_handler , :: libloading :: Error > , pub _get_thread_local_invalid_parameter_handler : Result < unsafe extern "C" fn () -> _invalid_parameter_handler , :: libloading :: Error > , pub _set_error_mode : Result < unsafe extern "C" fn (_Mode : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int , :: libloading :: Error > , pub __doserrno : Result < unsafe extern "C" fn () -> * mut :: std :: os :: raw :: c_ulong , :: libloading :: Error > , pub _set_doserrno : Result < unsafe extern "C" fn (_Value : :: std :: os :: raw :: c_ulong) -> errno_t , :: libloading :: Error > , pub _get_doserrno : Result < unsafe extern "C" fn (_Value : * mut :: std :: os :: raw :: c_ulong) -> errno_t , :: libloading :: Error > , pub __sys_errlist : Result < unsafe extern "C" fn () -> * mut * mut :: std :: os :: raw :: c_char , :: libloading :: Error > , pub __sys_nerr : Result < unsafe extern "C" fn () -> * mut :: std :: os :: raw :: c_int , :: libloading :: Error > , pub perror : Result < unsafe extern "C" fn (_ErrMsg : * const :: std :: os :: raw :: c_char) , :: libloading :: Error > , pub __p__pgmptr : Result < unsafe extern "C" fn () -> * mut * mut :: std :: os :: raw :: c_char , :: libloading :: Error > , pub __p__wpgmptr : Result < unsafe extern "C" fn () -> * mut * mut wchar_t , :: libloading :: Error > , pub __p__fmode : Result < unsafe extern "C" fn () -> * mut :: std :: os :: raw :: c_int , :: libloading :: Error > , pub _get_pgmptr : Result < unsafe extern "C" fn (_Value : * mut * mut :: std :: os :: raw :: c_char) -> errno_t , :: libloading :: Error > , pub _get_wpgmptr : Result < unsafe extern "C" fn (_Value : * mut * mut wchar_t) -> errno_t , :: libloading :: Error > , pub _set_fmode : Result < unsafe extern "C" fn (_Mode : :: std :: os :: raw :: c_int) -> errno_t , :: libloading :: Error > , pub _get_fmode : Result < unsafe extern "C" fn (_PMode : * mut :: std :: os :: raw :: c_int) -> errno_t , :: libloading :: Error > , pub abs : Result < unsafe extern "C" fn (_Number : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int , :: libloading :: Error > , pub labs : Result < unsafe extern "C" fn (_Number : :: std :: os :: raw :: c_long) -> :: std :: os :: raw :: c_long , :: libloading :: Error > , pub llabs : Result < unsafe extern "C" fn (_Number : :: std :: os :: raw :: c_longlong) -> :: std :: os :: raw :: c_longlong , :: libloading :: Error > , pub _abs64 : Result < unsafe extern "C" fn (_Number : :: std :: os :: raw :: c_longlong) -> :: std :: os :: raw :: c_longlong , :: libloading :: Error > , pub _byteswap_ushort : Result < unsafe extern "C" fn (_Number : :: std :: os :: raw :: c_ushort) -> :: std :: os :: raw :: c_ushort , :: libloading :: Error > , pub _byteswap_ulong : Result < unsafe extern "C" fn (_Number : :: std :: os :: raw :: c_ulong) -> :: std :: os :: raw :: c_ulong , :: libloading :: Error > , pub _byteswap_uint64 : Result < unsafe extern "C" fn (_Number : :: std :: os :: raw :: c_ulonglong) -> :: std :: os :: raw :: c_ulonglong , :: libloading :: Error > , pub div : Result < unsafe extern "C" fn (_Numerator : :: std :: os :: raw :: c_int , _Denominator : :: std :: os :: raw :: c_int) -> div_t , :: libloading :: Error > , pub ldiv : Result < unsafe extern "C" fn (_Numerator : :: std :: os :: raw :: c_long , _Denominator : :: std :: os :: raw :: c_long) -> ldiv_t , :: libloading :: Error > , pub lldiv : Result < unsafe extern "C" fn (_Numerator : :: std :: os :: raw :: c_longlong , _Denominator : :: std :: os :: raw :: c_longlong) -> lldiv_t , :: libloading :: Error > , pub _rotl : Result < unsafe extern "C" fn (_Value : :: std :: os :: raw :: c_uint , _Shift : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_uint , :: libloading :: Error > , pub _lrotl : Result < unsafe extern "C" fn (_Value : :: std :: os :: raw :: c_ulong , _Shift : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_ulong , :: libloading :: Error > , pub _rotl64 : Result < unsafe extern "C" fn (_Value : :: std :: os :: raw :: c_ulonglong , _Shift : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_ulonglong , :: libloading :: Error > , pub _rotr : Result < unsafe extern "C" fn (_Value : :: std :: os :: raw :: c_uint , _Shift : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_uint , :: libloading :: Error > , pub _lrotr : Result < unsafe extern "C" fn (_Value : :: std :: os :: raw :: c_ulong , _Shift : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_ulong , :: libloading :: Error > , pub _rotr64 : Result < unsafe extern "C" fn (_Value : :: std :: os :: raw :: c_ulonglong , _Shift : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_ulonglong , :: libloading :: Error > , pub srand : Result < unsafe extern "C" fn (_Seed : :: std :: os :: raw :: c_uint) , :: libloading :: Error > , pub rand : Result < unsafe extern "C" fn () -> :: std :: os :: raw :: c_int , :: libloading :: Error > , pub atof : Result < unsafe extern "C" fn (_String : * const :: std :: os :: raw :: c_char) -> f64 , :: libloading :: Error > , pub atoi : Result < unsafe extern "C" fn (_String : * const :: std :: os :: raw :: c_char) -> :: std :: os :: raw :: c_int , :: libloading :: Error > , pub atol : Result < unsafe extern "C" fn (_String : * const :: std :: os :: raw :: c_char) -> :: std :: os :: raw :: c_long , :: libloading :: Error > , pub atoll : Result < unsafe extern "C" fn (_String : * const :: std :: os :: raw :: c_char) -> :: std :: os :: raw :: c_longlong , :: libloading :: Error > , pub _atoi64 : Result < unsafe extern "C" fn (_String : * const :: std :: os :: raw :: c_char) -> :: std :: os :: raw :: c_longlong , :: libloading :: Error > , pub _atof_l : Result < unsafe extern "C" fn (_String : * const :: std :: os :: raw :: c_char , _Locale : _locale_t) -> f64 , :: libloading :: Error > , pub _atoi_l : Result < unsafe extern "C" fn (_String : * const :: std :: os :: raw :: c_char , _Locale : _locale_t) -> :: std :: os :: raw :: c_int , :: libloading :: Error > , pub _atol_l : Result < unsafe extern "C" fn (_String : * const :: std :: os :: raw :: c_char , _Locale : _locale_t) -> :: std :: os :: raw :: c_long , :: libloading :: Error > , pub _atoll_l : Result < unsafe extern "C" fn (_String : * const :: std :: os :: raw :: c_char , _Locale : _locale_t) -> :: std :: os :: raw :: c_longlong , :: libloading :: Error > , pub _atoi64_l : Result < unsafe extern "C" fn (_String : * const :: std :: os :: raw :: c_char , _Locale : _locale_t) -> :: std :: os :: raw :: c_longlong , :: libloading :: Error > , pub _atoflt : Result < unsafe extern "C" fn (_Result : * mut _CRT_FLOAT , _String : * const :: std :: os :: raw :: c_char) -> :: std :: os :: raw :: c_int , :: libloading :: Error > , pub _atodbl : Result < unsafe extern "C" fn (_Result : * mut _CRT_DOUBLE , _String : * mut :: std :: os :: raw :: c_char) -> :: std :: os :: raw :: c_int , :: libloading :: Error > , pub _atoldbl : Result < unsafe extern "C" fn (_Result : * mut _LDOUBLE , _String : * mut :: std :: os :: raw :: c_char) -> :: std :: os :: raw :: c_int , :: libloading :: Error > , pub _atoflt_l : Result < unsafe extern "C" fn (_Result : * mut _CRT_FLOAT , _String : * const :: std :: os :: raw :: c_char , _Locale : _locale_t) -> :: std :: os :: raw :: c_int , :: libloading :: Error > , pub _atodbl_l : Result < unsafe extern "C" fn (_Result : * mut _CRT_DOUBLE , _String : * mut :: std :: os :: raw :: c_char , _Locale : _locale_t) -> :: std :: os :: raw :: c_int , :: libloading :: Error > , pub _atoldbl_l : Result < unsafe extern "C" fn (_Result : * mut _LDOUBLE , _String : * mut :: std :: os :: raw :: c_char , _Locale : _locale_t) -> :: std :: os :: raw :: c_int , :: libloading :: Error > , pub strtof : Result < unsafe extern "C" fn (_String : * const :: std :: os :: raw :: c_char , _EndPtr : * mut * mut :: std :: os :: raw :: c_char) -> f32 , :: libloading :: Error > , pub _strtof_l : Result < unsafe extern "C" fn (_String : * const :: std :: os :: raw :: c_char , _EndPtr : * mut * mut :: std :: os :: raw :: c_char , _Locale : _locale_t) -> f32 , :: libloading :: Error > , pub strtod : Result < unsafe extern "C" fn (_String : * const :: std :: os :: raw :: c_char , _EndPtr : * mut * mut :: std :: os :: raw :: c_char) -> f64 , :: libloading :: Error > , pub _strtod_l : Result < unsafe extern "C" fn (_String : * const :: std :: os :: raw :: c_char , _EndPtr : * mut * mut :: std :: os :: raw :: c_char , _Locale : _locale_t) -> f64 , :: libloading :: Error > , pub strtold : Result < unsafe extern "C" fn (_String : * const :: std :: os :: raw :: c_char , _EndPtr : * mut * mut :: std :: os :: raw :: c_char) -> f64 , :: libloading :: Error > , pub _strtold_l : Result < unsafe extern "C" fn (_String : * const :: std :: os :: raw :: c_char , _EndPtr : * mut * mut :: std :: os :: raw :: c_char , _Locale : _locale_t) -> f64 , :: libloading :: Error > , pub strtol : Result < unsafe extern "C" fn (_String : * const :: std :: os :: raw :: c_char , _EndPtr : * mut * mut :: std :: os :: raw :: c_char , _Radix : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_long , :: libloading :: Error > , pub _strtol_l : Result < unsafe extern "C" fn (_String : * const :: std :: os :: raw :: c_char , _EndPtr : * mut * mut :: std :: os :: raw :: c_char , _Radix : :: std :: os :: raw :: c_int , _Locale : _locale_t) -> :: std :: os :: raw :: c_long , :: libloading :: Error > , pub strtoll : Result < unsafe extern "C" fn (_String : * const :: std :: os :: raw :: c_char , _EndPtr : * mut * mut :: std :: os :: raw :: c_char , _Radix : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_longlong , :: libloading :: Error > , pub _strtoll_l : Result < unsafe extern "C" fn (_String : * const :: std :: os :: raw :: c_char , _EndPtr : * mut * mut :: std :: os :: raw :: c_char , _Radix : :: std :: os :: raw :: c_int , _Locale : _locale_t) -> :: std :: os :: raw :: c_longlong , :: libloading :: Error > , pub strtoul : Result < unsafe extern "C" fn (_String : * const :: std :: os :: raw :: c_char , _EndPtr : * mut * mut :: std :: os :: raw :: c_char , _Radix : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_ulong , :: libloading :: Error > , pub _strtoul_l : Result < unsafe extern "C" fn (_String : * const :: std :: os :: raw :: c_char , _EndPtr : * mut * mut :: std :: os :: raw :: c_char , _Radix : :: std :: os :: raw :: c_int , _Locale : _locale_t) -> :: std :: os :: raw :: c_ulong , :: libloading :: Error > , pub strtoull : Result < unsafe extern "C" fn (_String : * const :: std :: os :: raw :: c_char , _EndPtr : * mut * mut :: std :: os :: raw :: c_char , _Radix : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_ulonglong , :: libloading :: Error > , pub _strtoull_l : Result < unsafe extern "C" fn (_String : * const :: std :: os :: raw :: c_char , _EndPtr : * mut * mut :: std :: os :: raw :: c_char , _Radix : :: std :: os :: raw :: c_int , _Locale : _locale_t) -> :: std :: os :: raw :: c_ulonglong , :: libloading :: Error > , pub _strtoi64 : Result < unsafe extern "C" fn (_String : * const :: std :: os :: raw :: c_char , _EndPtr : * mut * mut :: std :: os :: raw :: c_char , _Radix : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_longlong , :: libloading :: Error > , pub _strtoi64_l : Result < unsafe extern "C" fn (_String : * const :: std :: os :: raw :: c_char , _EndPtr : * mut * mut :: std :: os :: raw :: c_char , _Radix : :: std :: os :: raw :: c_int , _Locale : _locale_t) -> :: std :: os :: raw :: c_longlong , :: libloading :: Error > , pub _strtoui64 : Result < unsafe extern "C" fn (_String : * const :: std :: os :: raw :: c_char , _EndPtr : * mut * mut :: std :: os :: raw :: c_char , _Radix : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_ulonglong , :: libloading :: Error > , pub _strtoui64_l : Result < unsafe extern "C" fn (_String : * const :: std :: os :: raw :: c_char , _EndPtr : * mut * mut :: std :: os :: raw :: c_char , _Radix : :: std :: os :: raw :: c_int , _Locale : _locale_t) -> :: std :: os :: raw :: c_ulonglong , :: libloading :: Error > , pub _itoa_s : Result < unsafe extern "C" fn (_Value : :: std :: os :: raw :: c_int , _Buffer : * mut :: std :: os :: raw :: c_char , _BufferCount : usize , _Radix : :: std :: os :: raw :: c_int) -> errno_t , :: libloading :: Error > , pub _itoa : Result < unsafe extern "C" fn (_Value : :: std :: os :: raw :: c_int , _Buffer : * mut :: std :: os :: raw :: c_char , _Radix : :: std :: os :: raw :: c_int) -> * mut :: std :: os :: raw :: c_char , :: libloading :: Error > , pub _ltoa_s : Result < unsafe extern "C" fn (_Value : :: std :: os :: raw :: c_long , _Buffer : * mut :: std :: os :: raw :: c_char , _BufferCount : usize , _Radix : :: std :: os :: raw :: c_int) -> errno_t , :: libloading :: Error > , pub _ltoa : Result < unsafe extern "C" fn (_Value : :: std :: os :: raw :: c_long , _Buffer : * mut :: std :: os :: raw :: c_char , _Radix : :: std :: os :: raw :: c_int) -> * mut :: std :: os :: raw :: c_char , :: libloading :: Error > , pub _ultoa_s : Result < unsafe extern "C" fn (_Value : :: std :: os :: raw :: c_ulong , _Buffer : * mut :: std :: os :: raw :: c_char , _BufferCount : usize , _Radix : :: std :: os :: raw :: c_int) -> errno_t , :: libloading :: Error > , pub _ultoa : Result < unsafe extern "C" fn (_Value : :: std :: os :: raw :: c_ulong , _Buffer : * mut :: std :: os :: raw :: c_char , _Radix : :: std :: os :: raw :: c_int) -> * mut :: std :: os :: raw :: c_char , :: libloading :: Error > , pub _i64toa_s : Result < unsafe extern "C" fn (_Value : :: std :: os :: raw :: c_longlong , _Buffer : * mut :: std :: os :: raw :: c_char , _BufferCount : usize , _Radix : :: std :: os :: raw :: c_int) -> errno_t , :: libloading :: Error > , pub _i64toa : Result < unsafe extern "C" fn (_Value : :: std :: os :: raw :: c_longlong , _Buffer : * mut :: std :: os :: raw :: c_char , _Radix : :: std :: os :: raw :: c_int) -> * mut :: std :: os :: raw :: c_char , :: libloading :: Error > , pub _ui64toa_s : Result < unsafe extern "C" fn (_Value : :: std :: os :: raw :: c_ulonglong , _Buffer : * mut :: std :: os :: raw :: c_char , _BufferCount : usize , _Radix : :: std :: os :: raw :: c_int) -> errno_t , :: libloading :: Error > , pub _ui64toa : Result < unsafe extern "C" fn (_Value : :: std :: os :: raw :: c_ulonglong , _Buffer : * mut :: std :: os :: raw :: c_char , _Radix : :: std :: os :: raw :: c_int) -> * mut :: std :: os :: raw :: c_char , :: libloading :: Error > , pub _ecvt_s : Result < unsafe extern "C" fn (_Buffer : * mut :: std :: os :: raw :: c_char , _BufferCount : usize , _Value : f64 , _DigitCount : :: std :: os :: raw :: c_int , _PtDec : * mut :: std :: os :: raw :: c_int , _PtSign : * mut :: std :: os :: raw :: c_int) -> errno_t , :: libloading :: Error > , pub _ecvt : Result < unsafe extern "C" fn (_Value : f64 , _DigitCount : :: std :: os :: raw :: c_int , _PtDec : * mut :: std :: os :: raw :: c_int , _PtSign : * mut :: std :: os :: raw :: c_int) -> * mut :: std :: os :: raw :: c_char , :: libloading :: Error > , pub _fcvt_s : Result < unsafe extern "C" fn (_Buffer : * mut :: std :: os :: raw :: c_char , _BufferCount : usize , _Value : f64 , _FractionalDigitCount : :: std :: os :: raw :: c_int , _PtDec : * mut :: std :: os :: raw :: c_int , _PtSign : * mut :: std :: os :: raw :: c_int) -> errno_t , :: libloading :: Error > , pub _fcvt : Result < unsafe extern "C" fn (_Value : f64 , _FractionalDigitCount : :: std :: os :: raw :: c_int , _PtDec : * mut :: std :: os :: raw :: c_int , _PtSign : * mut :: std :: os :: raw :: c_int) -> * mut :: std :: os :: raw :: c_char , :: libloading :: Error > , pub _gcvt_s : Result < unsafe extern "C" fn (_Buffer : * mut :: std :: os :: raw :: c_char , _BufferCount : usize , _Value : f64 , _DigitCount : :: std :: os :: raw :: c_int) -> errno_t , :: libloading :: Error > , pub _gcvt : Result < unsafe extern "C" fn (_Value : f64 , _DigitCount : :: std :: os :: raw :: c_int , _Buffer : * mut :: std :: os :: raw :: c_char) -> * mut :: std :: os :: raw :: c_char , :: libloading :: Error > , pub ___mb_cur_max_func : Result < unsafe extern "C" fn () -> :: std :: os :: raw :: c_int , :: libloading :: Error > , pub ___mb_cur_max_l_func : Result < unsafe extern "C" fn (arg1 : _locale_t) -> :: std :: os :: raw :: c_int , :: libloading :: Error > , pub mblen : Result < unsafe extern "C" fn (_Ch : * const :: std :: os :: raw :: c_char , _MaxCount : usize) -> :: std :: os :: raw :: c_int , :: libloading :: Error > , pub _mblen_l : Result < unsafe extern "C" fn (_Ch : * const :: std :: os :: raw :: c_char , _MaxCount : usize , _Locale : _locale_t) -> :: std :: os :: raw :: c_int , :: libloading :: Error > , pub _mbstrlen : Result < unsafe extern "C" fn (_String : * const :: std :: os :: raw :: c_char) -> usize , :: libloading :: Error > , pub _mbstrlen_l : Result < unsafe extern "C" fn (_String : * const :: std :: os :: raw :: c_char , _Locale : _locale_t) -> usize , :: libloading :: Error > , pub _mbstrnlen : Result < unsafe extern "C" fn (_String : * const :: std :: os :: raw :: c_char , _MaxCount : usize) -> usize , :: libloading :: Error > , pub _mbstrnlen_l : Result < unsafe extern "C" fn (_String : * const :: std :: os :: raw :: c_char , _MaxCount : usize , _Locale : _locale_t) -> usize , :: libloading :: Error > , pub mbtowc : Result < unsafe extern "C" fn (_DstCh : * mut wchar_t , _SrcCh : * const :: std :: os :: raw :: c_char , _SrcSizeInBytes : usize) -> :: std :: os :: raw :: c_int , :: libloading :: Error > , pub _mbtowc_l : Result < unsafe extern "C" fn (_DstCh : * mut wchar_t , _SrcCh : * const :: std :: os :: raw :: c_char , _SrcSizeInBytes : usize , _Locale : _locale_t) -> :: std :: os :: raw :: c_int , :: libloading :: Error > , pub mbstowcs_s : Result < unsafe extern "C" fn (_PtNumOfCharConverted : * mut usize , _DstBuf : * mut wchar_t , _SizeInWords : usize , _SrcBuf : * const :: std :: os :: raw :: c_char , _MaxCount : usize) -> errno_t , :: libloading :: Error > , pub mbstowcs : Result < unsafe extern "C" fn (_Dest : * mut wchar_t , _Source : * const :: std :: os :: raw :: c_char , _MaxCount : usize) -> usize , :: libloading :: Error > , pub _mbstowcs_s_l : Result < unsafe extern "C" fn (_PtNumOfCharConverted : * mut usize , _DstBuf : * mut wchar_t , _SizeInWords : usize , _SrcBuf : * const :: std :: os :: raw :: c_char , _MaxCount : usize , _Locale : _locale_t) -> errno_t , :: libloading :: Error > , pub _mbstowcs_l : Result < unsafe extern "C" fn (_Dest : * mut wchar_t , _Source : * const :: std :: os :: raw :: c_char , _MaxCount : usize , _Locale : _locale_t) -> usize , :: libloading :: Error > , pub wctomb : Result < unsafe extern "C" fn (_MbCh : * mut :: std :: os :: raw :: c_char , _WCh : wchar_t) -> :: std :: os :: raw :: c_int , :: libloading :: Error > , pub _wctomb_l : Result < unsafe extern "C" fn (_MbCh : * mut :: std :: os :: raw :: c_char , _WCh : wchar_t , _Locale : _locale_t) -> :: std :: os :: raw :: c_int , :: libloading :: Error > , pub wctomb_s : Result < unsafe extern "C" fn (_SizeConverted : * mut :: std :: os :: raw :: c_int , _MbCh : * mut :: std :: os :: raw :: c_char , _SizeInBytes : rsize_t , _WCh : wchar_t) -> errno_t , :: libloading :: Error > , pub _wctomb_s_l : Result < unsafe extern "C" fn (_SizeConverted : * mut :: std :: os :: raw :: c_int , _MbCh : * mut :: std :: os :: raw :: c_char , _SizeInBytes : usize , _WCh : wchar_t , _Locale : _locale_t) -> errno_t , :: libloading :: Error > , pub wcstombs_s : Result < unsafe extern "C" fn (_PtNumOfCharConverted : * mut usize , _Dst : * mut :: std :: os :: raw :: c_char , _DstSizeInBytes : usize , _Src : * const wchar_t , _MaxCountInBytes : usize) -> errno_t , :: libloading :: Error > , pub wcstombs : Result < unsafe extern "C" fn (_Dest : * mut :: std :: os :: raw :: c_char , _Source : * const wchar_t , _MaxCount : usize) -> usize , :: libloading :: Error > , pub _wcstombs_s_l : Result < unsafe extern "C" fn (_PtNumOfCharConverted : * mut usize , _Dst : * mut :: std :: os :: raw :: c_char , _DstSizeInBytes : usize , _Src : * const wchar_t , _MaxCountInBytes : usize , _Locale : _locale_t) -> errno_t , :: libloading :: Error > , pub _wcstombs_l : Result < unsafe extern "C" fn (_Dest : * mut :: std :: os :: raw :: c_char , _Source : * const wchar_t , _MaxCount : usize , _Locale : _locale_t) -> usize , :: libloading :: Error > , pub _fullpath : Result < unsafe extern "C" fn (_Buffer : * mut :: std :: os :: raw :: c_char , _Path : * const :: std :: os :: raw :: c_char , _BufferCount : usize) -> * mut :: std :: os :: raw :: c_char , :: libloading :: Error > , pub _makepath_s : Result < unsafe extern "C" fn (_Buffer : * mut :: std :: os :: raw :: c_char , _BufferCount : usize , _Drive : * const :: std :: os :: raw :: c_char , _Dir : * const :: std :: os :: raw :: c_char , _Filename : * const :: std :: os :: raw :: c_char , _Ext : * const :: std :: os :: raw :: c_char) -> errno_t , :: libloading :: Error > , pub _makepath : Result < unsafe extern "C" fn (_Buffer : * mut :: std :: os :: raw :: c_char , _Drive : * const :: std :: os :: raw :: c_char , _Dir : * const :: std :: os :: raw :: c_char , _Filename : * const :: std :: os :: raw :: c_char , _Ext : * const :: std :: os :: raw :: c_char) , :: libloading :: Error > , pub _splitpath : Result < unsafe extern "C" fn (_FullPath : * const :: std :: os :: raw :: c_char , _Drive : * mut :: std :: os :: raw :: c_char , _Dir : * mut :: std :: os :: raw :: c_char , _Filename : * mut :: std :: os :: raw :: c_char , _Ext : * mut :: std :: os :: raw :: c_char) , :: libloading :: Error > , pub _splitpath_s : Result < unsafe extern "C" fn (_FullPath : * const :: std :: os :: raw :: c_char , _Drive : * mut :: std :: os :: raw :: c_char , _DriveCount : usize , _Dir : * mut :: std :: os :: raw :: c_char , _DirCount : usize , _Filename : * mut :: std :: os :: raw :: c_char , _FilenameCount : usize , _Ext : * mut :: std :: os :: raw :: c_char , _ExtCount : usize) -> errno_t , :: libloading :: Error > , pub getenv_s : Result < unsafe extern "C" fn (_RequiredCount : * mut usize , _Buffer : * mut :: std :: os :: raw :: c_char , _BufferCount : rsize_t , _VarName : * const :: std :: os :: raw :: c_char) -> errno_t , :: libloading :: Error > , pub __p___argc : Result < unsafe extern "C" fn () -> * mut :: std :: os :: raw :: c_int , :: libloading :: Error > , pub __p___argv : Result < unsafe extern "C" fn () -> * mut * mut * mut :: std :: os :: raw :: c_char , :: libloading :: Error > , pub __p___wargv : Result < unsafe extern "C" fn () -> * mut * mut * mut wchar_t , :: libloading :: Error > , pub __p__environ : Result < unsafe extern "C" fn () -> * mut * mut * mut :: std :: os :: raw :: c_char , :: libloading :: Error > , pub __p__wenviron : Result < unsafe extern "C" fn () -> * mut * mut * mut wchar_t , :: libloading :: Error > , pub getenv : Result < unsafe extern "C" fn (_VarName : * const :: std :: os :: raw :: c_char) -> * mut :: std :: os :: raw :: c_char , :: libloading :: Error > , pub _dupenv_s : Result < unsafe extern "C" fn (_Buffer : * mut * mut :: std :: os :: raw :: c_char , _BufferCount : * mut usize , _VarName : * const :: std :: os :: raw :: c_char) -> errno_t , :: libloading :: Error > , pub system : Result < unsafe extern "C" fn (_Command : * const :: std :: os :: raw :: c_char) -> :: std :: os :: raw :: c_int , :: libloading :: Error > , pub _putenv : Result < unsafe extern "C" fn (_EnvString : * const :: std :: os :: raw :: c_char) -> :: std :: os :: raw :: c_int , :: libloading :: Error > , pub _putenv_s : Result < unsafe extern "C" fn (_Name : * const :: std :: os :: raw :: c_char , _Value : * const :: std :: os :: raw :: c_char) -> errno_t , :: libloading :: Error > , pub _searchenv_s : Result < unsafe extern "C" fn (_Filename : * const :: std :: os :: raw :: c_char , _VarName : * const :: std :: os :: raw :: c_char , _Buffer : * mut :: std :: os :: raw :: c_char , _BufferCount : usize) -> errno_t , :: libloading :: Error > , pub _searchenv : Result < unsafe extern "C" fn (_Filename : * const :: std :: os :: raw :: c_char , _VarName : * const :: std :: os :: raw :: c_char , _Buffer : * mut :: std :: os :: raw :: c_char) , :: libloading :: Error > , pub _seterrormode : Result < unsafe extern "C" fn (_Mode : :: std :: os :: raw :: c_int) , :: libloading :: Error > , pub _beep : Result < unsafe extern "C" fn (_Frequency : :: std :: os :: raw :: c_uint , _Duration : :: std :: os :: raw :: c_uint) , :: libloading :: Error > , pub _sleep : Result < unsafe extern "C" fn (_Duration : :: std :: os :: raw :: c_ulong) , :: libloading :: Error > , pub ecvt : Result < unsafe extern "C" fn (_Value : f64 , _DigitCount : :: std :: os :: raw :: c_int , _PtDec : * mut :: std :: os :: raw :: c_int , _PtSign : * mut :: std :: os :: raw :: c_int) -> * mut :: std :: os :: raw :: c_char , :: libloading :: Error > , pub fcvt : Result < unsafe extern "C" fn (_Value : f64 , _FractionalDigitCount : :: std :: os :: raw :: c_int , _PtDec : * mut :: std :: os :: raw :: c_int , _PtSign : * mut :: std :: os :: raw :: c_int) -> * mut :: std :: os :: raw :: c_char , :: libloading :: Error > , pub gcvt : Result < unsafe extern "C" fn (_Value : f64 , _DigitCount : :: std :: os :: raw :: c_int , _DstBuf : * mut :: std :: os :: raw :: c_char) -> * mut :: std :: os :: raw :: c_char , :: libloading :: Error > , pub itoa : Result < unsafe extern "C" fn (_Value : :: std :: os :: raw :: c_int , _Buffer : * mut :: std :: os :: raw :: c_char , _Radix : :: std :: os :: raw :: c_int) -> * mut :: std :: os :: raw :: c_char , :: libloading :: Error > , pub ltoa : Result < unsafe extern "C" fn (_Value : :: std :: os :: raw :: c_long , _Buffer : * mut :: std :: os :: raw :: c_char , _Radix : :: std :: os :: raw :: c_int) -> * mut :: std :: os :: raw :: c_char , :: libloading :: Error > , pub swab : Result < unsafe extern "C" fn (_Buf1 : * mut :: std :: os :: raw :: c_char , _Buf2 : * mut :: std :: os :: raw :: c_char , _SizeInBytes : :: std :: os :: raw :: c_int) , :: libloading :: Error > , pub ultoa : Result < unsafe extern "C" fn (_Value : :: std :: os :: raw :: c_ulong , _Buffer : * mut :: std :: os :: raw :: c_char , _Radix : :: std :: os :: raw :: c_int) -> * mut :: std :: os :: raw :: c_char , :: libloading :: Error > , pub putenv : Result < unsafe extern "C" fn (_EnvString : * const :: std :: os :: raw :: c_char) -> :: std :: os :: raw :: c_int , :: libloading :: Error > , pub onexit : Result < unsafe extern "C" fn (_Func : _onexit_t) -> _onexit_t , :: libloading :: Error > , pub mcd_initialize_f : Result < unsafe extern "C" fn (version_req : * const mcd_api_version_st , impl_info : * mut mcd_impl_version_info_st) -> mcd_return_et , :: libloading :: Error > , pub mcd_exit_f : Result < unsafe extern "C" fn () , :: libloading :: Error > , pub mcd_qry_servers_f : Result < unsafe extern "C" fn (host : * const mcd_char_t , running : mcd_bool_t , start_index : u32 , num_servers : * mut u32 , server_info : * mut mcd_server_info_st) -> mcd_return_et , :: libloading :: Error > , pub mcd_open_server_f : Result < unsafe extern "C" fn (system_key : * const mcd_char_t , config_string : * const mcd_char_t , server : * mut * mut mcd_server_st) -> mcd_return_et , :: libloading :: Error > , pub mcd_close_server_f : Result < unsafe extern "C" fn (server : * const mcd_server_st) -> mcd_return_et , :: libloading :: Error > , pub mcd_set_server_config_f : Result < unsafe extern "C" fn (server : * const mcd_server_st , config_string : * const mcd_char_t) -> mcd_return_et , :: libloading :: Error > , pub mcd_qry_server_config_f : Result < unsafe extern "C" fn (server : * const mcd_server_st , max_len : * mut u32 , config_string : * mut mcd_char_t) -> mcd_return_et , :: libloading :: Error > , pub mcd_qry_systems_f : Result < unsafe extern "C" fn (start_index : u32 , num_systems : * mut u32 , system_con_info : * mut mcd_core_con_info_st) -> mcd_return_et , :: libloading :: Error > , pub mcd_qry_devices_f : Result < unsafe extern "C" fn (system_con_info : * const mcd_core_con_info_st , start_index : u32 , num_devices : * mut u32 , device_con_info : * mut mcd_core_con_info_st) -> mcd_return_et , :: libloading :: Error > , pub mcd_qry_cores_f : Result < unsafe extern "C" fn (connection_info : * const mcd_core_con_info_st , start_index : u32 , num_cores : * mut u32 , core_con_info : * mut mcd_core_con_info_st) -> mcd_return_et , :: libloading :: Error > , pub mcd_qry_core_modes_f : Result < unsafe extern "C" fn (core : * const mcd_core_st , start_index : u32 , num_modes : * mut u32 , core_mode_info : * mut mcd_core_mode_info_st) -> mcd_return_et , :: libloading :: Error > , pub mcd_open_core_f : Result < unsafe extern "C" fn (core_con_info : * const mcd_core_con_info_st , core : * mut * mut mcd_core_st) -> mcd_return_et , :: libloading :: Error > , pub mcd_close_core_f : Result < unsafe extern "C" fn (core : * const mcd_core_st) -> mcd_return_et , :: libloading :: Error > , pub mcd_qry_error_info_f : Result < unsafe extern "C" fn (core : * const mcd_core_st , error_info : * mut mcd_error_info_st) , :: libloading :: Error > , pub mcd_qry_device_description_f : Result < unsafe extern "C" fn (core : * const mcd_core_st , url : * mut mcd_char_t , url_length : * mut u32) -> mcd_return_et , :: libloading :: Error > , pub mcd_qry_max_payload_size_f : Result < unsafe extern "C" fn (core : * const mcd_core_st , max_payload : * mut u32) -> mcd_return_et , :: libloading :: Error > , pub mcd_qry_input_handle_f : Result < unsafe extern "C" fn (core : * const mcd_core_st , input_handle : * mut u32) -> mcd_return_et , :: libloading :: Error > , pub mcd_qry_mem_spaces_f : Result < unsafe extern "C" fn (core : * const mcd_core_st , start_index : u32 , num_mem_spaces : * mut u32 , mem_spaces : * mut mcd_memspace_st) -> mcd_return_et , :: libloading :: Error > , pub mcd_qry_mem_blocks_f : Result < unsafe extern "C" fn (core : * const mcd_core_st , mem_space_id : u32 , start_index : u32 , num_mem_blocks : * mut u32 , mem_blocks : * mut mcd_memblock_st) -> mcd_return_et , :: libloading :: Error > , pub mcd_qry_active_overlays_f : Result < unsafe extern "C" fn (core : * const mcd_core_st , start_index : u32 , num_active_overlays : * mut u32 , active_overlays : * mut u32) -> mcd_return_et , :: libloading :: Error > , pub mcd_qry_reg_groups_f : Result < unsafe extern "C" fn (core : * const mcd_core_st , start_index : u32 , num_reg_groups : * mut u32 , reg_groups : * mut mcd_register_group_st) -> mcd_return_et , :: libloading :: Error > , pub mcd_qry_reg_map_f : Result < unsafe extern "C" fn (core : * const mcd_core_st , reg_group_id : u32 , start_index : u32 , num_regs : * mut u32 , reg_info : * mut mcd_register_info_st) -> mcd_return_et , :: libloading :: Error > , pub mcd_qry_reg_compound_f : Result < unsafe extern "C" fn (core : * const mcd_core_st , compound_reg_id : u32 , start_index : u32 , num_reg_ids : * mut u32 , reg_id_array : * mut u32) -> mcd_return_et , :: libloading :: Error > , pub mcd_qry_trig_info_f : Result < unsafe extern "C" fn (core : * const mcd_core_st , trig_info : * mut mcd_trig_info_st) -> mcd_return_et , :: libloading :: Error > , pub mcd_qry_ctrigs_f : Result < unsafe extern "C" fn (core : * const mcd_core_st , start_index : u32 , num_ctrigs : * mut u32 , ctrig_info : * mut mcd_ctrig_info_st) -> mcd_return_et , :: libloading :: Error > , pub mcd_create_trig_f : Result < unsafe extern "C" fn (core : * const mcd_core_st , trig : * mut :: std :: os :: raw :: c_void , trig_id : * mut u32) -> mcd_return_et , :: libloading :: Error > , pub mcd_qry_trig_f : Result < unsafe extern "C" fn (core : * const mcd_core_st , trig_id : u32 , max_trig_size : u32 , trig : * mut :: std :: os :: raw :: c_void) -> mcd_return_et , :: libloading :: Error > , pub mcd_remove_trig_f : Result < unsafe extern "C" fn (core : * const mcd_core_st , trig_id : u32) -> mcd_return_et , :: libloading :: Error > , pub mcd_qry_trig_state_f : Result < unsafe extern "C" fn (core : * const mcd_core_st , trig_id : u32 , trig_state : * mut mcd_trig_state_st) -> mcd_return_et , :: libloading :: Error > , pub mcd_activate_trig_set_f : Result < unsafe extern "C" fn (core : * const mcd_core_st) -> mcd_return_et , :: libloading :: Error > , pub mcd_remove_trig_set_f : Result < unsafe extern "C" fn (core : * const mcd_core_st) -> mcd_return_et , :: libloading :: Error > , pub mcd_qry_trig_set_f : Result < unsafe extern "C" fn (core : * const mcd_core_st , start_index : u32 , num_trigs : * mut u32 , trig_ids : * mut u32) -> mcd_return_et , :: libloading :: Error > , pub mcd_qry_trig_set_state_f : Result < unsafe extern "C" fn (core : * const mcd_core_st , trig_state : * mut mcd_trig_set_state_st) -> mcd_return_et , :: libloading :: Error > , pub mcd_execute_txlist_f : Result < unsafe extern "C" fn (core : * const mcd_core_st , txlist : * mut mcd_txlist_st) -> mcd_return_et , :: libloading :: Error > , pub mcd_run_f : Result < unsafe extern "C" fn (core : * const mcd_core_st , global : mcd_bool_t) -> mcd_return_et , :: libloading :: Error > , pub mcd_stop_f : Result < unsafe extern "C" fn (core : * const mcd_core_st , global : mcd_bool_t) -> mcd_return_et , :: libloading :: Error > , pub mcd_run_until_f : Result < unsafe extern "C" fn (core : * const mcd_core_st , global : mcd_bool_t , absolute_time : mcd_bool_t , run_until_time : u64) -> mcd_return_et , :: libloading :: Error > , pub mcd_qry_current_time_f : Result < unsafe extern "C" fn (core : * const mcd_core_st , current_time : * mut u64) -> mcd_return_et , :: libloading :: Error > , pub mcd_step_f : Result < unsafe extern "C" fn (core : * const mcd_core_st , global : mcd_bool_t , step_type : mcd_core_step_type_et , n_steps : u32) -> mcd_return_et , :: libloading :: Error > , pub mcd_set_global_f : Result < unsafe extern "C" fn (core : * const mcd_core_st , enable : mcd_bool_t) -> mcd_return_et , :: libloading :: Error > , pub mcd_qry_state_f : Result < unsafe extern "C" fn (core : * const mcd_core_st , state : * mut mcd_core_state_st) -> mcd_return_et , :: libloading :: Error > , pub mcd_execute_command_f : Result < unsafe extern "C" fn (core : * const mcd_core_st , command_string : * const mcd_char_t , result_string_size : u32 , result_string : * mut mcd_char_t) -> mcd_return_et , :: libloading :: Error > , pub mcd_qry_rst_classes_f : Result < unsafe extern "C" fn (core : * const mcd_core_st , rst_class_vector : * mut u32) -> mcd_return_et , :: libloading :: Error > , pub mcd_qry_rst_class_info_f : Result < unsafe extern "C" fn (core : * const mcd_core_st , rst_class : u8 , rst_info : * mut mcd_rst_info_st) -> mcd_return_et , :: libloading :: Error > , pub mcd_rst_f : Result < unsafe extern "C" fn (core : * const mcd_core_st , rst_class_vector : u32 , rst_and_halt : mcd_bool_t) -> mcd_return_et , :: libloading :: Error > , pub mcd_chl_open_f : Result < unsafe extern "C" fn (core : * const mcd_core_st , channel : * mut mcd_chl_st) -> mcd_return_et , :: libloading :: Error > , pub mcd_send_msg_f : Result < unsafe extern "C" fn (core : * const mcd_core_st , channel : * const mcd_chl_st , msg_len : u32 , msg : * const u8) -> mcd_return_et , :: libloading :: Error > , pub mcd_receive_msg_f : Result < unsafe extern "C" fn (core : * const mcd_core_st , channel : * const mcd_chl_st , timeout : u32 , msg_len : * mut u32 , msg : * mut u8) -> mcd_return_et , :: libloading :: Error > , pub mcd_chl_reset_f : Result < unsafe extern "C" fn (core : * const mcd_core_st , channel : * const mcd_chl_st) -> mcd_return_et , :: libloading :: Error > , pub mcd_chl_close_f : Result < unsafe extern "C" fn (core : * const mcd_core_st , channel : * const mcd_chl_st) -> mcd_return_et , :: libloading :: Error > , pub mcd_qry_traces_f : Result < unsafe extern "C" fn (core : * const mcd_core_st , start_index : u32 , num_traces : * mut u32 , trace_info : * mut mcd_trace_info_st) -> mcd_return_et , :: libloading :: Error > , pub mcd_qry_trace_state_f : Result < unsafe extern "C" fn (core : * const mcd_core_st , trace_id : u32 , state : * mut mcd_trace_state_st) -> mcd_return_et , :: libloading :: Error > , pub mcd_set_trace_state_f : Result < unsafe extern "C" fn (core : * const mcd_core_st , trace_id : u32 , state : * mut mcd_trace_state_st) -> mcd_return_et , :: libloading :: Error > , pub mcd_read_trace_f : Result < unsafe extern "C" fn (core : * const mcd_core_st , trace_id : u32 , start_index : u64 , num_frames : * mut u32 , trace_data_size : u32 , trace_data : * mut :: std :: os :: raw :: c_void) -> mcd_return_et , :: libloading :: Error > , } impl DynamicMCDxDAS { pub unsafe fn new < P > (path : P) -> Result < Self , :: libloading :: Error > where P : AsRef < :: std :: ffi :: OsStr > { let library = :: libloading :: Library :: new (path) ? ; Self :: from_library (library) } pub unsafe fn from_library < L > (library : L) -> Result < Self , :: libloading :: Error > where L : Into < :: libloading :: Library > { let __library = library . into () ; let __va_start = __library . get (b"__va_start\0") . map (| sym | * sym) ; let __security_init_cookie = __library . get (b"__security_init_cookie\0") . map (| sym | * sym) ; let __security_check_cookie = __library . get (b"__security_check_cookie\0") . map (| sym | * sym) ; let __report_gsfailure = __library . get (b"__report_gsfailure\0") . map (| sym | * sym) ; let _invalid_parameter_noinfo = __library . get (b"_invalid_parameter_noinfo\0") . map (| sym | * sym) ; let _invalid_parameter_noinfo_noreturn = __library . get (b"_invalid_parameter_noinfo_noreturn\0") . map (| sym | * sym) ; let _invoke_watson = __library . get (b"_invoke_watson\0") . map (| sym | * sym) ; let _calloc_base = __library . get (b"_calloc_base\0") . map (| sym | * sym) ; let calloc = __library . get (b"calloc\0") . map (| sym | * sym) ; let _callnewh = __library . get (b"_callnewh\0") . map (| sym | * sym) ; let _expand = __library . get (b"_expand\0") . map (| sym | * sym) ; let _free_base = __library . get (b"_free_base\0") . map (| sym | * sym) ; let free = __library . get (b"free\0") . map (| sym | * sym) ; let _malloc_base = __library . get (b"_malloc_base\0") . map (| sym | * sym) ; let malloc = __library . get (b"malloc\0") . map (| sym | * sym) ; let _msize = __library . get (b"_msize\0") . map (| sym | * sym) ; let _realloc_base = __library . get (b"_realloc_base\0") . map (| sym | * sym) ; let realloc = __library . get (b"realloc\0") . map (| sym | * sym) ; let _recalloc = __library . get (b"_recalloc\0") . map (| sym | * sym) ; let _aligned_free = __library . get (b"_aligned_free\0") . map (| sym | * sym) ; let _aligned_malloc = __library . get (b"_aligned_malloc\0") . map (| sym | * sym) ; let _aligned_offset_malloc = __library . get (b"_aligned_offset_malloc\0") . map (| sym | * sym) ; let _aligned_msize = __library . get (b"_aligned_msize\0") . map (| sym | * sym) ; let _aligned_offset_realloc = __library . get (b"_aligned_offset_realloc\0") . map (| sym | * sym) ; let _aligned_offset_recalloc = __library . get (b"_aligned_offset_recalloc\0") . map (| sym | * sym) ; let _aligned_realloc = __library . get (b"_aligned_realloc\0") . map (| sym | * sym) ; let _aligned_recalloc = __library . get (b"_aligned_recalloc\0") . map (| sym | * sym) ; let _errno = __library . get (b"_errno\0") . map (| sym | * sym) ; let _set_errno = __library . get (b"_set_errno\0") . map (| sym | * sym) ; let _get_errno = __library . get (b"_get_errno\0") . map (| sym | * sym) ; let __threadid = __library . get (b"__threadid\0") . map (| sym | * sym) ; let __threadhandle = __library . get (b"__threadhandle\0") . map (| sym | * sym) ; let bsearch_s = __library . get (b"bsearch_s\0") . map (| sym | * sym) ; let qsort_s = __library . get (b"qsort_s\0") . map (| sym | * sym) ; let bsearch = __library . get (b"bsearch\0") . map (| sym | * sym) ; let qsort = __library . get (b"qsort\0") . map (| sym | * sym) ; let _lfind_s = __library . get (b"_lfind_s\0") . map (| sym | * sym) ; let _lfind = __library . get (b"_lfind\0") . map (| sym | * sym) ; let _lsearch_s = __library . get (b"_lsearch_s\0") . map (| sym | * sym) ; let _lsearch = __library . get (b"_lsearch\0") . map (| sym | * sym) ; let lfind = __library . get (b"lfind\0") . map (| sym | * sym) ; let lsearch = __library . get (b"lsearch\0") . map (| sym | * sym) ; let _itow_s = __library . get (b"_itow_s\0") . map (| sym | * sym) ; let _itow = __library . get (b"_itow\0") . map (| sym | * sym) ; let _ltow_s = __library . get (b"_ltow_s\0") . map (| sym | * sym) ; let _ltow = __library . get (b"_ltow\0") . map (| sym | * sym) ; let _ultow_s = __library . get (b"_ultow_s\0") . map (| sym | * sym) ; let _ultow = __library . get (b"_ultow\0") . map (| sym | * sym) ; let wcstod = __library . get (b"wcstod\0") . map (| sym | * sym) ; let _wcstod_l = __library . get (b"_wcstod_l\0") . map (| sym | * sym) ; let wcstol = __library . get (b"wcstol\0") . map (| sym | * sym) ; let _wcstol_l = __library . get (b"_wcstol_l\0") . map (| sym | * sym) ; let wcstoll = __library . get (b"wcstoll\0") . map (| sym | * sym) ; let _wcstoll_l = __library . get (b"_wcstoll_l\0") . map (| sym | * sym) ; let wcstoul = __library . get (b"wcstoul\0") . map (| sym | * sym) ; let _wcstoul_l = __library . get (b"_wcstoul_l\0") . map (| sym | * sym) ; let wcstoull = __library . get (b"wcstoull\0") . map (| sym | * sym) ; let _wcstoull_l = __library . get (b"_wcstoull_l\0") . map (| sym | * sym) ; let wcstold = __library . get (b"wcstold\0") . map (| sym | * sym) ; let _wcstold_l = __library . get (b"_wcstold_l\0") . map (| sym | * sym) ; let wcstof = __library . get (b"wcstof\0") . map (| sym | * sym) ; let _wcstof_l = __library . get (b"_wcstof_l\0") . map (| sym | * sym) ; let _wtof = __library . get (b"_wtof\0") . map (| sym | * sym) ; let _wtof_l = __library . get (b"_wtof_l\0") . map (| sym | * sym) ; let _wtoi = __library . get (b"_wtoi\0") . map (| sym | * sym) ; let _wtoi_l = __library . get (b"_wtoi_l\0") . map (| sym | * sym) ; let _wtol = __library . get (b"_wtol\0") . map (| sym | * sym) ; let _wtol_l = __library . get (b"_wtol_l\0") . map (| sym | * sym) ; let _wtoll = __library . get (b"_wtoll\0") . map (| sym | * sym) ; let _wtoll_l = __library . get (b"_wtoll_l\0") . map (| sym | * sym) ; let _i64tow_s = __library . get (b"_i64tow_s\0") . map (| sym | * sym) ; let _i64tow = __library . get (b"_i64tow\0") . map (| sym | * sym) ; let _ui64tow_s = __library . get (b"_ui64tow_s\0") . map (| sym | * sym) ; let _ui64tow = __library . get (b"_ui64tow\0") . map (| sym | * sym) ; let _wtoi64 = __library . get (b"_wtoi64\0") . map (| sym | * sym) ; let _wtoi64_l = __library . get (b"_wtoi64_l\0") . map (| sym | * sym) ; let _wcstoi64 = __library . get (b"_wcstoi64\0") . map (| sym | * sym) ; let _wcstoi64_l = __library . get (b"_wcstoi64_l\0") . map (| sym | * sym) ; let _wcstoui64 = __library . get (b"_wcstoui64\0") . map (| sym | * sym) ; let _wcstoui64_l = __library . get (b"_wcstoui64_l\0") . map (| sym | * sym) ; let _wfullpath = __library . get (b"_wfullpath\0") . map (| sym | * sym) ; let _wmakepath_s = __library . get (b"_wmakepath_s\0") . map (| sym | * sym) ; let _wmakepath = __library . get (b"_wmakepath\0") . map (| sym | * sym) ; let _wperror = __library . get (b"_wperror\0") . map (| sym | * sym) ; let _wsplitpath = __library . get (b"_wsplitpath\0") . map (| sym | * sym) ; let _wsplitpath_s = __library . get (b"_wsplitpath_s\0") . map (| sym | * sym) ; let _wdupenv_s = __library . get (b"_wdupenv_s\0") . map (| sym | * sym) ; let _wgetenv = __library . get (b"_wgetenv\0") . map (| sym | * sym) ; let _wgetenv_s = __library . get (b"_wgetenv_s\0") . map (| sym | * sym) ; let _wputenv = __library . get (b"_wputenv\0") . map (| sym | * sym) ; let _wputenv_s = __library . get (b"_wputenv_s\0") . map (| sym | * sym) ; let _wsearchenv_s = __library . get (b"_wsearchenv_s\0") . map (| sym | * sym) ; let _wsearchenv = __library . get (b"_wsearchenv\0") . map (| sym | * sym) ; let _wsystem = __library . get (b"_wsystem\0") . map (| sym | * sym) ; let _swab = __library . get (b"_swab\0") . map (| sym | * sym) ; let exit = __library . get (b"exit\0") . map (| sym | * sym) ; let _exit = __library . get (b"_exit\0") . map (| sym | * sym) ; let _Exit = __library . get (b"_Exit\0") . map (| sym | * sym) ; let quick_exit = __library . get (b"quick_exit\0") . map (| sym | * sym) ; let abort = __library . get (b"abort\0") . map (| sym | * sym) ; let _set_abort_behavior = __library . get (b"_set_abort_behavior\0") . map (| sym | * sym) ; let atexit = __library . get (b"atexit\0") . map (| sym | * sym) ; let _onexit = __library . get (b"_onexit\0") . map (| sym | * sym) ; let at_quick_exit = __library . get (b"at_quick_exit\0") . map (| sym | * sym) ; let _set_purecall_handler = __library . get (b"_set_purecall_handler\0") . map (| sym | * sym) ; let _get_purecall_handler = __library . get (b"_get_purecall_handler\0") . map (| sym | * sym) ; let _set_invalid_parameter_handler = __library . get (b"_set_invalid_parameter_handler\0") . map (| sym | * sym) ; let _get_invalid_parameter_handler = __library . get (b"_get_invalid_parameter_handler\0") . map (| sym | * sym) ; let _set_thread_local_invalid_parameter_handler = __library . get (b"_set_thread_local_invalid_parameter_handler\0") . map (| sym | * sym) ; let _get_thread_local_invalid_parameter_handler = __library . get (b"_get_thread_local_invalid_parameter_handler\0") . map (| sym | * sym) ; let _set_error_mode = __library . get (b"_set_error_mode\0") . map (| sym | * sym) ; let __doserrno = __library . get (b"__doserrno\0") . map (| sym | * sym) ; let _set_doserrno = __library . get (b"_set_doserrno\0") . map (| sym | * sym) ; let _get_doserrno = __library . get (b"_get_doserrno\0") . map (| sym | * sym) ; let __sys_errlist = __library . get (b"__sys_errlist\0") . map (| sym | * sym) ; let __sys_nerr = __library . get (b"__sys_nerr\0") . map (| sym | * sym) ; let perror = __library . get (b"perror\0") . map (| sym | * sym) ; let __p__pgmptr = __library . get (b"__p__pgmptr\0") . map (| sym | * sym) ; let __p__wpgmptr = __library . get (b"__p__wpgmptr\0") . map (| sym | * sym) ; let __p__fmode = __library . get (b"__p__fmode\0") . map (| sym | * sym) ; let _get_pgmptr = __library . get (b"_get_pgmptr\0") . map (| sym | * sym) ; let _get_wpgmptr = __library . get (b"_get_wpgmptr\0") . map (| sym | * sym) ; let _set_fmode = __library . get (b"_set_fmode\0") . map (| sym | * sym) ; let _get_fmode = __library . get (b"_get_fmode\0") . map (| sym | * sym) ; let abs = __library . get (b"abs\0") . map (| sym | * sym) ; let labs = __library . get (b"labs\0") . map (| sym | * sym) ; let llabs = __library . get (b"llabs\0") . map (| sym | * sym) ; let _abs64 = __library . get (b"_abs64\0") . map (| sym | * sym) ; let _byteswap_ushort = __library . get (b"_byteswap_ushort\0") . map (| sym | * sym) ; let _byteswap_ulong = __library . get (b"_byteswap_ulong\0") . map (| sym | * sym) ; let _byteswap_uint64 = __library . get (b"_byteswap_uint64\0") . map (| sym | * sym) ; let div = __library . get (b"div\0") . map (| sym | * sym) ; let ldiv = __library . get (b"ldiv\0") . map (| sym | * sym) ; let lldiv = __library . get (b"lldiv\0") . map (| sym | * sym) ; let _rotl = __library . get (b"_rotl\0") . map (| sym | * sym) ; let _lrotl = __library . get (b"_lrotl\0") . map (| sym | * sym) ; let _rotl64 = __library . get (b"_rotl64\0") . map (| sym | * sym) ; let _rotr = __library . get (b"_rotr\0") . map (| sym | * sym) ; let _lrotr = __library . get (b"_lrotr\0") . map (| sym | * sym) ; let _rotr64 = __library . get (b"_rotr64\0") . map (| sym | * sym) ; let srand = __library . get (b"srand\0") . map (| sym | * sym) ; let rand = __library . get (b"rand\0") . map (| sym | * sym) ; let atof = __library . get (b"atof\0") . map (| sym | * sym) ; let atoi = __library . get (b"atoi\0") . map (| sym | * sym) ; let atol = __library . get (b"atol\0") . map (| sym | * sym) ; let atoll = __library . get (b"atoll\0") . map (| sym | * sym) ; let _atoi64 = __library . get (b"_atoi64\0") . map (| sym | * sym) ; let _atof_l = __library . get (b"_atof_l\0") . map (| sym | * sym) ; let _atoi_l = __library . get (b"_atoi_l\0") . map (| sym | * sym) ; let _atol_l = __library . get (b"_atol_l\0") . map (| sym | * sym) ; let _atoll_l = __library . get (b"_atoll_l\0") . map (| sym | * sym) ; let _atoi64_l = __library . get (b"_atoi64_l\0") . map (| sym | * sym) ; let _atoflt = __library . get (b"_atoflt\0") . map (| sym | * sym) ; let _atodbl = __library . get (b"_atodbl\0") . map (| sym | * sym) ; let _atoldbl = __library . get (b"_atoldbl\0") . map (| sym | * sym) ; let _atoflt_l = __library . get (b"_atoflt_l\0") . map (| sym | * sym) ; let _atodbl_l = __library . get (b"_atodbl_l\0") . map (| sym | * sym) ; let _atoldbl_l = __library . get (b"_atoldbl_l\0") . map (| sym | * sym) ; let strtof = __library . get (b"strtof\0") . map (| sym | * sym) ; let _strtof_l = __library . get (b"_strtof_l\0") . map (| sym | * sym) ; let strtod = __library . get (b"strtod\0") . map (| sym | * sym) ; let _strtod_l = __library . get (b"_strtod_l\0") . map (| sym | * sym) ; let strtold = __library . get (b"strtold\0") . map (| sym | * sym) ; let _strtold_l = __library . get (b"_strtold_l\0") . map (| sym | * sym) ; let strtol = __library . get (b"strtol\0") . map (| sym | * sym) ; let _strtol_l = __library . get (b"_strtol_l\0") . map (| sym | * sym) ; let strtoll = __library . get (b"strtoll\0") . map (| sym | * sym) ; let _strtoll_l = __library . get (b"_strtoll_l\0") . map (| sym | * sym) ; let strtoul = __library . get (b"strtoul\0") . map (| sym | * sym) ; let _strtoul_l = __library . get (b"_strtoul_l\0") . map (| sym | * sym) ; let strtoull = __library . get (b"strtoull\0") . map (| sym | * sym) ; let _strtoull_l = __library . get (b"_strtoull_l\0") . map (| sym | * sym) ; let _strtoi64 = __library . get (b"_strtoi64\0") . map (| sym | * sym) ; let _strtoi64_l = __library . get (b"_strtoi64_l\0") . map (| sym | * sym) ; let _strtoui64 = __library . get (b"_strtoui64\0") . map (| sym | * sym) ; let _strtoui64_l = __library . get (b"_strtoui64_l\0") . map (| sym | * sym) ; let _itoa_s = __library . get (b"_itoa_s\0") . map (| sym | * sym) ; let _itoa = __library . get (b"_itoa\0") . map (| sym | * sym) ; let _ltoa_s = __library . get (b"_ltoa_s\0") . map (| sym | * sym) ; let _ltoa = __library . get (b"_ltoa\0") . map (| sym | * sym) ; let _ultoa_s = __library . get (b"_ultoa_s\0") . map (| sym | * sym) ; let _ultoa = __library . get (b"_ultoa\0") . map (| sym | * sym) ; let _i64toa_s = __library . get (b"_i64toa_s\0") . map (| sym | * sym) ; let _i64toa = __library . get (b"_i64toa\0") . map (| sym | * sym) ; let _ui64toa_s = __library . get (b"_ui64toa_s\0") . map (| sym | * sym) ; let _ui64toa = __library . get (b"_ui64toa\0") . map (| sym | * sym) ; let _ecvt_s = __library . get (b"_ecvt_s\0") . map (| sym | * sym) ; let _ecvt = __library . get (b"_ecvt\0") . map (| sym | * sym) ; let _fcvt_s = __library . get (b"_fcvt_s\0") . map (| sym | * sym) ; let _fcvt = __library . get (b"_fcvt\0") . map (| sym | * sym) ; let _gcvt_s = __library . get (b"_gcvt_s\0") . map (| sym | * sym) ; let _gcvt = __library . get (b"_gcvt\0") . map (| sym | * sym) ; let ___mb_cur_max_func = __library . get (b"___mb_cur_max_func\0") . map (| sym | * sym) ; let ___mb_cur_max_l_func = __library . get (b"___mb_cur_max_l_func\0") . map (| sym | * sym) ; let mblen = __library . get (b"mblen\0") . map (| sym | * sym) ; let _mblen_l = __library . get (b"_mblen_l\0") . map (| sym | * sym) ; let _mbstrlen = __library . get (b"_mbstrlen\0") . map (| sym | * sym) ; let _mbstrlen_l = __library . get (b"_mbstrlen_l\0") . map (| sym | * sym) ; let _mbstrnlen = __library . get (b"_mbstrnlen\0") . map (| sym | * sym) ; let _mbstrnlen_l = __library . get (b"_mbstrnlen_l\0") . map (| sym | * sym) ; let mbtowc = __library . get (b"mbtowc\0") . map (| sym | * sym) ; let _mbtowc_l = __library . get (b"_mbtowc_l\0") . map (| sym | * sym) ; let mbstowcs_s = __library . get (b"mbstowcs_s\0") . map (| sym | * sym) ; let mbstowcs = __library . get (b"mbstowcs\0") . map (| sym | * sym) ; let _mbstowcs_s_l = __library . get (b"_mbstowcs_s_l\0") . map (| sym | * sym) ; let _mbstowcs_l = __library . get (b"_mbstowcs_l\0") . map (| sym | * sym) ; let wctomb = __library . get (b"wctomb\0") . map (| sym | * sym) ; let _wctomb_l = __library . get (b"_wctomb_l\0") . map (| sym | * sym) ; let wctomb_s = __library . get (b"wctomb_s\0") . map (| sym | * sym) ; let _wctomb_s_l = __library . get (b"_wctomb_s_l\0") . map (| sym | * sym) ; let wcstombs_s = __library . get (b"wcstombs_s\0") . map (| sym | * sym) ; let wcstombs = __library . get (b"wcstombs\0") . map (| sym | * sym) ; let _wcstombs_s_l = __library . get (b"_wcstombs_s_l\0") . map (| sym | * sym) ; let _wcstombs_l = __library . get (b"_wcstombs_l\0") . map (| sym | * sym) ; let _fullpath = __library . get (b"_fullpath\0") . map (| sym | * sym) ; let _makepath_s = __library . get (b"_makepath_s\0") . map (| sym | * sym) ; let _makepath = __library . get (b"_makepath\0") . map (| sym | * sym) ; let _splitpath = __library . get (b"_splitpath\0") . map (| sym | * sym) ; let _splitpath_s = __library . get (b"_splitpath_s\0") . map (| sym | * sym) ; let getenv_s = __library . get (b"getenv_s\0") . map (| sym | * sym) ; let __p___argc = __library . get (b"__p___argc\0") . map (| sym | * sym) ; let __p___argv = __library . get (b"__p___argv\0") . map (| sym | * sym) ; let __p___wargv = __library . get (b"__p___wargv\0") . map (| sym | * sym) ; let __p__environ = __library . get (b"__p__environ\0") . map (| sym | * sym) ; let __p__wenviron = __library . get (b"__p__wenviron\0") . map (| sym | * sym) ; let getenv = __library . get (b"getenv\0") . map (| sym | * sym) ; let _dupenv_s = __library . get (b"_dupenv_s\0") . map (| sym | * sym) ; let system = __library . get (b"system\0") . map (| sym | * sym) ; let _putenv = __library . get (b"_putenv\0") . map (| sym | * sym) ; let _putenv_s = __library . get (b"_putenv_s\0") . map (| sym | * sym) ; let _searchenv_s = __library . get (b"_searchenv_s\0") . map (| sym | * sym) ; let _searchenv = __library . get (b"_searchenv\0") . map (| sym | * sym) ; let _seterrormode = __library . get (b"_seterrormode\0") . map (| sym | * sym) ; let _beep = __library . get (b"_beep\0") . map (| sym | * sym) ; let _sleep = __library . get (b"_sleep\0") . map (| sym | * sym) ; let ecvt = __library . get (b"ecvt\0") . map (| sym | * sym) ; let fcvt = __library . get (b"fcvt\0") . map (| sym | * sym) ; let gcvt = __library . get (b"gcvt\0") . map (| sym | * sym) ; let itoa = __library . get (b"itoa\0") . map (| sym | * sym) ; let ltoa = __library . get (b"ltoa\0") . map (| sym | * sym) ; let swab = __library . get (b"swab\0") . map (| sym | * sym) ; let ultoa = __library . get (b"ultoa\0") . map (| sym | * sym) ; let putenv = __library . get (b"putenv\0") . map (| sym | * sym) ; let onexit = __library . get (b"onexit\0") . map (| sym | * sym) ; let mcd_initialize_f = __library . get (b"mcd_initialize_f\0") . map (| sym | * sym) ; let mcd_exit_f = __library . get (b"mcd_exit_f\0") . map (| sym | * sym) ; let mcd_qry_servers_f = __library . get (b"mcd_qry_servers_f\0") . map (| sym | * sym) ; let mcd_open_server_f = __library . get (b"mcd_open_server_f\0") . map (| sym | * sym) ; let mcd_close_server_f = __library . get (b"mcd_close_server_f\0") . map (| sym | * sym) ; let mcd_set_server_config_f = __library . get (b"mcd_set_server_config_f\0") . map (| sym | * sym) ; let mcd_qry_server_config_f = __library . get (b"mcd_qry_server_config_f\0") . map (| sym | * sym) ; let mcd_qry_systems_f = __library . get (b"mcd_qry_systems_f\0") . map (| sym | * sym) ; let mcd_qry_devices_f = __library . get (b"mcd_qry_devices_f\0") . map (| sym | * sym) ; let mcd_qry_cores_f = __library . get (b"mcd_qry_cores_f\0") . map (| sym | * sym) ; let mcd_qry_core_modes_f = __library . get (b"mcd_qry_core_modes_f\0") . map (| sym | * sym) ; let mcd_open_core_f = __library . get (b"mcd_open_core_f\0") . map (| sym | * sym) ; let mcd_close_core_f = __library . get (b"mcd_close_core_f\0") . map (| sym | * sym) ; let mcd_qry_error_info_f = __library . get (b"mcd_qry_error_info_f\0") . map (| sym | * sym) ; let mcd_qry_device_description_f = __library . get (b"mcd_qry_device_description_f\0") . map (| sym | * sym) ; let mcd_qry_max_payload_size_f = __library . get (b"mcd_qry_max_payload_size_f\0") . map (| sym | * sym) ; let mcd_qry_input_handle_f = __library . get (b"mcd_qry_input_handle_f\0") . map (| sym | * sym) ; let mcd_qry_mem_spaces_f = __library . get (b"mcd_qry_mem_spaces_f\0") . map (| sym | * sym) ; let mcd_qry_mem_blocks_f = __library . get (b"mcd_qry_mem_blocks_f\0") . map (| sym | * sym) ; let mcd_qry_active_overlays_f = __library . get (b"mcd_qry_active_overlays_f\0") . map (| sym | * sym) ; let mcd_qry_reg_groups_f = __library . get (b"mcd_qry_reg_groups_f\0") . map (| sym | * sym) ; let mcd_qry_reg_map_f = __library . get (b"mcd_qry_reg_map_f\0") . map (| sym | * sym) ; let mcd_qry_reg_compound_f = __library . get (b"mcd_qry_reg_compound_f\0") . map (| sym | * sym) ; let mcd_qry_trig_info_f = __library . get (b"mcd_qry_trig_info_f\0") . map (| sym | * sym) ; let mcd_qry_ctrigs_f = __library . get (b"mcd_qry_ctrigs_f\0") . map (| sym | * sym) ; let mcd_create_trig_f = __library . get (b"mcd_create_trig_f\0") . map (| sym | * sym) ; let mcd_qry_trig_f = __library . get (b"mcd_qry_trig_f\0") . map (| sym | * sym) ; let mcd_remove_trig_f = __library . get (b"mcd_remove_trig_f\0") . map (| sym | * sym) ; let mcd_qry_trig_state_f = __library . get (b"mcd_qry_trig_state_f\0") . map (| sym | * sym) ; let mcd_activate_trig_set_f = __library . get (b"mcd_activate_trig_set_f\0") . map (| sym | * sym) ; let mcd_remove_trig_set_f = __library . get (b"mcd_remove_trig_set_f\0") . map (| sym | * sym) ; let mcd_qry_trig_set_f = __library . get (b"mcd_qry_trig_set_f\0") . map (| sym | * sym) ; let mcd_qry_trig_set_state_f = __library . get (b"mcd_qry_trig_set_state_f\0") . map (| sym | * sym) ; let mcd_execute_txlist_f = __library . get (b"mcd_execute_txlist_f\0") . map (| sym | * sym) ; let mcd_run_f = __library . get (b"mcd_run_f\0") . map (| sym | * sym) ; let mcd_stop_f = __library . get (b"mcd_stop_f\0") . map (| sym | * sym) ; let mcd_run_until_f = __library . get (b"mcd_run_until_f\0") . map (| sym | * sym) ; let mcd_qry_current_time_f = __library . get (b"mcd_qry_current_time_f\0") . map (| sym | * sym) ; let mcd_step_f = __library . get (b"mcd_step_f\0") . map (| sym | * sym) ; let mcd_set_global_f = __library . get (b"mcd_set_global_f\0") . map (| sym | * sym) ; let mcd_qry_state_f = __library . get (b"mcd_qry_state_f\0") . map (| sym | * sym) ; let mcd_execute_command_f = __library . get (b"mcd_execute_command_f\0") . map (| sym | * sym) ; let mcd_qry_rst_classes_f = __library . get (b"mcd_qry_rst_classes_f\0") . map (| sym | * sym) ; let mcd_qry_rst_class_info_f = __library . get (b"mcd_qry_rst_class_info_f\0") . map (| sym | * sym) ; let mcd_rst_f = __library . get (b"mcd_rst_f\0") . map (| sym | * sym) ; let mcd_chl_open_f = __library . get (b"mcd_chl_open_f\0") . map (| sym | * sym) ; let mcd_send_msg_f = __library . get (b"mcd_send_msg_f\0") . map (| sym | * sym) ; let mcd_receive_msg_f = __library . get (b"mcd_receive_msg_f\0") . map (| sym | * sym) ; let mcd_chl_reset_f = __library . get (b"mcd_chl_reset_f\0") . map (| sym | * sym) ; let mcd_chl_close_f = __library . get (b"mcd_chl_close_f\0") . map (| sym | * sym) ; let mcd_qry_traces_f = __library . get (b"mcd_qry_traces_f\0") . map (| sym | * sym) ; let mcd_qry_trace_state_f = __library . get (b"mcd_qry_trace_state_f\0") . map (| sym | * sym) ; let mcd_set_trace_state_f = __library . get (b"mcd_set_trace_state_f\0") . map (| sym | * sym) ; let mcd_read_trace_f = __library . get (b"mcd_read_trace_f\0") . map (| sym | * sym) ; Ok (DynamicMCDxDAS { __library , __va_start , __security_init_cookie , __security_check_cookie , __report_gsfailure , _invalid_parameter_noinfo , _invalid_parameter_noinfo_noreturn , _invoke_watson , _calloc_base , calloc , _callnewh , _expand , _free_base , free , _malloc_base , malloc , _msize , _realloc_base , realloc , _recalloc , _aligned_free , _aligned_malloc , _aligned_offset_malloc , _aligned_msize , _aligned_offset_realloc , _aligned_offset_recalloc , _aligned_realloc , _aligned_recalloc , _errno , _set_errno , _get_errno , __threadid , __threadhandle , bsearch_s , qsort_s , bsearch , qsort , _lfind_s , _lfind , _lsearch_s , _lsearch , lfind , lsearch , _itow_s , _itow , _ltow_s , _ltow , _ultow_s , _ultow , wcstod , _wcstod_l , wcstol , _wcstol_l , wcstoll , _wcstoll_l , wcstoul , _wcstoul_l , wcstoull , _wcstoull_l , wcstold , _wcstold_l , wcstof , _wcstof_l , _wtof , _wtof_l , _wtoi , _wtoi_l , _wtol , _wtol_l , _wtoll , _wtoll_l , _i64tow_s , _i64tow , _ui64tow_s , _ui64tow , _wtoi64 , _wtoi64_l , _wcstoi64 , _wcstoi64_l , _wcstoui64 , _wcstoui64_l , _wfullpath , _wmakepath_s , _wmakepath , _wperror , _wsplitpath , _wsplitpath_s , _wdupenv_s , _wgetenv , _wgetenv_s , _wputenv , _wputenv_s , _wsearchenv_s , _wsearchenv , _wsystem , _swab , exit , _exit , _Exit , quick_exit , abort , _set_abort_behavior , atexit , _onexit , at_quick_exit , _set_purecall_handler , _get_purecall_handler , _set_invalid_parameter_handler , _get_invalid_parameter_handler , _set_thread_local_invalid_parameter_handler , _get_thread_local_invalid_parameter_handler , _set_error_mode , __doserrno , _set_doserrno , _get_doserrno , __sys_errlist , __sys_nerr , perror , __p__pgmptr , __p__wpgmptr , __p__fmode , _get_pgmptr , _get_wpgmptr , _set_fmode , _get_fmode , abs , labs , llabs , _abs64 , _byteswap_ushort , _byteswap_ulong , _byteswap_uint64 , div , ldiv , lldiv , _rotl , _lrotl , _rotl64 , _rotr , _lrotr , _rotr64 , srand , rand , atof , atoi , atol , atoll , _atoi64 , _atof_l , _atoi_l , _atol_l , _atoll_l , _atoi64_l , _atoflt , _atodbl , _atoldbl , _atoflt_l , _atodbl_l , _atoldbl_l , strtof , _strtof_l , strtod , _strtod_l , strtold , _strtold_l , strtol , _strtol_l , strtoll , _strtoll_l , strtoul , _strtoul_l , strtoull , _strtoull_l , _strtoi64 , _strtoi64_l , _strtoui64 , _strtoui64_l , _itoa_s , _itoa , _ltoa_s , _ltoa , _ultoa_s , _ultoa , _i64toa_s , _i64toa , _ui64toa_s , _ui64toa , _ecvt_s , _ecvt , _fcvt_s , _fcvt , _gcvt_s , _gcvt , ___mb_cur_max_func , ___mb_cur_max_l_func , mblen , _mblen_l , _mbstrlen , _mbstrlen_l , _mbstrnlen , _mbstrnlen_l , mbtowc , _mbtowc_l , mbstowcs_s , mbstowcs , _mbstowcs_s_l , _mbstowcs_l , wctomb , _wctomb_l , wctomb_s , _wctomb_s_l , wcstombs_s , wcstombs , _wcstombs_s_l , _wcstombs_l , _fullpath , _makepath_s , _makepath , _splitpath , _splitpath_s , getenv_s , __p___argc , __p___argv , __p___wargv , __p__environ , __p__wenviron , getenv , _dupenv_s , system , _putenv , _putenv_s , _searchenv_s , _searchenv , _seterrormode , _beep , _sleep , ecvt , fcvt , gcvt , itoa , ltoa , swab , ultoa , putenv , onexit , mcd_initialize_f , mcd_exit_f , mcd_qry_servers_f , mcd_open_server_f , mcd_close_server_f , mcd_set_server_config_f , mcd_qry_server_config_f , mcd_qry_systems_f , mcd_qry_devices_f , mcd_qry_cores_f , mcd_qry_core_modes_f , mcd_open_core_f , mcd_close_core_f , mcd_qry_error_info_f , mcd_qry_device_description_f , mcd_qry_max_payload_size_f , mcd_qry_input_handle_f , mcd_qry_mem_spaces_f , mcd_qry_mem_blocks_f , mcd_qry_active_overlays_f , mcd_qry_reg_groups_f , mcd_qry_reg_map_f , mcd_qry_reg_compound_f , mcd_qry_trig_info_f , mcd_qry_ctrigs_f , mcd_create_trig_f , mcd_qry_trig_f , mcd_remove_trig_f , mcd_qry_trig_state_f , mcd_activate_trig_set_f , mcd_remove_trig_set_f , mcd_qry_trig_set_f , mcd_qry_trig_set_state_f , mcd_execute_txlist_f , mcd_run_f , mcd_stop_f , mcd_run_until_f , mcd_qry_current_time_f , mcd_step_f , mcd_set_global_f , mcd_qry_state_f , mcd_execute_command_f , mcd_qry_rst_classes_f , mcd_qry_rst_class_info_f , mcd_rst_f , mcd_chl_open_f , mcd_send_msg_f , mcd_receive_msg_f , mcd_chl_reset_f , mcd_chl_close_f , mcd_qry_traces_f , mcd_qry_trace_state_f , mcd_set_trace_state_f , mcd_read_trace_f }) } pub unsafe fn __security_init_cookie (& self ,) -> () { (self . __security_init_cookie . as_ref () . expect ("Expected function, got error.")) () } pub unsafe fn __security_check_cookie (& self , _StackCookie : usize) -> () { (self . __security_check_cookie . as_ref () . expect ("Expected function, got error.")) (_StackCookie) } pub unsafe fn __report_gsfailure (& self , _StackCookie : usize) -> () { (self . __report_gsfailure . as_ref () . expect ("Expected function, got error.")) (_StackCookie) } pub unsafe fn _invalid_parameter_noinfo (& self ,) -> () { (self . _invalid_parameter_noinfo . as_ref () . expect ("Expected function, got error.")) () } pub unsafe fn _invalid_parameter_noinfo_noreturn (& self ,) -> () { (self . _invalid_parameter_noinfo_noreturn . as_ref () . expect ("Expected function, got error.")) () } pub unsafe fn _invoke_watson (& self , arg1 : * const wchar_t , arg2 : * const wchar_t , arg3 : * const wchar_t , arg4 : :: std :: os :: raw :: c_uint , arg5 : usize) -> () { (self . _invoke_watson . as_ref () . expect ("Expected function, got error.")) (arg1 , arg2 , arg3 , arg4 , arg5) } pub unsafe fn _calloc_base (& self , _Count : usize , _Size : usize) -> * mut :: std :: os :: raw :: c_void { (self . _calloc_base . as_ref () . expect ("Expected function, got error.")) (_Count , _Size) } pub unsafe fn calloc (& self , _Count : :: std :: os :: raw :: c_ulonglong , _Size : :: std :: os :: raw :: c_ulonglong) -> * mut :: std :: os :: raw :: c_void { (self . calloc . as_ref () . expect ("Expected function, got error.")) (_Count , _Size) } pub unsafe fn _callnewh (& self , _Size : usize) -> :: std :: os :: raw :: c_int { (self . _callnewh . as_ref () . expect ("Expected function, got error.")) (_Size) } pub unsafe fn _expand (& self , _Block : * mut :: std :: os :: raw :: c_void , _Size : usize) -> * mut :: std :: os :: raw :: c_void { (self . _expand . as_ref () . expect ("Expected function, got error.")) (_Block , _Size) } pub unsafe fn _free_base (& self , _Block : * mut :: std :: os :: raw :: c_void) -> () { (self . _free_base . as_ref () . expect ("Expected function, got error.")) (_Block) } pub unsafe fn free (& self , _Block : * mut :: std :: os :: raw :: c_void) -> () { (self . free . as_ref () . expect ("Expected function, got error.")) (_Block) } pub unsafe fn _malloc_base (& self , _Size : usize) -> * mut :: std :: os :: raw :: c_void { (self . _malloc_base . as_ref () . expect ("Expected function, got error.")) (_Size) } pub unsafe fn malloc (& self , _Size : :: std :: os :: raw :: c_ulonglong) -> * mut :: std :: os :: raw :: c_void { (self . malloc . as_ref () . expect ("Expected function, got error.")) (_Size) } pub unsafe fn _msize (& self , _Block : * mut :: std :: os :: raw :: c_void) -> usize { (self . _msize . as_ref () . expect ("Expected function, got error.")) (_Block) } pub unsafe fn _realloc_base (& self , _Block : * mut :: std :: os :: raw :: c_void , _Size : usize) -> * mut :: std :: os :: raw :: c_void { (self . _realloc_base . as_ref () . expect ("Expected function, got error.")) (_Block , _Size) } pub unsafe fn realloc (& self , _Block : * mut :: std :: os :: raw :: c_void , _Size : :: std :: os :: raw :: c_ulonglong) -> * mut :: std :: os :: raw :: c_void { (self . realloc . as_ref () . expect ("Expected function, got error.")) (_Block , _Size) } pub unsafe fn _recalloc (& self , _Block : * mut :: std :: os :: raw :: c_void , _Count : usize , _Size : usize) -> * mut :: std :: os :: raw :: c_void { (self . _recalloc . as_ref () . expect ("Expected function, got error.")) (_Block , _Count , _Size) } pub unsafe fn _aligned_free (& self , _Block : * mut :: std :: os :: raw :: c_void) -> () { (self . _aligned_free . as_ref () . expect ("Expected function, got error.")) (_Block) } pub unsafe fn _aligned_malloc (& self , _Size : usize , _Alignment : usize) -> * mut :: std :: os :: raw :: c_void { (self . _aligned_malloc . as_ref () . expect ("Expected function, got error.")) (_Size , _Alignment) } pub unsafe fn _aligned_offset_malloc (& self , _Size : usize , _Alignment : usize , _Offset : usize) -> * mut :: std :: os :: raw :: c_void { (self . _aligned_offset_malloc . as_ref () . expect ("Expected function, got error.")) (_Size , _Alignment , _Offset) } pub unsafe fn _aligned_msize (& self , _Block : * mut :: std :: os :: raw :: c_void , _Alignment : usize , _Offset : usize) -> usize { (self . _aligned_msize . as_ref () . expect ("Expected function, got error.")) (_Block , _Alignment , _Offset) } pub unsafe fn _aligned_offset_realloc (& self , _Block : * mut :: std :: os :: raw :: c_void , _Size : usize , _Alignment : usize , _Offset : usize) -> * mut :: std :: os :: raw :: c_void { (self . _aligned_offset_realloc . as_ref () . expect ("Expected function, got error.")) (_Block , _Size , _Alignment , _Offset) } pub unsafe fn _aligned_offset_recalloc (& self , _Block : * mut :: std :: os :: raw :: c_void , _Count : usize , _Size : usize , _Alignment : usize , _Offset : usize) -> * mut :: std :: os :: raw :: c_void { (self . _aligned_offset_recalloc . as_ref () . expect ("Expected function, got error.")) (_Block , _Count , _Size , _Alignment , _Offset) } pub unsafe fn _aligned_realloc (& self , _Block : * mut :: std :: os :: raw :: c_void , _Size : usize , _Alignment : usize) -> * mut :: std :: os :: raw :: c_void { (self . _aligned_realloc . as_ref () . expect ("Expected function, got error.")) (_Block , _Size , _Alignment) } pub unsafe fn _aligned_recalloc (& self , _Block : * mut :: std :: os :: raw :: c_void , _Count : usize , _Size : usize , _Alignment : usize) -> * mut :: std :: os :: raw :: c_void { (self . _aligned_recalloc . as_ref () . expect ("Expected function, got error.")) (_Block , _Count , _Size , _Alignment) } pub unsafe fn _errno (& self ,) -> * mut :: std :: os :: raw :: c_int { (self . _errno . as_ref () . expect ("Expected function, got error.")) () } pub unsafe fn _set_errno (& self , _Value : :: std :: os :: raw :: c_int) -> errno_t { (self . _set_errno . as_ref () . expect ("Expected function, got error.")) (_Value) } pub unsafe fn _get_errno (& self , _Value : * mut :: std :: os :: raw :: c_int) -> errno_t { (self . _get_errno . as_ref () . expect ("Expected function, got error.")) (_Value) } pub unsafe fn __threadid (& self ,) -> :: std :: os :: raw :: c_ulong { (self . __threadid . as_ref () . expect ("Expected function, got error.")) () } pub unsafe fn __threadhandle (& self ,) -> usize { (self . __threadhandle . as_ref () . expect ("Expected function, got error.")) () } pub unsafe fn bsearch_s (& self , _Key : * const :: std :: os :: raw :: c_void , _Base : * const :: std :: os :: raw :: c_void , _NumOfElements : rsize_t , _SizeOfElements : rsize_t , _PtFuncCompare : :: std :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: std :: os :: raw :: c_void , arg2 : * const :: std :: os :: raw :: c_void , arg3 : * const :: std :: os :: raw :: c_void) -> :: std :: os :: raw :: c_int > , _Context : * mut :: std :: os :: raw :: c_void) -> * mut :: std :: os :: raw :: c_void { (self . bsearch_s . as_ref () . expect ("Expected function, got error.")) (_Key , _Base , _NumOfElements , _SizeOfElements , _PtFuncCompare , _Context) } pub unsafe fn qsort_s (& self , _Base : * mut :: std :: os :: raw :: c_void , _NumOfElements : rsize_t , _SizeOfElements : rsize_t , _PtFuncCompare : :: std :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: std :: os :: raw :: c_void , arg2 : * const :: std :: os :: raw :: c_void , arg3 : * const :: std :: os :: raw :: c_void) -> :: std :: os :: raw :: c_int > , _Context : * mut :: std :: os :: raw :: c_void) -> () { (self . qsort_s . as_ref () . expect ("Expected function, got error.")) (_Base , _NumOfElements , _SizeOfElements , _PtFuncCompare , _Context) } pub unsafe fn bsearch (& self , _Key : * const :: std :: os :: raw :: c_void , _Base : * const :: std :: os :: raw :: c_void , _NumOfElements : usize , _SizeOfElements : usize , _PtFuncCompare : :: std :: option :: Option < unsafe extern "C" fn (arg1 : * const :: std :: os :: raw :: c_void , arg2 : * const :: std :: os :: raw :: c_void) -> :: std :: os :: raw :: c_int >) -> * mut :: std :: os :: raw :: c_void { (self . bsearch . as_ref () . expect ("Expected function, got error.")) (_Key , _Base , _NumOfElements , _SizeOfElements , _PtFuncCompare) } pub unsafe fn qsort (& self , _Base : * mut :: std :: os :: raw :: c_void , _NumOfElements : usize , _SizeOfElements : usize , _PtFuncCompare : :: std :: option :: Option < unsafe extern "C" fn (arg1 : * const :: std :: os :: raw :: c_void , arg2 : * const :: std :: os :: raw :: c_void) -> :: std :: os :: raw :: c_int >) -> () { (self . qsort . as_ref () . expect ("Expected function, got error.")) (_Base , _NumOfElements , _SizeOfElements , _PtFuncCompare) } pub unsafe fn _lfind_s (& self , _Key : * const :: std :: os :: raw :: c_void , _Base : * const :: std :: os :: raw :: c_void , _NumOfElements : * mut :: std :: os :: raw :: c_uint , _SizeOfElements : usize , _PtFuncCompare : :: std :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: std :: os :: raw :: c_void , arg2 : * const :: std :: os :: raw :: c_void , arg3 : * const :: std :: os :: raw :: c_void) -> :: std :: os :: raw :: c_int > , _Context : * mut :: std :: os :: raw :: c_void) -> * mut :: std :: os :: raw :: c_void { (self . _lfind_s . as_ref () . expect ("Expected function, got error.")) (_Key , _Base , _NumOfElements , _SizeOfElements , _PtFuncCompare , _Context) } pub unsafe fn _lfind (& self , _Key : * const :: std :: os :: raw :: c_void , _Base : * const :: std :: os :: raw :: c_void , _NumOfElements : * mut :: std :: os :: raw :: c_uint , _SizeOfElements : :: std :: os :: raw :: c_uint , _PtFuncCompare : :: std :: option :: Option < unsafe extern "C" fn (arg1 : * const :: std :: os :: raw :: c_void , arg2 : * const :: std :: os :: raw :: c_void) -> :: std :: os :: raw :: c_int >) -> * mut :: std :: os :: raw :: c_void { (self . _lfind . as_ref () . expect ("Expected function, got error.")) (_Key , _Base , _NumOfElements , _SizeOfElements , _PtFuncCompare) } pub unsafe fn _lsearch_s (& self , _Key : * const :: std :: os :: raw :: c_void , _Base : * mut :: std :: os :: raw :: c_void , _NumOfElements : * mut :: std :: os :: raw :: c_uint , _SizeOfElements : usize , _PtFuncCompare : :: std :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: std :: os :: raw :: c_void , arg2 : * const :: std :: os :: raw :: c_void , arg3 : * const :: std :: os :: raw :: c_void) -> :: std :: os :: raw :: c_int > , _Context : * mut :: std :: os :: raw :: c_void) -> * mut :: std :: os :: raw :: c_void { (self . _lsearch_s . as_ref () . expect ("Expected function, got error.")) (_Key , _Base , _NumOfElements , _SizeOfElements , _PtFuncCompare , _Context) } pub unsafe fn _lsearch (& self , _Key : * const :: std :: os :: raw :: c_void , _Base : * mut :: std :: os :: raw :: c_void , _NumOfElements : * mut :: std :: os :: raw :: c_uint , _SizeOfElements : :: std :: os :: raw :: c_uint , _PtFuncCompare : :: std :: option :: Option < unsafe extern "C" fn (arg1 : * const :: std :: os :: raw :: c_void , arg2 : * const :: std :: os :: raw :: c_void) -> :: std :: os :: raw :: c_int >) -> * mut :: std :: os :: raw :: c_void { (self . _lsearch . as_ref () . expect ("Expected function, got error.")) (_Key , _Base , _NumOfElements , _SizeOfElements , _PtFuncCompare) } pub unsafe fn lfind (& self , _Key : * const :: std :: os :: raw :: c_void , _Base : * const :: std :: os :: raw :: c_void , _NumOfElements : * mut :: std :: os :: raw :: c_uint , _SizeOfElements : :: std :: os :: raw :: c_uint , _PtFuncCompare : :: std :: option :: Option < unsafe extern "C" fn (arg1 : * const :: std :: os :: raw :: c_void , arg2 : * const :: std :: os :: raw :: c_void) -> :: std :: os :: raw :: c_int >) -> * mut :: std :: os :: raw :: c_void { (self . lfind . as_ref () . expect ("Expected function, got error.")) (_Key , _Base , _NumOfElements , _SizeOfElements , _PtFuncCompare) } pub unsafe fn lsearch (& self , _Key : * const :: std :: os :: raw :: c_void , _Base : * mut :: std :: os :: raw :: c_void , _NumOfElements : * mut :: std :: os :: raw :: c_uint , _SizeOfElements : :: std :: os :: raw :: c_uint , _PtFuncCompare : :: std :: option :: Option < unsafe extern "C" fn (arg1 : * const :: std :: os :: raw :: c_void , arg2 : * const :: std :: os :: raw :: c_void) -> :: std :: os :: raw :: c_int >) -> * mut :: std :: os :: raw :: c_void { (self . lsearch . as_ref () . expect ("Expected function, got error.")) (_Key , _Base , _NumOfElements , _SizeOfElements , _PtFuncCompare) } pub unsafe fn _itow_s (& self , _Value : :: std :: os :: raw :: c_int , _Buffer : * mut wchar_t , _BufferCount : usize , _Radix : :: std :: os :: raw :: c_int) -> errno_t { (self . _itow_s . as_ref () . expect ("Expected function, got error.")) (_Value , _Buffer , _BufferCount , _Radix) } pub unsafe fn _itow (& self , _Value : :: std :: os :: raw :: c_int , _Buffer : * mut wchar_t , _Radix : :: std :: os :: raw :: c_int) -> * mut wchar_t { (self . _itow . as_ref () . expect ("Expected function, got error.")) (_Value , _Buffer , _Radix) } pub unsafe fn _ltow_s (& self , _Value : :: std :: os :: raw :: c_long , _Buffer : * mut wchar_t , _BufferCount : usize , _Radix : :: std :: os :: raw :: c_int) -> errno_t { (self . _ltow_s . as_ref () . expect ("Expected function, got error.")) (_Value , _Buffer , _BufferCount , _Radix) } pub unsafe fn _ltow (& self , _Value : :: std :: os :: raw :: c_long , _Buffer : * mut wchar_t , _Radix : :: std :: os :: raw :: c_int) -> * mut wchar_t { (self . _ltow . as_ref () . expect ("Expected function, got error.")) (_Value , _Buffer , _Radix) } pub unsafe fn _ultow_s (& self , _Value : :: std :: os :: raw :: c_ulong , _Buffer : * mut wchar_t , _BufferCount : usize , _Radix : :: std :: os :: raw :: c_int) -> errno_t { (self . _ultow_s . as_ref () . expect ("Expected function, got error.")) (_Value , _Buffer , _BufferCount , _Radix) } pub unsafe fn _ultow (& self , _Value : :: std :: os :: raw :: c_ulong , _Buffer : * mut wchar_t , _Radix : :: std :: os :: raw :: c_int) -> * mut wchar_t { (self . _ultow . as_ref () . expect ("Expected function, got error.")) (_Value , _Buffer , _Radix) } pub unsafe fn wcstod (& self , _String : * const wchar_t , _EndPtr : * mut * mut wchar_t) -> f64 { (self . wcstod . as_ref () . expect ("Expected function, got error.")) (_String , _EndPtr) } pub unsafe fn _wcstod_l (& self , _String : * const wchar_t , _EndPtr : * mut * mut wchar_t , _Locale : _locale_t) -> f64 { (self . _wcstod_l . as_ref () . expect ("Expected function, got error.")) (_String , _EndPtr , _Locale) } pub unsafe fn wcstol (& self , _String : * const wchar_t , _EndPtr : * mut * mut wchar_t , _Radix : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_long { (self . wcstol . as_ref () . expect ("Expected function, got error.")) (_String , _EndPtr , _Radix) } pub unsafe fn _wcstol_l (& self , _String : * const wchar_t , _EndPtr : * mut * mut wchar_t , _Radix : :: std :: os :: raw :: c_int , _Locale : _locale_t) -> :: std :: os :: raw :: c_long { (self . _wcstol_l . as_ref () . expect ("Expected function, got error.")) (_String , _EndPtr , _Radix , _Locale) } pub unsafe fn wcstoll (& self , _String : * const wchar_t , _EndPtr : * mut * mut wchar_t , _Radix : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_longlong { (self . wcstoll . as_ref () . expect ("Expected function, got error.")) (_String , _EndPtr , _Radix) } pub unsafe fn _wcstoll_l (& self , _String : * const wchar_t , _EndPtr : * mut * mut wchar_t , _Radix : :: std :: os :: raw :: c_int , _Locale : _locale_t) -> :: std :: os :: raw :: c_longlong { (self . _wcstoll_l . as_ref () . expect ("Expected function, got error.")) (_String , _EndPtr , _Radix , _Locale) } pub unsafe fn wcstoul (& self , _String : * const wchar_t , _EndPtr : * mut * mut wchar_t , _Radix : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_ulong { (self . wcstoul . as_ref () . expect ("Expected function, got error.")) (_String , _EndPtr , _Radix) } pub unsafe fn _wcstoul_l (& self , _String : * const wchar_t , _EndPtr : * mut * mut wchar_t , _Radix : :: std :: os :: raw :: c_int , _Locale : _locale_t) -> :: std :: os :: raw :: c_ulong { (self . _wcstoul_l . as_ref () . expect ("Expected function, got error.")) (_String , _EndPtr , _Radix , _Locale) } pub unsafe fn wcstoull (& self , _String : * const wchar_t , _EndPtr : * mut * mut wchar_t , _Radix : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_ulonglong { (self . wcstoull . as_ref () . expect ("Expected function, got error.")) (_String , _EndPtr , _Radix) } pub unsafe fn _wcstoull_l (& self , _String : * const wchar_t , _EndPtr : * mut * mut wchar_t , _Radix : :: std :: os :: raw :: c_int , _Locale : _locale_t) -> :: std :: os :: raw :: c_ulonglong { (self . _wcstoull_l . as_ref () . expect ("Expected function, got error.")) (_String , _EndPtr , _Radix , _Locale) } pub unsafe fn wcstold (& self , _String : * const wchar_t , _EndPtr : * mut * mut wchar_t) -> f64 { (self . wcstold . as_ref () . expect ("Expected function, got error.")) (_String , _EndPtr) } pub unsafe fn _wcstold_l (& self , _String : * const wchar_t , _EndPtr : * mut * mut wchar_t , _Locale : _locale_t) -> f64 { (self . _wcstold_l . as_ref () . expect ("Expected function, got error.")) (_String , _EndPtr , _Locale) } pub unsafe fn wcstof (& self , _String : * const wchar_t , _EndPtr : * mut * mut wchar_t) -> f32 { (self . wcstof . as_ref () . expect ("Expected function, got error.")) (_String , _EndPtr) } pub unsafe fn _wcstof_l (& self , _String : * const wchar_t , _EndPtr : * mut * mut wchar_t , _Locale : _locale_t) -> f32 { (self . _wcstof_l . as_ref () . expect ("Expected function, got error.")) (_String , _EndPtr , _Locale) } pub unsafe fn _wtof (& self , _String : * const wchar_t) -> f64 { (self . _wtof . as_ref () . expect ("Expected function, got error.")) (_String) } pub unsafe fn _wtof_l (& self , _String : * const wchar_t , _Locale : _locale_t) -> f64 { (self . _wtof_l . as_ref () . expect ("Expected function, got error.")) (_String , _Locale) } pub unsafe fn _wtoi (& self , _String : * const wchar_t) -> :: std :: os :: raw :: c_int { (self . _wtoi . as_ref () . expect ("Expected function, got error.")) (_String) } pub unsafe fn _wtoi_l (& self , _String : * const wchar_t , _Locale : _locale_t) -> :: std :: os :: raw :: c_int { (self . _wtoi_l . as_ref () . expect ("Expected function, got error.")) (_String , _Locale) } pub unsafe fn _wtol (& self , _String : * const wchar_t) -> :: std :: os :: raw :: c_long { (self . _wtol . as_ref () . expect ("Expected function, got error.")) (_String) } pub unsafe fn _wtol_l (& self , _String : * const wchar_t , _Locale : _locale_t) -> :: std :: os :: raw :: c_long { (self . _wtol_l . as_ref () . expect ("Expected function, got error.")) (_String , _Locale) } pub unsafe fn _wtoll (& self , _String : * const wchar_t) -> :: std :: os :: raw :: c_longlong { (self . _wtoll . as_ref () . expect ("Expected function, got error.")) (_String) } pub unsafe fn _wtoll_l (& self , _String : * const wchar_t , _Locale : _locale_t) -> :: std :: os :: raw :: c_longlong { (self . _wtoll_l . as_ref () . expect ("Expected function, got error.")) (_String , _Locale) } pub unsafe fn _i64tow_s (& self , _Value : :: std :: os :: raw :: c_longlong , _Buffer : * mut wchar_t , _BufferCount : usize , _Radix : :: std :: os :: raw :: c_int) -> errno_t { (self . _i64tow_s . as_ref () . expect ("Expected function, got error.")) (_Value , _Buffer , _BufferCount , _Radix) } pub unsafe fn _i64tow (& self , _Value : :: std :: os :: raw :: c_longlong , _Buffer : * mut wchar_t , _Radix : :: std :: os :: raw :: c_int) -> * mut wchar_t { (self . _i64tow . as_ref () . expect ("Expected function, got error.")) (_Value , _Buffer , _Radix) } pub unsafe fn _ui64tow_s (& self , _Value : :: std :: os :: raw :: c_ulonglong , _Buffer : * mut wchar_t , _BufferCount : usize , _Radix : :: std :: os :: raw :: c_int) -> errno_t { (self . _ui64tow_s . as_ref () . expect ("Expected function, got error.")) (_Value , _Buffer , _BufferCount , _Radix) } pub unsafe fn _ui64tow (& self , _Value : :: std :: os :: raw :: c_ulonglong , _Buffer : * mut wchar_t , _Radix : :: std :: os :: raw :: c_int) -> * mut wchar_t { (self . _ui64tow . as_ref () . expect ("Expected function, got error.")) (_Value , _Buffer , _Radix) } pub unsafe fn _wtoi64 (& self , _String : * const wchar_t) -> :: std :: os :: raw :: c_longlong { (self . _wtoi64 . as_ref () . expect ("Expected function, got error.")) (_String) } pub unsafe fn _wtoi64_l (& self , _String : * const wchar_t , _Locale : _locale_t) -> :: std :: os :: raw :: c_longlong { (self . _wtoi64_l . as_ref () . expect ("Expected function, got error.")) (_String , _Locale) } pub unsafe fn _wcstoi64 (& self , _String : * const wchar_t , _EndPtr : * mut * mut wchar_t , _Radix : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_longlong { (self . _wcstoi64 . as_ref () . expect ("Expected function, got error.")) (_String , _EndPtr , _Radix) } pub unsafe fn _wcstoi64_l (& self , _String : * const wchar_t , _EndPtr : * mut * mut wchar_t , _Radix : :: std :: os :: raw :: c_int , _Locale : _locale_t) -> :: std :: os :: raw :: c_longlong { (self . _wcstoi64_l . as_ref () . expect ("Expected function, got error.")) (_String , _EndPtr , _Radix , _Locale) } pub unsafe fn _wcstoui64 (& self , _String : * const wchar_t , _EndPtr : * mut * mut wchar_t , _Radix : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_ulonglong { (self . _wcstoui64 . as_ref () . expect ("Expected function, got error.")) (_String , _EndPtr , _Radix) } pub unsafe fn _wcstoui64_l (& self , _String : * const wchar_t , _EndPtr : * mut * mut wchar_t , _Radix : :: std :: os :: raw :: c_int , _Locale : _locale_t) -> :: std :: os :: raw :: c_ulonglong { (self . _wcstoui64_l . as_ref () . expect ("Expected function, got error.")) (_String , _EndPtr , _Radix , _Locale) } pub unsafe fn _wfullpath (& self , _Buffer : * mut wchar_t , _Path : * const wchar_t , _BufferCount : usize) -> * mut wchar_t { (self . _wfullpath . as_ref () . expect ("Expected function, got error.")) (_Buffer , _Path , _BufferCount) } pub unsafe fn _wmakepath_s (& self , _Buffer : * mut wchar_t , _BufferCount : usize , _Drive : * const wchar_t , _Dir : * const wchar_t , _Filename : * const wchar_t , _Ext : * const wchar_t) -> errno_t { (self . _wmakepath_s . as_ref () . expect ("Expected function, got error.")) (_Buffer , _BufferCount , _Drive , _Dir , _Filename , _Ext) } pub unsafe fn _wmakepath (& self , _Buffer : * mut wchar_t , _Drive : * const wchar_t , _Dir : * const wchar_t , _Filename : * const wchar_t , _Ext : * const wchar_t) -> () { (self . _wmakepath . as_ref () . expect ("Expected function, got error.")) (_Buffer , _Drive , _Dir , _Filename , _Ext) } pub unsafe fn _wperror (& self , _ErrMsg : * const wchar_t) -> () { (self . _wperror . as_ref () . expect ("Expected function, got error.")) (_ErrMsg) } pub unsafe fn _wsplitpath (& self , _FullPath : * const wchar_t , _Drive : * mut wchar_t , _Dir : * mut wchar_t , _Filename : * mut wchar_t , _Ext : * mut wchar_t) -> () { (self . _wsplitpath . as_ref () . expect ("Expected function, got error.")) (_FullPath , _Drive , _Dir , _Filename , _Ext) } pub unsafe fn _wsplitpath_s (& self , _FullPath : * const wchar_t , _Drive : * mut wchar_t , _DriveCount : usize , _Dir : * mut wchar_t , _DirCount : usize , _Filename : * mut wchar_t , _FilenameCount : usize , _Ext : * mut wchar_t , _ExtCount : usize) -> errno_t { (self . _wsplitpath_s . as_ref () . expect ("Expected function, got error.")) (_FullPath , _Drive , _DriveCount , _Dir , _DirCount , _Filename , _FilenameCount , _Ext , _ExtCount) } pub unsafe fn _wdupenv_s (& self , _Buffer : * mut * mut wchar_t , _BufferCount : * mut usize , _VarName : * const wchar_t) -> errno_t { (self . _wdupenv_s . as_ref () . expect ("Expected function, got error.")) (_Buffer , _BufferCount , _VarName) } pub unsafe fn _wgetenv (& self , _VarName : * const wchar_t) -> * mut wchar_t { (self . _wgetenv . as_ref () . expect ("Expected function, got error.")) (_VarName) } pub unsafe fn _wgetenv_s (& self , _RequiredCount : * mut usize , _Buffer : * mut wchar_t , _BufferCount : usize , _VarName : * const wchar_t) -> errno_t { (self . _wgetenv_s . as_ref () . expect ("Expected function, got error.")) (_RequiredCount , _Buffer , _BufferCount , _VarName) } pub unsafe fn _wputenv (& self , _EnvString : * const wchar_t) -> :: std :: os :: raw :: c_int { (self . _wputenv . as_ref () . expect ("Expected function, got error.")) (_EnvString) } pub unsafe fn _wputenv_s (& self , _Name : * const wchar_t , _Value : * const wchar_t) -> errno_t { (self . _wputenv_s . as_ref () . expect ("Expected function, got error.")) (_Name , _Value) } pub unsafe fn _wsearchenv_s (& self , _Filename : * const wchar_t , _VarName : * const wchar_t , _Buffer : * mut wchar_t , _BufferCount : usize) -> errno_t { (self . _wsearchenv_s . as_ref () . expect ("Expected function, got error.")) (_Filename , _VarName , _Buffer , _BufferCount) } pub unsafe fn _wsearchenv (& self , _Filename : * const wchar_t , _VarName : * const wchar_t , _ResultPath : * mut wchar_t) -> () { (self . _wsearchenv . as_ref () . expect ("Expected function, got error.")) (_Filename , _VarName , _ResultPath) } pub unsafe fn _wsystem (& self , _Command : * const wchar_t) -> :: std :: os :: raw :: c_int { (self . _wsystem . as_ref () . expect ("Expected function, got error.")) (_Command) } pub unsafe fn _swab (& self , _Buf1 : * mut :: std :: os :: raw :: c_char , _Buf2 : * mut :: std :: os :: raw :: c_char , _SizeInBytes : :: std :: os :: raw :: c_int) -> () { (self . _swab . as_ref () . expect ("Expected function, got error.")) (_Buf1 , _Buf2 , _SizeInBytes) } pub unsafe fn exit (& self , _Code : :: std :: os :: raw :: c_int) -> () { (self . exit . as_ref () . expect ("Expected function, got error.")) (_Code) } pub unsafe fn _exit (& self , _Code : :: std :: os :: raw :: c_int) -> () { (self . _exit . as_ref () . expect ("Expected function, got error.")) (_Code) } pub unsafe fn _Exit (& self , _Code : :: std :: os :: raw :: c_int) -> () { (self . _Exit . as_ref () . expect ("Expected function, got error.")) (_Code) } pub unsafe fn quick_exit (& self , _Code : :: std :: os :: raw :: c_int) -> () { (self . quick_exit . as_ref () . expect ("Expected function, got error.")) (_Code) } pub unsafe fn abort (& self ,) -> () { (self . abort . as_ref () . expect ("Expected function, got error.")) () } pub unsafe fn _set_abort_behavior (& self , _Flags : :: std :: os :: raw :: c_uint , _Mask : :: std :: os :: raw :: c_uint) -> :: std :: os :: raw :: c_uint { (self . _set_abort_behavior . as_ref () . expect ("Expected function, got error.")) (_Flags , _Mask) } pub unsafe fn atexit (& self , arg1 : :: std :: option :: Option < unsafe extern "C" fn () >) -> :: std :: os :: raw :: c_int { (self . atexit . as_ref () . expect ("Expected function, got error.")) (arg1) } pub unsafe fn _onexit (& self , _Func : _onexit_t) -> _onexit_t { (self . _onexit . as_ref () . expect ("Expected function, got error.")) (_Func) } pub unsafe fn at_quick_exit (& self , arg1 : :: std :: option :: Option < unsafe extern "C" fn () >) -> :: std :: os :: raw :: c_int { (self . at_quick_exit . as_ref () . expect ("Expected function, got error.")) (arg1) } pub unsafe fn _set_purecall_handler (& self , _Handler : _purecall_handler) -> _purecall_handler { (self . _set_purecall_handler . as_ref () . expect ("Expected function, got error.")) (_Handler) } pub unsafe fn _get_purecall_handler (& self ,) -> _purecall_handler { (self . _get_purecall_handler . as_ref () . expect ("Expected function, got error.")) () } pub unsafe fn _set_invalid_parameter_handler (& self , _Handler : _invalid_parameter_handler) -> _invalid_parameter_handler { (self . _set_invalid_parameter_handler . as_ref () . expect ("Expected function, got error.")) (_Handler) } pub unsafe fn _get_invalid_parameter_handler (& self ,) -> _invalid_parameter_handler { (self . _get_invalid_parameter_handler . as_ref () . expect ("Expected function, got error.")) () } pub unsafe fn _set_thread_local_invalid_parameter_handler (& self , _Handler : _invalid_parameter_handler) -> _invalid_parameter_handler { (self . _set_thread_local_invalid_parameter_handler . as_ref () . expect ("Expected function, got error.")) (_Handler) } pub unsafe fn _get_thread_local_invalid_parameter_handler (& self ,) -> _invalid_parameter_handler { (self . _get_thread_local_invalid_parameter_handler . as_ref () . expect ("Expected function, got error.")) () } pub unsafe fn _set_error_mode (& self , _Mode : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int { (self . _set_error_mode . as_ref () . expect ("Expected function, got error.")) (_Mode) } pub unsafe fn __doserrno (& self ,) -> * mut :: std :: os :: raw :: c_ulong { (self . __doserrno . as_ref () . expect ("Expected function, got error.")) () } pub unsafe fn _set_doserrno (& self , _Value : :: std :: os :: raw :: c_ulong) -> errno_t { (self . _set_doserrno . as_ref () . expect ("Expected function, got error.")) (_Value) } pub unsafe fn _get_doserrno (& self , _Value : * mut :: std :: os :: raw :: c_ulong) -> errno_t { (self . _get_doserrno . as_ref () . expect ("Expected function, got error.")) (_Value) } pub unsafe fn __sys_errlist (& self ,) -> * mut * mut :: std :: os :: raw :: c_char { (self . __sys_errlist . as_ref () . expect ("Expected function, got error.")) () } pub unsafe fn __sys_nerr (& self ,) -> * mut :: std :: os :: raw :: c_int { (self . __sys_nerr . as_ref () . expect ("Expected function, got error.")) () } pub unsafe fn perror (& self , _ErrMsg : * const :: std :: os :: raw :: c_char) -> () { (self . perror . as_ref () . expect ("Expected function, got error.")) (_ErrMsg) } pub unsafe fn __p__pgmptr (& self ,) -> * mut * mut :: std :: os :: raw :: c_char { (self . __p__pgmptr . as_ref () . expect ("Expected function, got error.")) () } pub unsafe fn __p__wpgmptr (& self ,) -> * mut * mut wchar_t { (self . __p__wpgmptr . as_ref () . expect ("Expected function, got error.")) () } pub unsafe fn __p__fmode (& self ,) -> * mut :: std :: os :: raw :: c_int { (self . __p__fmode . as_ref () . expect ("Expected function, got error.")) () } pub unsafe fn _get_pgmptr (& self , _Value : * mut * mut :: std :: os :: raw :: c_char) -> errno_t { (self . _get_pgmptr . as_ref () . expect ("Expected function, got error.")) (_Value) } pub unsafe fn _get_wpgmptr (& self , _Value : * mut * mut wchar_t) -> errno_t { (self . _get_wpgmptr . as_ref () . expect ("Expected function, got error.")) (_Value) } pub unsafe fn _set_fmode (& self , _Mode : :: std :: os :: raw :: c_int) -> errno_t { (self . _set_fmode . as_ref () . expect ("Expected function, got error.")) (_Mode) } pub unsafe fn _get_fmode (& self , _PMode : * mut :: std :: os :: raw :: c_int) -> errno_t { (self . _get_fmode . as_ref () . expect ("Expected function, got error.")) (_PMode) } pub unsafe fn abs (& self , _Number : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int { (self . abs . as_ref () . expect ("Expected function, got error.")) (_Number) } pub unsafe fn labs (& self , _Number : :: std :: os :: raw :: c_long) -> :: std :: os :: raw :: c_long { (self . labs . as_ref () . expect ("Expected function, got error.")) (_Number) } pub unsafe fn llabs (& self , _Number : :: std :: os :: raw :: c_longlong) -> :: std :: os :: raw :: c_longlong { (self . llabs . as_ref () . expect ("Expected function, got error.")) (_Number) } pub unsafe fn _abs64 (& self , _Number : :: std :: os :: raw :: c_longlong) -> :: std :: os :: raw :: c_longlong { (self . _abs64 . as_ref () . expect ("Expected function, got error.")) (_Number) } pub unsafe fn _byteswap_ushort (& self , _Number : :: std :: os :: raw :: c_ushort) -> :: std :: os :: raw :: c_ushort { (self . _byteswap_ushort . as_ref () . expect ("Expected function, got error.")) (_Number) } pub unsafe fn _byteswap_ulong (& self , _Number : :: std :: os :: raw :: c_ulong) -> :: std :: os :: raw :: c_ulong { (self . _byteswap_ulong . as_ref () . expect ("Expected function, got error.")) (_Number) } pub unsafe fn _byteswap_uint64 (& self , _Number : :: std :: os :: raw :: c_ulonglong) -> :: std :: os :: raw :: c_ulonglong { (self . _byteswap_uint64 . as_ref () . expect ("Expected function, got error.")) (_Number) } pub unsafe fn div (& self , _Numerator : :: std :: os :: raw :: c_int , _Denominator : :: std :: os :: raw :: c_int) -> div_t { (self . div . as_ref () . expect ("Expected function, got error.")) (_Numerator , _Denominator) } pub unsafe fn ldiv (& self , _Numerator : :: std :: os :: raw :: c_long , _Denominator : :: std :: os :: raw :: c_long) -> ldiv_t { (self . ldiv . as_ref () . expect ("Expected function, got error.")) (_Numerator , _Denominator) } pub unsafe fn lldiv (& self , _Numerator : :: std :: os :: raw :: c_longlong , _Denominator : :: std :: os :: raw :: c_longlong) -> lldiv_t { (self . lldiv . as_ref () . expect ("Expected function, got error.")) (_Numerator , _Denominator) } pub unsafe fn _rotl (& self , _Value : :: std :: os :: raw :: c_uint , _Shift : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_uint { (self . _rotl . as_ref () . expect ("Expected function, got error.")) (_Value , _Shift) } pub unsafe fn _lrotl (& self , _Value : :: std :: os :: raw :: c_ulong , _Shift : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_ulong { (self . _lrotl . as_ref () . expect ("Expected function, got error.")) (_Value , _Shift) } pub unsafe fn _rotl64 (& self , _Value : :: std :: os :: raw :: c_ulonglong , _Shift : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_ulonglong { (self . _rotl64 . as_ref () . expect ("Expected function, got error.")) (_Value , _Shift) } pub unsafe fn _rotr (& self , _Value : :: std :: os :: raw :: c_uint , _Shift : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_uint { (self . _rotr . as_ref () . expect ("Expected function, got error.")) (_Value , _Shift) } pub unsafe fn _lrotr (& self , _Value : :: std :: os :: raw :: c_ulong , _Shift : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_ulong { (self . _lrotr . as_ref () . expect ("Expected function, got error.")) (_Value , _Shift) } pub unsafe fn _rotr64 (& self , _Value : :: std :: os :: raw :: c_ulonglong , _Shift : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_ulonglong { (self . _rotr64 . as_ref () . expect ("Expected function, got error.")) (_Value , _Shift) } pub unsafe fn srand (& self , _Seed : :: std :: os :: raw :: c_uint) -> () { (self . srand . as_ref () . expect ("Expected function, got error.")) (_Seed) } pub unsafe fn rand (& self ,) -> :: std :: os :: raw :: c_int { (self . rand . as_ref () . expect ("Expected function, got error.")) () } pub unsafe fn atof (& self , _String : * const :: std :: os :: raw :: c_char) -> f64 { (self . atof . as_ref () . expect ("Expected function, got error.")) (_String) } pub unsafe fn atoi (& self , _String : * const :: std :: os :: raw :: c_char) -> :: std :: os :: raw :: c_int { (self . atoi . as_ref () . expect ("Expected function, got error.")) (_String) } pub unsafe fn atol (& self , _String : * const :: std :: os :: raw :: c_char) -> :: std :: os :: raw :: c_long { (self . atol . as_ref () . expect ("Expected function, got error.")) (_String) } pub unsafe fn atoll (& self , _String : * const :: std :: os :: raw :: c_char) -> :: std :: os :: raw :: c_longlong { (self . atoll . as_ref () . expect ("Expected function, got error.")) (_String) } pub unsafe fn _atoi64 (& self , _String : * const :: std :: os :: raw :: c_char) -> :: std :: os :: raw :: c_longlong { (self . _atoi64 . as_ref () . expect ("Expected function, got error.")) (_String) } pub unsafe fn _atof_l (& self , _String : * const :: std :: os :: raw :: c_char , _Locale : _locale_t) -> f64 { (self . _atof_l . as_ref () . expect ("Expected function, got error.")) (_String , _Locale) } pub unsafe fn _atoi_l (& self , _String : * const :: std :: os :: raw :: c_char , _Locale : _locale_t) -> :: std :: os :: raw :: c_int { (self . _atoi_l . as_ref () . expect ("Expected function, got error.")) (_String , _Locale) } pub unsafe fn _atol_l (& self , _String : * const :: std :: os :: raw :: c_char , _Locale : _locale_t) -> :: std :: os :: raw :: c_long { (self . _atol_l . as_ref () . expect ("Expected function, got error.")) (_String , _Locale) } pub unsafe fn _atoll_l (& self , _String : * const :: std :: os :: raw :: c_char , _Locale : _locale_t) -> :: std :: os :: raw :: c_longlong { (self . _atoll_l . as_ref () . expect ("Expected function, got error.")) (_String , _Locale) } pub unsafe fn _atoi64_l (& self , _String : * const :: std :: os :: raw :: c_char , _Locale : _locale_t) -> :: std :: os :: raw :: c_longlong { (self . _atoi64_l . as_ref () . expect ("Expected function, got error.")) (_String , _Locale) } pub unsafe fn _atoflt (& self , _Result : * mut _CRT_FLOAT , _String : * const :: std :: os :: raw :: c_char) -> :: std :: os :: raw :: c_int { (self . _atoflt . as_ref () . expect ("Expected function, got error.")) (_Result , _String) } pub unsafe fn _atodbl (& self , _Result : * mut _CRT_DOUBLE , _String : * mut :: std :: os :: raw :: c_char) -> :: std :: os :: raw :: c_int { (self . _atodbl . as_ref () . expect ("Expected function, got error.")) (_Result , _String) } pub unsafe fn _atoldbl (& self , _Result : * mut _LDOUBLE , _String : * mut :: std :: os :: raw :: c_char) -> :: std :: os :: raw :: c_int { (self . _atoldbl . as_ref () . expect ("Expected function, got error.")) (_Result , _String) } pub unsafe fn _atoflt_l (& self , _Result : * mut _CRT_FLOAT , _String : * const :: std :: os :: raw :: c_char , _Locale : _locale_t) -> :: std :: os :: raw :: c_int { (self . _atoflt_l . as_ref () . expect ("Expected function, got error.")) (_Result , _String , _Locale) } pub unsafe fn _atodbl_l (& self , _Result : * mut _CRT_DOUBLE , _String : * mut :: std :: os :: raw :: c_char , _Locale : _locale_t) -> :: std :: os :: raw :: c_int { (self . _atodbl_l . as_ref () . expect ("Expected function, got error.")) (_Result , _String , _Locale) } pub unsafe fn _atoldbl_l (& self , _Result : * mut _LDOUBLE , _String : * mut :: std :: os :: raw :: c_char , _Locale : _locale_t) -> :: std :: os :: raw :: c_int { (self . _atoldbl_l . as_ref () . expect ("Expected function, got error.")) (_Result , _String , _Locale) } pub unsafe fn strtof (& self , _String : * const :: std :: os :: raw :: c_char , _EndPtr : * mut * mut :: std :: os :: raw :: c_char) -> f32 { (self . strtof . as_ref () . expect ("Expected function, got error.")) (_String , _EndPtr) } pub unsafe fn _strtof_l (& self , _String : * const :: std :: os :: raw :: c_char , _EndPtr : * mut * mut :: std :: os :: raw :: c_char , _Locale : _locale_t) -> f32 { (self . _strtof_l . as_ref () . expect ("Expected function, got error.")) (_String , _EndPtr , _Locale) } pub unsafe fn strtod (& self , _String : * const :: std :: os :: raw :: c_char , _EndPtr : * mut * mut :: std :: os :: raw :: c_char) -> f64 { (self . strtod . as_ref () . expect ("Expected function, got error.")) (_String , _EndPtr) } pub unsafe fn _strtod_l (& self , _String : * const :: std :: os :: raw :: c_char , _EndPtr : * mut * mut :: std :: os :: raw :: c_char , _Locale : _locale_t) -> f64 { (self . _strtod_l . as_ref () . expect ("Expected function, got error.")) (_String , _EndPtr , _Locale) } pub unsafe fn strtold (& self , _String : * const :: std :: os :: raw :: c_char , _EndPtr : * mut * mut :: std :: os :: raw :: c_char) -> f64 { (self . strtold . as_ref () . expect ("Expected function, got error.")) (_String , _EndPtr) } pub unsafe fn _strtold_l (& self , _String : * const :: std :: os :: raw :: c_char , _EndPtr : * mut * mut :: std :: os :: raw :: c_char , _Locale : _locale_t) -> f64 { (self . _strtold_l . as_ref () . expect ("Expected function, got error.")) (_String , _EndPtr , _Locale) } pub unsafe fn strtol (& self , _String : * const :: std :: os :: raw :: c_char , _EndPtr : * mut * mut :: std :: os :: raw :: c_char , _Radix : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_long { (self . strtol . as_ref () . expect ("Expected function, got error.")) (_String , _EndPtr , _Radix) } pub unsafe fn _strtol_l (& self , _String : * const :: std :: os :: raw :: c_char , _EndPtr : * mut * mut :: std :: os :: raw :: c_char , _Radix : :: std :: os :: raw :: c_int , _Locale : _locale_t) -> :: std :: os :: raw :: c_long { (self . _strtol_l . as_ref () . expect ("Expected function, got error.")) (_String , _EndPtr , _Radix , _Locale) } pub unsafe fn strtoll (& self , _String : * const :: std :: os :: raw :: c_char , _EndPtr : * mut * mut :: std :: os :: raw :: c_char , _Radix : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_longlong { (self . strtoll . as_ref () . expect ("Expected function, got error.")) (_String , _EndPtr , _Radix) } pub unsafe fn _strtoll_l (& self , _String : * const :: std :: os :: raw :: c_char , _EndPtr : * mut * mut :: std :: os :: raw :: c_char , _Radix : :: std :: os :: raw :: c_int , _Locale : _locale_t) -> :: std :: os :: raw :: c_longlong { (self . _strtoll_l . as_ref () . expect ("Expected function, got error.")) (_String , _EndPtr , _Radix , _Locale) } pub unsafe fn strtoul (& self , _String : * const :: std :: os :: raw :: c_char , _EndPtr : * mut * mut :: std :: os :: raw :: c_char , _Radix : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_ulong { (self . strtoul . as_ref () . expect ("Expected function, got error.")) (_String , _EndPtr , _Radix) } pub unsafe fn _strtoul_l (& self , _String : * const :: std :: os :: raw :: c_char , _EndPtr : * mut * mut :: std :: os :: raw :: c_char , _Radix : :: std :: os :: raw :: c_int , _Locale : _locale_t) -> :: std :: os :: raw :: c_ulong { (self . _strtoul_l . as_ref () . expect ("Expected function, got error.")) (_String , _EndPtr , _Radix , _Locale) } pub unsafe fn strtoull (& self , _String : * const :: std :: os :: raw :: c_char , _EndPtr : * mut * mut :: std :: os :: raw :: c_char , _Radix : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_ulonglong { (self . strtoull . as_ref () . expect ("Expected function, got error.")) (_String , _EndPtr , _Radix) } pub unsafe fn _strtoull_l (& self , _String : * const :: std :: os :: raw :: c_char , _EndPtr : * mut * mut :: std :: os :: raw :: c_char , _Radix : :: std :: os :: raw :: c_int , _Locale : _locale_t) -> :: std :: os :: raw :: c_ulonglong { (self . _strtoull_l . as_ref () . expect ("Expected function, got error.")) (_String , _EndPtr , _Radix , _Locale) } pub unsafe fn _strtoi64 (& self , _String : * const :: std :: os :: raw :: c_char , _EndPtr : * mut * mut :: std :: os :: raw :: c_char , _Radix : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_longlong { (self . _strtoi64 . as_ref () . expect ("Expected function, got error.")) (_String , _EndPtr , _Radix) } pub unsafe fn _strtoi64_l (& self , _String : * const :: std :: os :: raw :: c_char , _EndPtr : * mut * mut :: std :: os :: raw :: c_char , _Radix : :: std :: os :: raw :: c_int , _Locale : _locale_t) -> :: std :: os :: raw :: c_longlong { (self . _strtoi64_l . as_ref () . expect ("Expected function, got error.")) (_String , _EndPtr , _Radix , _Locale) } pub unsafe fn _strtoui64 (& self , _String : * const :: std :: os :: raw :: c_char , _EndPtr : * mut * mut :: std :: os :: raw :: c_char , _Radix : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_ulonglong { (self . _strtoui64 . as_ref () . expect ("Expected function, got error.")) (_String , _EndPtr , _Radix) } pub unsafe fn _strtoui64_l (& self , _String : * const :: std :: os :: raw :: c_char , _EndPtr : * mut * mut :: std :: os :: raw :: c_char , _Radix : :: std :: os :: raw :: c_int , _Locale : _locale_t) -> :: std :: os :: raw :: c_ulonglong { (self . _strtoui64_l . as_ref () . expect ("Expected function, got error.")) (_String , _EndPtr , _Radix , _Locale) } pub unsafe fn _itoa_s (& self , _Value : :: std :: os :: raw :: c_int , _Buffer : * mut :: std :: os :: raw :: c_char , _BufferCount : usize , _Radix : :: std :: os :: raw :: c_int) -> errno_t { (self . _itoa_s . as_ref () . expect ("Expected function, got error.")) (_Value , _Buffer , _BufferCount , _Radix) } pub unsafe fn _itoa (& self , _Value : :: std :: os :: raw :: c_int , _Buffer : * mut :: std :: os :: raw :: c_char , _Radix : :: std :: os :: raw :: c_int) -> * mut :: std :: os :: raw :: c_char { (self . _itoa . as_ref () . expect ("Expected function, got error.")) (_Value , _Buffer , _Radix) } pub unsafe fn _ltoa_s (& self , _Value : :: std :: os :: raw :: c_long , _Buffer : * mut :: std :: os :: raw :: c_char , _BufferCount : usize , _Radix : :: std :: os :: raw :: c_int) -> errno_t { (self . _ltoa_s . as_ref () . expect ("Expected function, got error.")) (_Value , _Buffer , _BufferCount , _Radix) } pub unsafe fn _ltoa (& self , _Value : :: std :: os :: raw :: c_long , _Buffer : * mut :: std :: os :: raw :: c_char , _Radix : :: std :: os :: raw :: c_int) -> * mut :: std :: os :: raw :: c_char { (self . _ltoa . as_ref () . expect ("Expected function, got error.")) (_Value , _Buffer , _Radix) } pub unsafe fn _ultoa_s (& self , _Value : :: std :: os :: raw :: c_ulong , _Buffer : * mut :: std :: os :: raw :: c_char , _BufferCount : usize , _Radix : :: std :: os :: raw :: c_int) -> errno_t { (self . _ultoa_s . as_ref () . expect ("Expected function, got error.")) (_Value , _Buffer , _BufferCount , _Radix) } pub unsafe fn _ultoa (& self , _Value : :: std :: os :: raw :: c_ulong , _Buffer : * mut :: std :: os :: raw :: c_char , _Radix : :: std :: os :: raw :: c_int) -> * mut :: std :: os :: raw :: c_char { (self . _ultoa . as_ref () . expect ("Expected function, got error.")) (_Value , _Buffer , _Radix) } pub unsafe fn _i64toa_s (& self , _Value : :: std :: os :: raw :: c_longlong , _Buffer : * mut :: std :: os :: raw :: c_char , _BufferCount : usize , _Radix : :: std :: os :: raw :: c_int) -> errno_t { (self . _i64toa_s . as_ref () . expect ("Expected function, got error.")) (_Value , _Buffer , _BufferCount , _Radix) } pub unsafe fn _i64toa (& self , _Value : :: std :: os :: raw :: c_longlong , _Buffer : * mut :: std :: os :: raw :: c_char , _Radix : :: std :: os :: raw :: c_int) -> * mut :: std :: os :: raw :: c_char { (self . _i64toa . as_ref () . expect ("Expected function, got error.")) (_Value , _Buffer , _Radix) } pub unsafe fn _ui64toa_s (& self , _Value : :: std :: os :: raw :: c_ulonglong , _Buffer : * mut :: std :: os :: raw :: c_char , _BufferCount : usize , _Radix : :: std :: os :: raw :: c_int) -> errno_t { (self . _ui64toa_s . as_ref () . expect ("Expected function, got error.")) (_Value , _Buffer , _BufferCount , _Radix) } pub unsafe fn _ui64toa (& self , _Value : :: std :: os :: raw :: c_ulonglong , _Buffer : * mut :: std :: os :: raw :: c_char , _Radix : :: std :: os :: raw :: c_int) -> * mut :: std :: os :: raw :: c_char { (self . _ui64toa . as_ref () . expect ("Expected function, got error.")) (_Value , _Buffer , _Radix) } pub unsafe fn _ecvt_s (& self , _Buffer : * mut :: std :: os :: raw :: c_char , _BufferCount : usize , _Value : f64 , _DigitCount : :: std :: os :: raw :: c_int , _PtDec : * mut :: std :: os :: raw :: c_int , _PtSign : * mut :: std :: os :: raw :: c_int) -> errno_t { (self . _ecvt_s . as_ref () . expect ("Expected function, got error.")) (_Buffer , _BufferCount , _Value , _DigitCount , _PtDec , _PtSign) } pub unsafe fn _ecvt (& self , _Value : f64 , _DigitCount : :: std :: os :: raw :: c_int , _PtDec : * mut :: std :: os :: raw :: c_int , _PtSign : * mut :: std :: os :: raw :: c_int) -> * mut :: std :: os :: raw :: c_char { (self . _ecvt . as_ref () . expect ("Expected function, got error.")) (_Value , _DigitCount , _PtDec , _PtSign) } pub unsafe fn _fcvt_s (& self , _Buffer : * mut :: std :: os :: raw :: c_char , _BufferCount : usize , _Value : f64 , _FractionalDigitCount : :: std :: os :: raw :: c_int , _PtDec : * mut :: std :: os :: raw :: c_int , _PtSign : * mut :: std :: os :: raw :: c_int) -> errno_t { (self . _fcvt_s . as_ref () . expect ("Expected function, got error.")) (_Buffer , _BufferCount , _Value , _FractionalDigitCount , _PtDec , _PtSign) } pub unsafe fn _fcvt (& self , _Value : f64 , _FractionalDigitCount : :: std :: os :: raw :: c_int , _PtDec : * mut :: std :: os :: raw :: c_int , _PtSign : * mut :: std :: os :: raw :: c_int) -> * mut :: std :: os :: raw :: c_char { (self . _fcvt . as_ref () . expect ("Expected function, got error.")) (_Value , _FractionalDigitCount , _PtDec , _PtSign) } pub unsafe fn _gcvt_s (& self , _Buffer : * mut :: std :: os :: raw :: c_char , _BufferCount : usize , _Value : f64 , _DigitCount : :: std :: os :: raw :: c_int) -> errno_t { (self . _gcvt_s . as_ref () . expect ("Expected function, got error.")) (_Buffer , _BufferCount , _Value , _DigitCount) } pub unsafe fn _gcvt (& self , _Value : f64 , _DigitCount : :: std :: os :: raw :: c_int , _Buffer : * mut :: std :: os :: raw :: c_char) -> * mut :: std :: os :: raw :: c_char { (self . _gcvt . as_ref () . expect ("Expected function, got error.")) (_Value , _DigitCount , _Buffer) } pub unsafe fn ___mb_cur_max_func (& self ,) -> :: std :: os :: raw :: c_int { (self . ___mb_cur_max_func . as_ref () . expect ("Expected function, got error.")) () } pub unsafe fn ___mb_cur_max_l_func (& self , arg1 : _locale_t) -> :: std :: os :: raw :: c_int { (self . ___mb_cur_max_l_func . as_ref () . expect ("Expected function, got error.")) (arg1) } pub unsafe fn mblen (& self , _Ch : * const :: std :: os :: raw :: c_char , _MaxCount : usize) -> :: std :: os :: raw :: c_int { (self . mblen . as_ref () . expect ("Expected function, got error.")) (_Ch , _MaxCount) } pub unsafe fn _mblen_l (& self , _Ch : * const :: std :: os :: raw :: c_char , _MaxCount : usize , _Locale : _locale_t) -> :: std :: os :: raw :: c_int { (self . _mblen_l . as_ref () . expect ("Expected function, got error.")) (_Ch , _MaxCount , _Locale) } pub unsafe fn _mbstrlen (& self , _String : * const :: std :: os :: raw :: c_char) -> usize { (self . _mbstrlen . as_ref () . expect ("Expected function, got error.")) (_String) } pub unsafe fn _mbstrlen_l (& self , _String : * const :: std :: os :: raw :: c_char , _Locale : _locale_t) -> usize { (self . _mbstrlen_l . as_ref () . expect ("Expected function, got error.")) (_String , _Locale) } pub unsafe fn _mbstrnlen (& self , _String : * const :: std :: os :: raw :: c_char , _MaxCount : usize) -> usize { (self . _mbstrnlen . as_ref () . expect ("Expected function, got error.")) (_String , _MaxCount) } pub unsafe fn _mbstrnlen_l (& self , _String : * const :: std :: os :: raw :: c_char , _MaxCount : usize , _Locale : _locale_t) -> usize { (self . _mbstrnlen_l . as_ref () . expect ("Expected function, got error.")) (_String , _MaxCount , _Locale) } pub unsafe fn mbtowc (& self , _DstCh : * mut wchar_t , _SrcCh : * const :: std :: os :: raw :: c_char , _SrcSizeInBytes : usize) -> :: std :: os :: raw :: c_int { (self . mbtowc . as_ref () . expect ("Expected function, got error.")) (_DstCh , _SrcCh , _SrcSizeInBytes) } pub unsafe fn _mbtowc_l (& self , _DstCh : * mut wchar_t , _SrcCh : * const :: std :: os :: raw :: c_char , _SrcSizeInBytes : usize , _Locale : _locale_t) -> :: std :: os :: raw :: c_int { (self . _mbtowc_l . as_ref () . expect ("Expected function, got error.")) (_DstCh , _SrcCh , _SrcSizeInBytes , _Locale) } pub unsafe fn mbstowcs_s (& self , _PtNumOfCharConverted : * mut usize , _DstBuf : * mut wchar_t , _SizeInWords : usize , _SrcBuf : * const :: std :: os :: raw :: c_char , _MaxCount : usize) -> errno_t { (self . mbstowcs_s . as_ref () . expect ("Expected function, got error.")) (_PtNumOfCharConverted , _DstBuf , _SizeInWords , _SrcBuf , _MaxCount) } pub unsafe fn mbstowcs (& self , _Dest : * mut wchar_t , _Source : * const :: std :: os :: raw :: c_char , _MaxCount : usize) -> usize { (self . mbstowcs . as_ref () . expect ("Expected function, got error.")) (_Dest , _Source , _MaxCount) } pub unsafe fn _mbstowcs_s_l (& self , _PtNumOfCharConverted : * mut usize , _DstBuf : * mut wchar_t , _SizeInWords : usize , _SrcBuf : * const :: std :: os :: raw :: c_char , _MaxCount : usize , _Locale : _locale_t) -> errno_t { (self . _mbstowcs_s_l . as_ref () . expect ("Expected function, got error.")) (_PtNumOfCharConverted , _DstBuf , _SizeInWords , _SrcBuf , _MaxCount , _Locale) } pub unsafe fn _mbstowcs_l (& self , _Dest : * mut wchar_t , _Source : * const :: std :: os :: raw :: c_char , _MaxCount : usize , _Locale : _locale_t) -> usize { (self . _mbstowcs_l . as_ref () . expect ("Expected function, got error.")) (_Dest , _Source , _MaxCount , _Locale) } pub unsafe fn wctomb (& self , _MbCh : * mut :: std :: os :: raw :: c_char , _WCh : wchar_t) -> :: std :: os :: raw :: c_int { (self . wctomb . as_ref () . expect ("Expected function, got error.")) (_MbCh , _WCh) } pub unsafe fn _wctomb_l (& self , _MbCh : * mut :: std :: os :: raw :: c_char , _WCh : wchar_t , _Locale : _locale_t) -> :: std :: os :: raw :: c_int { (self . _wctomb_l . as_ref () . expect ("Expected function, got error.")) (_MbCh , _WCh , _Locale) } pub unsafe fn wctomb_s (& self , _SizeConverted : * mut :: std :: os :: raw :: c_int , _MbCh : * mut :: std :: os :: raw :: c_char , _SizeInBytes : rsize_t , _WCh : wchar_t) -> errno_t { (self . wctomb_s . as_ref () . expect ("Expected function, got error.")) (_SizeConverted , _MbCh , _SizeInBytes , _WCh) } pub unsafe fn _wctomb_s_l (& self , _SizeConverted : * mut :: std :: os :: raw :: c_int , _MbCh : * mut :: std :: os :: raw :: c_char , _SizeInBytes : usize , _WCh : wchar_t , _Locale : _locale_t) -> errno_t { (self . _wctomb_s_l . as_ref () . expect ("Expected function, got error.")) (_SizeConverted , _MbCh , _SizeInBytes , _WCh , _Locale) } pub unsafe fn wcstombs_s (& self , _PtNumOfCharConverted : * mut usize , _Dst : * mut :: std :: os :: raw :: c_char , _DstSizeInBytes : usize , _Src : * const wchar_t , _MaxCountInBytes : usize) -> errno_t { (self . wcstombs_s . as_ref () . expect ("Expected function, got error.")) (_PtNumOfCharConverted , _Dst , _DstSizeInBytes , _Src , _MaxCountInBytes) } pub unsafe fn wcstombs (& self , _Dest : * mut :: std :: os :: raw :: c_char , _Source : * const wchar_t , _MaxCount : usize) -> usize { (self . wcstombs . as_ref () . expect ("Expected function, got error.")) (_Dest , _Source , _MaxCount) } pub unsafe fn _wcstombs_s_l (& self , _PtNumOfCharConverted : * mut usize , _Dst : * mut :: std :: os :: raw :: c_char , _DstSizeInBytes : usize , _Src : * const wchar_t , _MaxCountInBytes : usize , _Locale : _locale_t) -> errno_t { (self . _wcstombs_s_l . as_ref () . expect ("Expected function, got error.")) (_PtNumOfCharConverted , _Dst , _DstSizeInBytes , _Src , _MaxCountInBytes , _Locale) } pub unsafe fn _wcstombs_l (& self , _Dest : * mut :: std :: os :: raw :: c_char , _Source : * const wchar_t , _MaxCount : usize , _Locale : _locale_t) -> usize { (self . _wcstombs_l . as_ref () . expect ("Expected function, got error.")) (_Dest , _Source , _MaxCount , _Locale) } pub unsafe fn _fullpath (& self , _Buffer : * mut :: std :: os :: raw :: c_char , _Path : * const :: std :: os :: raw :: c_char , _BufferCount : usize) -> * mut :: std :: os :: raw :: c_char { (self . _fullpath . as_ref () . expect ("Expected function, got error.")) (_Buffer , _Path , _BufferCount) } pub unsafe fn _makepath_s (& self , _Buffer : * mut :: std :: os :: raw :: c_char , _BufferCount : usize , _Drive : * const :: std :: os :: raw :: c_char , _Dir : * const :: std :: os :: raw :: c_char , _Filename : * const :: std :: os :: raw :: c_char , _Ext : * const :: std :: os :: raw :: c_char) -> errno_t { (self . _makepath_s . as_ref () . expect ("Expected function, got error.")) (_Buffer , _BufferCount , _Drive , _Dir , _Filename , _Ext) } pub unsafe fn _makepath (& self , _Buffer : * mut :: std :: os :: raw :: c_char , _Drive : * const :: std :: os :: raw :: c_char , _Dir : * const :: std :: os :: raw :: c_char , _Filename : * const :: std :: os :: raw :: c_char , _Ext : * const :: std :: os :: raw :: c_char) -> () { (self . _makepath . as_ref () . expect ("Expected function, got error.")) (_Buffer , _Drive , _Dir , _Filename , _Ext) } pub unsafe fn _splitpath (& self , _FullPath : * const :: std :: os :: raw :: c_char , _Drive : * mut :: std :: os :: raw :: c_char , _Dir : * mut :: std :: os :: raw :: c_char , _Filename : * mut :: std :: os :: raw :: c_char , _Ext : * mut :: std :: os :: raw :: c_char) -> () { (self . _splitpath . as_ref () . expect ("Expected function, got error.")) (_FullPath , _Drive , _Dir , _Filename , _Ext) } pub unsafe fn _splitpath_s (& self , _FullPath : * const :: std :: os :: raw :: c_char , _Drive : * mut :: std :: os :: raw :: c_char , _DriveCount : usize , _Dir : * mut :: std :: os :: raw :: c_char , _DirCount : usize , _Filename : * mut :: std :: os :: raw :: c_char , _FilenameCount : usize , _Ext : * mut :: std :: os :: raw :: c_char , _ExtCount : usize) -> errno_t { (self . _splitpath_s . as_ref () . expect ("Expected function, got error.")) (_FullPath , _Drive , _DriveCount , _Dir , _DirCount , _Filename , _FilenameCount , _Ext , _ExtCount) } pub unsafe fn getenv_s (& self , _RequiredCount : * mut usize , _Buffer : * mut :: std :: os :: raw :: c_char , _BufferCount : rsize_t , _VarName : * const :: std :: os :: raw :: c_char) -> errno_t { (self . getenv_s . as_ref () . expect ("Expected function, got error.")) (_RequiredCount , _Buffer , _BufferCount , _VarName) } pub unsafe fn __p___argc (& self ,) -> * mut :: std :: os :: raw :: c_int { (self . __p___argc . as_ref () . expect ("Expected function, got error.")) () } pub unsafe fn __p___argv (& self ,) -> * mut * mut * mut :: std :: os :: raw :: c_char { (self . __p___argv . as_ref () . expect ("Expected function, got error.")) () } pub unsafe fn __p___wargv (& self ,) -> * mut * mut * mut wchar_t { (self . __p___wargv . as_ref () . expect ("Expected function, got error.")) () } pub unsafe fn __p__environ (& self ,) -> * mut * mut * mut :: std :: os :: raw :: c_char { (self . __p__environ . as_ref () . expect ("Expected function, got error.")) () } pub unsafe fn __p__wenviron (& self ,) -> * mut * mut * mut wchar_t { (self . __p__wenviron . as_ref () . expect ("Expected function, got error.")) () } pub unsafe fn getenv (& self , _VarName : * const :: std :: os :: raw :: c_char) -> * mut :: std :: os :: raw :: c_char { (self . getenv . as_ref () . expect ("Expected function, got error.")) (_VarName) } pub unsafe fn _dupenv_s (& self , _Buffer : * mut * mut :: std :: os :: raw :: c_char , _BufferCount : * mut usize , _VarName : * const :: std :: os :: raw :: c_char) -> errno_t { (self . _dupenv_s . as_ref () . expect ("Expected function, got error.")) (_Buffer , _BufferCount , _VarName) } pub unsafe fn system (& self , _Command : * const :: std :: os :: raw :: c_char) -> :: std :: os :: raw :: c_int { (self . system . as_ref () . expect ("Expected function, got error.")) (_Command) } pub unsafe fn _putenv (& self , _EnvString : * const :: std :: os :: raw :: c_char) -> :: std :: os :: raw :: c_int { (self . _putenv . as_ref () . expect ("Expected function, got error.")) (_EnvString) } pub unsafe fn _putenv_s (& self , _Name : * const :: std :: os :: raw :: c_char , _Value : * const :: std :: os :: raw :: c_char) -> errno_t { (self . _putenv_s . as_ref () . expect ("Expected function, got error.")) (_Name , _Value) } pub unsafe fn _searchenv_s (& self , _Filename : * const :: std :: os :: raw :: c_char , _VarName : * const :: std :: os :: raw :: c_char , _Buffer : * mut :: std :: os :: raw :: c_char , _BufferCount : usize) -> errno_t { (self . _searchenv_s . as_ref () . expect ("Expected function, got error.")) (_Filename , _VarName , _Buffer , _BufferCount) } pub unsafe fn _searchenv (& self , _Filename : * const :: std :: os :: raw :: c_char , _VarName : * const :: std :: os :: raw :: c_char , _Buffer : * mut :: std :: os :: raw :: c_char) -> () { (self . _searchenv . as_ref () . expect ("Expected function, got error.")) (_Filename , _VarName , _Buffer) } pub unsafe fn _seterrormode (& self , _Mode : :: std :: os :: raw :: c_int) -> () { (self . _seterrormode . as_ref () . expect ("Expected function, got error.")) (_Mode) } pub unsafe fn _beep (& self , _Frequency : :: std :: os :: raw :: c_uint , _Duration : :: std :: os :: raw :: c_uint) -> () { (self . _beep . as_ref () . expect ("Expected function, got error.")) (_Frequency , _Duration) } pub unsafe fn _sleep (& self , _Duration : :: std :: os :: raw :: c_ulong) -> () { (self . _sleep . as_ref () . expect ("Expected function, got error.")) (_Duration) } pub unsafe fn ecvt (& self , _Value : f64 , _DigitCount : :: std :: os :: raw :: c_int , _PtDec : * mut :: std :: os :: raw :: c_int , _PtSign : * mut :: std :: os :: raw :: c_int) -> * mut :: std :: os :: raw :: c_char { (self . ecvt . as_ref () . expect ("Expected function, got error.")) (_Value , _DigitCount , _PtDec , _PtSign) } pub unsafe fn fcvt (& self , _Value : f64 , _FractionalDigitCount : :: std :: os :: raw :: c_int , _PtDec : * mut :: std :: os :: raw :: c_int , _PtSign : * mut :: std :: os :: raw :: c_int) -> * mut :: std :: os :: raw :: c_char { (self . fcvt . as_ref () . expect ("Expected function, got error.")) (_Value , _FractionalDigitCount , _PtDec , _PtSign) } pub unsafe fn gcvt (& self , _Value : f64 , _DigitCount : :: std :: os :: raw :: c_int , _DstBuf : * mut :: std :: os :: raw :: c_char) -> * mut :: std :: os :: raw :: c_char { (self . gcvt . as_ref () . expect ("Expected function, got error.")) (_Value , _DigitCount , _DstBuf) } pub unsafe fn itoa (& self , _Value : :: std :: os :: raw :: c_int , _Buffer : * mut :: std :: os :: raw :: c_char , _Radix : :: std :: os :: raw :: c_int) -> * mut :: std :: os :: raw :: c_char { (self . itoa . as_ref () . expect ("Expected function, got error.")) (_Value , _Buffer , _Radix) } pub unsafe fn ltoa (& self , _Value : :: std :: os :: raw :: c_long , _Buffer : * mut :: std :: os :: raw :: c_char , _Radix : :: std :: os :: raw :: c_int) -> * mut :: std :: os :: raw :: c_char { (self . ltoa . as_ref () . expect ("Expected function, got error.")) (_Value , _Buffer , _Radix) } pub unsafe fn swab (& self , _Buf1 : * mut :: std :: os :: raw :: c_char , _Buf2 : * mut :: std :: os :: raw :: c_char , _SizeInBytes : :: std :: os :: raw :: c_int) -> () { (self . swab . as_ref () . expect ("Expected function, got error.")) (_Buf1 , _Buf2 , _SizeInBytes) } pub unsafe fn ultoa (& self , _Value : :: std :: os :: raw :: c_ulong , _Buffer : * mut :: std :: os :: raw :: c_char , _Radix : :: std :: os :: raw :: c_int) -> * mut :: std :: os :: raw :: c_char { (self . ultoa . as_ref () . expect ("Expected function, got error.")) (_Value , _Buffer , _Radix) } pub unsafe fn putenv (& self , _EnvString : * const :: std :: os :: raw :: c_char) -> :: std :: os :: raw :: c_int { (self . putenv . as_ref () . expect ("Expected function, got error.")) (_EnvString) } pub unsafe fn onexit (& self , _Func : _onexit_t) -> _onexit_t { (self . onexit . as_ref () . expect ("Expected function, got error.")) (_Func) } # [doc = " \\brief Function initializing the interaction between a tool-side implementation and target-side implementation.\n\nThis function returns the version and vendor information for a particular\nimplementation of the MCD API in order to initialize the interaction between\na tool and a target-side implementation.\n\n\\param version_req      [in]   : MCD API version as requested by an upper layer.\n\\param impl_info        [out]  : Information about the implementation of the MCD\nAPI implementation.\n\n\\return Return code (\\c mcd_return_et).\n\n\\par Allowed error codes:\n\\c MCD_ERR_NONE     if successful.\\n\n\\c MCD_ERR_GENERAL  if target implementation is incompatible."] pub unsafe fn mcd_initialize_f (& self , version_req : * const mcd_api_version_st , impl_info : * mut mcd_impl_version_info_st) -> mcd_return_et { (self . mcd_initialize_f . as_ref () . expect ("Expected function, got error.")) (version_req , impl_info) } # [doc = " \\brief Function cleaning up all core and server connections from a tool.\n\nThis function allows to perform some cleanup functionality for all core\nconnections to a particular debugger before closing the connections."] pub unsafe fn mcd_exit_f (& self ,) -> () { (self . mcd_exit_f . as_ref () . expect ("Expected function, got error.")) () } # [doc = " \\brief Function returning a list of available servers.\n\nThis function returns a list of available (running or installed) servers.\n\n\\param host        [in]  : String containing the host name.\n\\param running     [in]  : Selects between running and installed servers.\n\\param start_index [in]  : Start index of the queried servers. This refers to\nan internal list of the target side implementation.\n\\param num_servers [in]  : The number of queried servers starting from the\ndefined \\c start_index. If it is set to '0', no\nserver descriptions are returned but the number of\nall available servers.\n\\param num_servers [out] : The number of returned servers. In case the input\nvalue of \\c num_servers is '0', this is the number\nof all available servers.\n\\param server_info [out] : Server information. This is an array allocated by\nthe calling function.\n\n\\return Return code (\\c mcd_return_et).\n\n\\par Allowed error codes:\n\\c MCD_ERR_NONE        if successful.\\n\n\\c MCD_ERR_CONNECTION  if query failed."] pub unsafe fn mcd_qry_servers_f (& self , host : * const mcd_char_t , running : mcd_bool_t , start_index : u32 , num_servers : * mut u32 , server_info : * mut mcd_server_info_st) -> mcd_return_et { (self . mcd_qry_servers_f . as_ref () . expect ("Expected function, got error.")) (host , running , start_index , num_servers , server_info) } # [doc = " \\brief Function opening the connection to a server on a host computer.\n\nThis function opens the connection to a server on a host computer and updates\nthe internal core information data base. It contains the information about\nall cores of devices which are simulated on the host computer or which are\naccessible on real silicon through a specific tool access hardware to the\nhost. This data base can then be queried at system, device and core level.\n\nFor real hardware devices, a server connection needs to be opened for each\naccess hardware. This allows individual control of the access parameters.\n\n\\param config_string [in]: Allows the configuration of the server connection by a\ncharacter string. Delimiters are blanks, tabs and line breaks. Value\nstrings are always enclosed with \"double quotes\". Bool values can be\n\"TRUE\" or \"FALSE\" (both in small letters).\n\nPre-defined \\a config_string string parameters:\n\n- McdHostName= \\c \\<string\\>       : Optional host name. Default value is \\c \"localhost\".\n- McdServerName= \\c \"<string>\"     : Name of the server to connect to.\n- McdSystemInstance= \\c \"<string>\" : Name of the simulation system instance this server\nis associated with.\n- McdServerKey= \\c <string>        : Static key for this specific server.\n- McdExitIfLastClient \\c <bool>    : If \\ref mcd_close_server_f() is called for the last\nclient connection, the server will terminate.\n\nAdditional pre-defined string parameters for real hardware:\n\n- McdAccHw= \\c <string>            : Restricts this server to connect to devices via a\nspecific access hardware as determined by the string.\n- McdAccHw.Frequency=<unsigned>    : Decimal (32 bit) value setting the frequency of the\nphysical I/F (e.g. according to IEEE 1149.1)\n- McdAccHw.PostRstDelay=<unsigned> : Delay [microseconds] after reset before first\ninteraction with the device is allowed.\n- McdAccHw.Device=\"<string>\"       : Description of connected device.\n- McdAccHw.DeviceId=<unsigned>     : Device ID (e.g. IEEE 1149.1 ID) of connected device.\n- McdAccHw.AutoDetect=<bool>       : If set to \"TRUE\" the access HW detects the device\n(DeviceId and Device will be ignored).\n- McdAccHw.Address=\"<string>\"      : Optional (e.g. TCP/IP address of access hardware).\n- McdAccHw.Port=<unsigned>         : Optional (e.g. TCP/IP port number of access hardware).\n\nInteractive Server Connection Setup\n\nIf a server(s) is running, \\ref mcd_open_server_f() can be called with an empty or NULL pointer\n\\c config_string. Then it connects to the first possible simulation system or, for real hardware,\naccess hardware path. A second call (while the first server is still open) will open the second\npossible simulation system or access hardware path and so on.\nIn order to restrict the potential list of connections to a server, \"McdServerName\"\n(and \"McdServerKey\") can be optionally provided with \\c config_string.\n\n\\ref mcd_qry_server_config_f() returns the complete configuration string for a server/device connection.\nThis allows storing this configuration to avoid an interactive server connection setup for the next\ndebug session. This is in particular useful for Real HW multi device systems in order to connect the\ndevices step by step.\n\nServer and System Keys\n\nA server can optionally require a key for access (\\c config_string parameter \"McdServerKey\").\nThis allows for example to prevent an unauthorized access to a test stand which might cause damage.\nA system key additionally allows to dynamically claim a server or to prevent several users from\nunintentionally accessing the same system at the same time through a specific set of servers.\n\nA key can be a password string or a sequence of decimal or hexadecimal numbers separated by whitespaces.\n\n\\param system_key      [in]  : A server is claimed by this key when being opened.\n\\param config_string   [in]  : String to configure the server or the access hardware device.\n\\param server          [out] : Pointer to the server connection instance. In contrast to the\nMCD API's usual calling scheme, the target has to allocate the\nobject the pointer refers to).\n\n\\return Return code (\\c mcd_return_et).\n\n\\par Allowed error codes:\n\\c MCD_ERR_NONE        if successful.\\n\n\\c MCD_ERR_CONNECTION  if server connection failed."] pub unsafe fn mcd_open_server_f (& self , system_key : * const mcd_char_t , config_string : * const mcd_char_t , server : * mut * mut mcd_server_st) -> mcd_return_et { (self . mcd_open_server_f . as_ref () . expect ("Expected function, got error.")) (system_key , config_string , server) } # [doc = " \\brief Function closing the connection to a debug server on a host computer.\n\nThis function closes the connection to an opened debug server on a host computer.\n\n\\param server            [in] : Pointer to the server connection instance of the\nopened server.\n\n\\return Return code (\\c mcd_return_et).\n\n\\par Allowed error codes:\n\\c MCD_ERR_NONE        if successful.\\n\n\\c MCD_ERR_CONNECTION  if closing the server connection failed."] pub unsafe fn mcd_close_server_f (& self , server : * const mcd_server_st) -> mcd_return_et { (self . mcd_close_server_f . as_ref () . expect ("Expected function, got error.")) (server) } # [doc = " \\brief Function changing the configuration of an open debug server.\n\nThis function allows to change the configuration of an open server.\nNote that McdHostName, McdServerName and McdSystemInstance can't be changed with this function.\nWhen the \\c config_string contains such parameter which can't be changed or parameters which can't\nbe changed to the requested value (e.g. new McdAccHw.Frequency not supporte by the Access HW), these\nparameters will be ignored or e.g. the closest possible value will be chosen by the implementation.\nThis behavior allows to use the same config strings/files for \\ref mcd_set_server_config_f() as for\n\\ref mcd_open_server_f(). The tool should always read back the actual config parameter values with\n\\ref mcd_qry_server_config_f().\n\n\\param server            [in] : Pointer to the server connection instance of the\nopened server.\n\\param config_string     [in] : String to configure the server or access hardware\ndevice.\n\n\\return Return code (\\c mcd_return_et).\n\n\\par Allowed error codes:\n\\c MCD_ERR_NONE        if successful.\\n\n\\c MCD_ERR_CONNECTION  if configuration of the server or access hardware device failed."] pub unsafe fn mcd_set_server_config_f (& self , server : * const mcd_server_st , config_string : * const mcd_char_t) -> mcd_return_et { (self . mcd_set_server_config_f . as_ref () . expect ("Expected function, got error.")) (server , config_string) } # [doc = " \\brief Function retrieving the configuration string of a debug server.\n\nThis function retrieves the configuration string of an opened\ndebug server.\n\nThe string can be used to retrieve the configuration of a server\nfor the following cases:\n- Server has been opened without setting \"McdServerName\" via \\c config_string.\n- Server has been configured with a server specific proprietary tool.\n\nCalling \\ref mcd_qry_server_config_f() with \\c max_len being a NULL pointer returns\nthe required string length for \\c config_string. The returned length includes the\nterminating zero. This retrieved configuration can be stored by an MCD based tool\nin order to configure the server connection of the next session.\n\n\\param server            [in]   : Pointer to the server connection instance.\n\\param max_len           [in]   : Maximum length of \\c config_string (as allocated\nby the calling function).\n\\param max_len           [out]  : Actual length required by the returned configuration\nstring.\n\\param config_string     [out]  : String describing the configuration of the server or\nthe access hardware device.\n\n\\return Return code (\\c mcd_return_et).\n\n\\par Allowed error codes:\n\\c MCD_ERR_NONE              if successful.\\n\n\\c MCD_ERR_CONNECTION        if server connection could not be accessed.\\n\n\\c MCD_ERR_RESULT_TOO_LONG   if requested configuration string is longer than \\c max_len."] pub unsafe fn mcd_qry_server_config_f (& self , server : * const mcd_server_st , max_len : * mut u32 , config_string : * mut mcd_char_t) -> mcd_return_et { (self . mcd_qry_server_config_f . as_ref () . expect ("Expected function, got error.")) (server , max_len , config_string) } # [doc = " \\brief Function querying the core connection information of a specified number of systems.\n\nThis function queries for the core connection information of a specified number\nof systems. The returned \\c core_con_info data are distinguished for different\nsystems only by the name of the system. If \\c num_systems is set to '0', the\nfunction call returns the number of all available systems.\n\n\\param start_index     [in]  : Start index of the queried systems. This refers to an\ninternal list of the target side implementation.\n\\param num_systems     [in]  : The number of queried systems starting from the defined\n\\c start_index. If it is set to '0', no core connection\ninformation is returned but the number of available systems.\n\\param num_systems     [out] : The number of systems the core connection info was returned\nfor. In case the input value of \\c num_systems is '0', this\nis the number of all available systems.\n\\param system_con_info [out] : Core connection information of the requested systems. This\nis an array allocated by the calling function.\n\nOnly the following information of \\c system_con_info shall be set by the target:\n- \\c system_key\n- \\c system\n- \\c system_instance\n\n\\return Return code (\\c mcd_return_et).\n\n\\par Allowed error codes:\n\\c MCD_ERR_NONE     if successful.\\n\n\\c MCD_ERR_PARAM    if \\c system_index is equal or larger than the number of available systems.\\n\n\\c MCD_ERR_GENERAL  on any other error."] pub unsafe fn mcd_qry_systems_f (& self , start_index : u32 , num_systems : * mut u32 , system_con_info : * mut mcd_core_con_info_st) -> mcd_return_et { (self . mcd_qry_systems_f . as_ref () . expect ("Expected function, got error.")) (start_index , num_systems , system_con_info) } # [doc = " \\brief Function querying the core connection information of a specified number of devices of a system.\n\nThis function queries for the core connection information of a specified number of devices of a\nparticular system. If \\c num_devices is set to '0', the function call returns the number of\nall available devices for the system.\n\n\\param system_con_info  [in]  : Core connection information of the system the devices\nare queried from.\n\\param start_index      [in]  : Start index of the requested devices. This refers to\nan internal list of the target side implementation.\n\\param num_devices      [in]  : The number of queried devices (e.g. simulated on or\nconnected to this host computer) starting from the\ndefined \\c start_index. If it is set to '0', no core\nconnection information is returned but the number of\nall available devices.\n\\param num_devices      [out] : The number of devices the core connection information\nwas returned for. In case the input value of \\c num_devices\nis '0', this is the number of all available devices for\nthe selected system.\n\\param device_con_info  [out] : Core connection information of the requested devices.\nThis is an array allocated by the calling function.\n\nOnly the \\c system and \\c system_instance information of \\c system_con_info are\nused for system selection.\n\nOnly the following information of \\c device_con_info shall be set by the target:\n- \\c host\n- \\c server_port\n- \\c system_key\n- \\c device_key       (zero length string if no device key)\n- \\c system\n- \\c system_instance  (zero length string for Real HW)\n- \\c acc_hw           (for Real HW)\n- \\c device_type\n- \\c device\n- \\c device_id\n\n\\return Return code (\\c mcd_return_et).\n\n\\par Allowed error codes:\n\\c MCD_ERR_NONE       if successful.\\n\n\\c MCD_ERR_PARAM      if \\c start_index is equal or larger than the number of available devices.\\n\n\\c MCD_ERR_GENERAL    on any other error."] pub unsafe fn mcd_qry_devices_f (& self , system_con_info : * const mcd_core_con_info_st , start_index : u32 , num_devices : * mut u32 , device_con_info : * mut mcd_core_con_info_st) -> mcd_return_et { (self . mcd_qry_devices_f . as_ref () . expect ("Expected function, got error.")) (system_con_info , start_index , num_devices , device_con_info) } # [doc = " \\brief Function querying the core connection information of a specified number of cores of a system/device.\n\nThis function queries the core connection information of a specified number of cores of a system/device.\n\n\\param connection_info  [in]  : Core connection information of the system or device the cores\nare queried from.\n\\param start_index      [in]  : Start index of the requested cores. This refers to an internal\nlist of the target side implementation.\n\\param num_cores        [in]  : The number of queried cores starting from the defined \\c start_index.\nIf it is set to '0', no core connection information is returned but\nthe number of all available cores.\n\\param num_cores        [out] : The number of cores the core connection information is returned for.\nIn case the input value of \\c num_cores is '0', this is the number of\nall available cores for the selected system or device.\n\\param core_con_info    [out] : Core connection information of the requested cores. This is an array\nallocated by the calling function.\n\nOnly the \\c system and \\c system_instance information of \\c connection_info are used for\nsystem selection.\n\nFor selecting a specific device, the following information of \\c connection_info is used:\n- \\c host\n- \\c server_port\n- \\c system_key\n- \\c device_key       (zero length string if no device key)\n- \\c system\n- \\c system_instance  (zero length string for Real HW)\n- \\c acc_hw           (for Real HW)\n- \\c device_type\n- \\c device\n- \\c device_id\n\nIf \\c device and \\c acc_hw are given for Real HW, only the cores of this specific device\nwill be returned.\n\nThe output parameter \\c core_con_info shall contain the complete \\ref mcd_core_con_info_st\ninformation except from \\c device_key.\n\n\\return Return code (\\c mcd_return_et).\n\n\\par Allowed error codes:\n\\c MCD_ERR_NONE       if successful.\\n\n\\c MCD_ERR_PARAM      if \\c start_index is equal or larger than the number of available cores.\\n\n\\c MCD_ERR_GENERAL    on any other error."] pub unsafe fn mcd_qry_cores_f (& self , connection_info : * const mcd_core_con_info_st , start_index : u32 , num_cores : * mut u32 , core_con_info : * mut mcd_core_con_info_st) -> mcd_return_et { (self . mcd_qry_cores_f . as_ref () . expect ("Expected function, got error.")) (connection_info , start_index , num_cores , core_con_info) } # [doc = " \\brief Function querying the available modes of a core.\n\nThis function queries the available modes of a specific core.\n\n\\param core             [in]  : A reference to the core the calling function addresses.\n\\param start_index      [in]  : Start index of the requested modes. This refers to an\ninternal list of the target side implementation.\n\\param num_modes        [in]  : The number of queried core modes starting from the defined\n\\c start_index. If it is set to '0', no core modes are\nreturned but the number of all available core modes.\n\\param num_modes        [out] : The number of returned core modes. In case the input value\nof \\c num_modes is '0', this is the number of all available\ncore modes for the selected core.\n\\param core_mode_info   [out] : Core mode information of the requested core. This is an\narray allocated by the calling function.\n\n\\return Return code (\\c mcd_return_et).\n\n\\par Allowed error codes:\n\\c MCD_ERR_NONE       if successful.\\n\n\\c MCD_ERR_PARAM      if \\c start_index is equal or larger than the number of available core modes.\\n\n\\c MCD_ERR_GENERAL    on any other error."] pub unsafe fn mcd_qry_core_modes_f (& self , core : * const mcd_core_st , start_index : u32 , num_modes : * mut u32 , core_mode_info : * mut mcd_core_mode_info_st) -> mcd_return_et { (self . mcd_qry_core_modes_f . as_ref () . expect ("Expected function, got error.")) (core , start_index , num_modes , core_mode_info) } # [doc = " \\brief Function opening a core connection.\n\nThis function opens a specific core connection.\n\n\\param core_con_info  [in]  : Unambigious core information (e.g. from \\ref mcd_qry_cores_f()).\n\\param core           [out] : Pointer to the requested core connection instance (In contrast to\nthe API's usual scheme, the target has to allocate the object the\npointer refers to).\n\nNote that \\c device_key needs to be set in \\c core_con_info in case of opening a locked device.\n\n\\return Return code (\\c mcd_return_et).\n\n\\par Allowed error codes:\n\\c MCD_ERR_NONE           if successful.\\n\n\\c MCD_ERR_PARAM          if \\c core_con_info is ambigious.\\n\n\\c MCD_ERR_DEVICE_LOCKED  if the requested device is locked.\\n\n\\c MCD_ERR_CONNECTION     if opening the core connection failed."] pub unsafe fn mcd_open_core_f (& self , core_con_info : * const mcd_core_con_info_st , core : * mut * mut mcd_core_st) -> mcd_return_et { (self . mcd_open_core_f . as_ref () . expect ("Expected function, got error.")) (core_con_info , core) } # [doc = " \\brief Function closing a core connection.\n\nThis function closes a specific core connection.\n\n\\param core   [in] : Pointer to the core connection instance of the core to close.\n\n\\return Return code (\\c mcd_return_et).\n\n\\par Allowed error codes:\n\\c MCD_ERR_NONE          if successful.\\n\n\\c MCD_ERR_CONNECTION    if closing the core connection failed."] pub unsafe fn mcd_close_core_f (& self , core : * const mcd_core_st) -> mcd_return_et { (self . mcd_close_core_f . as_ref () . expect ("Expected function, got error.")) (core) } # [doc = " \\brief Function allowing the access to detailed error and/or event information after an API call.\n\nThis function allows the user to access detailed error and/or event information after an API call.\n\nAlmost all MCD API functions return a value of type \\c mcd_return_et. This is an enumeration type\ninforming the calling function how to react on the API function call's results. If an error occurred,\nthe calling function has to call this function in order to obtain details about the error and/or\nevent which occurred during the previous call and in order to gain further details on it.\n\n\\param core       [in]  : A reference to the core the calling function addresses. This parameter\ncan be NULL if the error occured at a function without a parameter of\ntype \\ref mcd_core_st.\n\\param error_info [out] : Pointer to a structure containing the detailed error/event information."] pub unsafe fn mcd_qry_error_info_f (& self , core : * const mcd_core_st , error_info : * mut mcd_error_info_st) -> () { (self . mcd_qry_error_info_f . as_ref () . expect ("Expected function, got error.")) (core , error_info) } # [doc = " \\brief Function retrieving the file information of an IP-XACT description of the addressed component.\n\nThis functions can be used to request the URL where an IP-XACT\ndescription describing a system can be aquired. The most common for\nis to use a URL starting with \"file://...\" refering to a local\nfile where the desciption is stored in the local filesystem. This\nis also the only mandatory URI scheme (\"protocol\") which must be\nsupported in every tool.  Other possible options are URLs starting\nwith \"http://...\" or \"ftp://...\". URLs might either point to the\nMCD server itself, but could also point to locations on other\nservers.\n\n\\param core        [in]   : A reference to the core the calling function addresses.\n\\param url         [out]  : A pointer to the string containing the URL pointing to the IP-XACT description\nis returned through this parameter. Space for the URL must be reserved by the\ncaller. The string returned must be null terminated except if it is too large to\nfit the buffer. If called with a null pointer then the required buffer size will\nbe returned in the url_length parameter.\n\\param url_length  [in]   : Pointing to the size of the buffer allocated by the caller.\n\\param url_length  [out]  : Pointing to the size of the URL returned excluding the terminating '\\\\0' character.\nWhen called with url=0 returns the size of the buffer required including the\nterminating '\\\\0' character.\n\n\\return Return code (\\c mcd_return_et).\n\n\\par Allowed error codes:\n\\c MCD_ERR_NONE      if successful.\\n\n\\c MCD_ERR_GENERAL   if URL could not be provided."] pub unsafe fn mcd_qry_device_description_f (& self , core : * const mcd_core_st , url : * mut mcd_char_t , url_length : * mut u32) -> mcd_return_et { (self . mcd_qry_device_description_f . as_ref () . expect ("Expected function, got error.")) (core , url , url_length) } # [doc = " \\brief Function querying the maximum payload size for a transaction list.\n\nDifferent systems will support a different maximum in transaction list payload sizes.\nThe payload is the net number of bytes that are read or written. This function queries\nthe maximum payload size for a transaction list.\nSince a tool needs to be able to deal with smaller payload sizes, the only reason to use\nlarger payloads is an improved performance. In order to achieve this performance, it is\nrecommended that \\c max_payload is equal to the payload allowing the optimum performance.\n\\c max_payload then should be obeyed by the sent transaction lists.\n\n\\param core        [in]  : A reference to the core the calling function addresses.\n\\param max_payload [out] : Maximum (and optimum) supported payload size for a\ntransaction list.\n\n\\return Return code (\\c mcd_return_et).\n\n\\par Allowed error codes:\n\\c MCD_ERR_NONE     if successful.\\n\n\\c MCD_ERR_GENERAL  on any other error."] pub unsafe fn mcd_qry_max_payload_size_f (& self , core : * const mcd_core_st , max_payload : * mut u32) -> mcd_return_et { (self . mcd_qry_max_payload_size_f . as_ref () . expect ("Expected function, got error.")) (core , max_payload) } # [doc = " \\brief Function querying the input handle for the connection.\n\nFast and efficient reaction on target system events with a single threaded application\nrequires that the application can wait for user input or asychronous activity from the target.\nObtaining the handle used for the communication to the target (usually a socket) allows\nthe application to wait for activity there without frequent polling. If the communication is\nnot done by sockets then there may be no such handle.\n\n\\param core         [in]  : A reference to the core the calling function addresses.\n\\param input_handle [out] : Input handle or -1 if handle not defined.\n\n\\return Return code (\\c mcd_return_et).\n\n\\par Allowed error codes:\n\\c MCD_ERR_NONE     if successful.\\n\n\\c MCD_ERR_GENERAL  on any other error."] pub unsafe fn mcd_qry_input_handle_f (& self , core : * const mcd_core_st , input_handle : * mut u32) -> mcd_return_et { (self . mcd_qry_input_handle_f . as_ref () . expect ("Expected function, got error.")) (core , input_handle) } # [doc = "  \\brief Function querying the available memory spaces for a particular component.\n\nThere can be various memory spaces visible to a core depending on its architecture.\nFor Harvard architectures these can be \"program\" and \"data\", for DSP\narchitecture these can be \"P\"/\"X\"/\"Y\", etc. This function queries all memory spaces\navailable for a particular target core.\n\n\\param core           [in]  : A reference to the core the calling function addresses.\n\\param start_index    [in]  : Start index of the requested memory spaces. This refers\nto an internal list of the target side implementation.\n\\param num_mem_spaces [in]  : Number of memory spaces, information is requested of. If\nit is set to '0', no memory space information is returned\nbut the number of all available memory spaces for the\nselected core.\n\\param num_mem_spaces [out] : The number of returned memory spaces. In case the input\nvalue of \\c num_mem_spaces is '0', this is the number of\nall available memory spaces for the selected core.\n\\param mem_spaces     [out] : Memory space information. This is an array allocated by\nthe calling function.\n\n\\return Return code (\\c mcd_return_et).\n\n\\par Allowed error codes:\n\\c MCD_ERR_NONE              if successful.\\n\n\\c MCD_ERR_NO_MEM_SPACES     if no memory spaces are defined for this core."] pub unsafe fn mcd_qry_mem_spaces_f (& self , core : * const mcd_core_st , start_index : u32 , num_mem_spaces : * mut u32 , mem_spaces : * mut mcd_memspace_st) -> mcd_return_et { (self . mcd_qry_mem_spaces_f . as_ref () . expect ("Expected function, got error.")) (core , start_index , num_mem_spaces , mem_spaces) } # [doc = "  \\brief Function querying the available memory blocks of a specified memory space.\n\nThere can be various memory blocks within a particular memory space of a core. The\nmemory blocks define the layout of the memory space. Memory blocks can be hierarchical\nin nature, and this query function returns information about all available memory\nblocks in the memory space. Memory blocks with the same parent must not overlap.\nThis call returns existing memory blocks only. If a target side implementation supports\nmemory block descriptions, the calling function may assume that memory which does not\nbelong to any memory block is not addressable.\n\n\\param core           [in]  : A reference to the core the calling function addresses.\n\\param mem_space_id   [in]  : The ID of the memory space the calling function queries\nthe memory block information from.\n\\param start_index    [in]  : Start index of the requested memory blocks. This refers\nto an internal list of the target side implementation.\n\\param num_mem_blocks [in]  : Number of memory blocks, information is requested of. If\nit is set to '0', no memory block information is returned\nbut the number of all available memory blocks for the\nselected memory.\n\\param num_mem_blocks [out] : Number of returned memory blocks. In case the input value\nof \\c num_mem_blocks is '0', this is the number of all\navailable memory blocks for the selected memory space.\n\\param mem_blocks     [out] : Memory block information. This is an array allocated by\nthe calling function.\n\n\\return Return code (\\c mcd_return_et).\n\n\\par Allowed error codes:\n\\c MCD_ERR_NONE              if successful.\\n\n\\c MCD_ERR_NO_MEM_BLOCKS     if no memory blocks are defined for this memory space."] pub unsafe fn mcd_qry_mem_blocks_f (& self , core : * const mcd_core_st , mem_space_id : u32 , start_index : u32 , num_mem_blocks : * mut u32 , mem_blocks : * mut mcd_memblock_st) -> mcd_return_et { (self . mcd_qry_mem_blocks_f . as_ref () . expect ("Expected function, got error.")) (core , mem_space_id , start_index , num_mem_blocks , mem_blocks) } # [doc = "  \\brief Function querying the active (swapped-in) overlays at the current time.\n\nThis function is called when the caller wants to retrieve the list of active\nmemory overlays. This is typically done when a breakpoint is hit.\n\n\\param core                [in]  : A reference to the core the calling function addresses.\n\\param start_index         [in]  : Start index of the requested active memory overlays. This\nrefers to an internal list of the target side implementation.\n\\param num_active_overlays [in]  : Number of active memory overlays, information is requested of.\nIf it is set to '0', no active memory overlay information is\nreturned but the number of all available active memory overlays\nfor the selected core.\n\\param num_active_overlays [out] : Number of returned active memory overlays. In case the input\nvalue of \\c num_active_overlays is '0', this is the number of\nall available active memory overlays for the selected core.\n\\param active_overlays     [out] : Active memory overlay information. This is an array allocated\nby the calling function.\n\n\\return Return code (\\c mcd_return_et).\n\n\\par Allowed error codes:\n\\c MCD_ERR_NONE         if successful.\\n\n\\c MCD_ERR_OVERLAYS     if retrieving active memory overlay information failed."] pub unsafe fn mcd_qry_active_overlays_f (& self , core : * const mcd_core_st , start_index : u32 , num_active_overlays : * mut u32 , active_overlays : * mut u32) -> mcd_return_et { (self . mcd_qry_active_overlays_f . as_ref () . expect ("Expected function, got error.")) (core , start_index , num_active_overlays , active_overlays) } # [doc = "  \\brief Function querying the register groups defined for a particular component.\n\n\n\nThere can be various register groups defined for a core depending on its\narchitecture. This function queries information about these register groups.\n\nThe parameter \\c num_reg_groups is used as an input/output parameter.\nAs input parameter it is set to the desired number of register groups. As\noutput parameter it set to the actual number of register groups information\nis returned for in \\c reg_groups.\nIf the target does not define any register groups, it is assumed that a\nvirtual register group with ID 0 exists which contains all registers of the\ncorresponding component. Then the information about this default 'virtual'\nregister group has to be sent back as only register group information.\n\n\\param core           [in]  : A reference to the core the calling function addresses.\n\\param start_index    [in]  : Start index of the requested register groups. This refers\nto an internal list of the target side implementation.\n\\param num_reg_groups [in]  : Number of register groups, information is requested of. If\nit is set to '0', no register groups information is\nreturned but the number of all available register groups\nfor the selected core.\n\\param num_reg_groups [out] : Number of returned register groups. In case the input\nvalue of \\c num_reg_groups is '0', this is the number of\nall available register groups for the selected core.\n\\param reg_groups     [out] : Register group information. This is an array allocated\nby the calling function.\n\n\\return Return code (\\c mcd_return_et).\n\n\\par Allowed error codes:\n\\c MCD_ERR_NONE              if successful.\\n\n\\c MCD_ERR_NO_REG_GROUPS     if no register groups are defined for this core."] pub unsafe fn mcd_qry_reg_groups_f (& self , core : * const mcd_core_st , start_index : u32 , num_reg_groups : * mut u32 , reg_groups : * mut mcd_register_group_st) -> mcd_return_et { (self . mcd_qry_reg_groups_f . as_ref () . expect ("Expected function, got error.")) (core , start_index , num_reg_groups , reg_groups) } # [doc = "  \\brief Function querying the register information of a particular register group.\n\nThere can be various register groups defined for a core depending on its architecture.\nWithin each register group there can be many registers. This function allows the user\nto query information about the registers contained within a register group. Information\nall registers which have to be exposed to the debug environment have to be returned as\na result of such a query.\n\n\\param core          [in]  : A reference to the core the calling function addresses.\n\\param reg_group_id  [in]  : ID of the register group detailed register information\nis requested for.\n\\param start_index   [in]  : Start index of the requested registers. This refers to\nan internal list of the target side implementation.\n\\param num_regs      [in]  : Number of registers, information is requested of. If it\nis set to '0', no register information is returned but\nthe number of all available registers within for the\nselected register group.\n\\param num_regs      [out] : Number of returned registers. In case the input value\nof \\c num_regs is '0', this is the number of all\navailable register for the selected register group.\n\\param reg_info      [out] : Register information. This is an array allocated by the\ncalling function.\n\n\\return Return code (\\c mcd_return_et).\n\n\\par Allowed error codes:\n\\c MCD_ERR_NONE             if successful.\\n\n\\c MCD_ERR_REG_GROUP_ID     if no register group with this ID is available for this core."] pub unsafe fn mcd_qry_reg_map_f (& self , core : * const mcd_core_st , reg_group_id : u32 , start_index : u32 , num_regs : * mut u32 , reg_info : * mut mcd_register_info_st) -> mcd_return_et { (self . mcd_qry_reg_map_f . as_ref () . expect ("Expected function, got error.")) (core , reg_group_id , start_index , num_regs , reg_info) } # [doc = "  \\brief Function querying the component registers of a compound register.\n\nRegisters within a target component may be composed of several simple registers.\nThese are by definition called \"compound registers\". This function allows a user\nto query information about the registers contained within a particular compound\nregister.\n\n\\param core            [in]  : A reference to the core the calling function addresses.\n\\param compound_reg_id [in]  : ID of the compound register component register IDs are\nqueried for.\n\\param start_index     [in]  : Start index of the requested component registers. This\nrefers to an internal list of the target side implementation.\n\\param num_reg_ids     [in]  : Number of component registers the ID is requested of.\nIf it is set to '0', no component register IDs are returned\nbut the number of all available component register for\nthe selected compound register.\n\\param num_reg_ids     [out] : Number of returned component registers. In case the input\nvalue of \\c num_reg_ids is '0', this is the number of all\navailable component registers for the selected compound\nregister.\n\\param reg_id_array    [out] : Component register IDs. This is an array allocated by the\ncalling function.\n\n\\return Return code (\\c mcd_return_et).\n\n\\par Allowed error codes:\n\\c MCD_ERR_NONE                  if successful.\\n\n\\c MCD_ERR_REG_NOT_COMPOUND      if no compound register with this ID is available for this core."] pub unsafe fn mcd_qry_reg_compound_f (& self , core : * const mcd_core_st , compound_reg_id : u32 , start_index : u32 , num_reg_ids : * mut u32 , reg_id_array : * mut u32) -> mcd_return_et { (self . mcd_qry_reg_compound_f . as_ref () . expect ("Expected function, got error.")) (core , compound_reg_id , start_index , num_reg_ids , reg_id_array) } # [doc = " \\brief Function querying information about trigger capabilities.\n\nThis function queries information about trigger capabilities implemented\nin a target.\n\n\\param core       [in]   : A reference to the core the calling function addresses.\n\\param trig_info  [out]  : Information about supported triggers.\n\n\\return Return code (\\c mcd_return_et).\n\n\\par Allowed error codes:\n\\c MCD_ERR_NONE        if successful.\\n\n\\c MCD_ERR_GENERAL     if trigger capabilities could not be retrieved."] pub unsafe fn mcd_qry_trig_info_f (& self , core : * const mcd_core_st , trig_info : * mut mcd_trig_info_st) -> mcd_return_et { (self . mcd_qry_trig_info_f . as_ref () . expect ("Expected function, got error.")) (core , trig_info) } # [doc = " \\brief Function querying information about custom triggers.\n\nThis function queries information about custom triggers of a component\nas well as the number of available custom triggers.\n\n\\param core        [in]  : A reference to the core the calling function addresses.\n\\param start_index [in]  : Start index of the requested custom triggers. This refers\nto an internal list of the target side implementation.\n\\param num_ctrigs  [in]  : Number of custom triggers, information is requested of.\nIf it is set to '0', no custom trigger information is\nreturned but the number of all available custom triggers\nfor the selected core.\n\\param num_ctrigs  [out] : Number of returned custom triggers. In case the input value\nof \\c num_ctrigs is '0', this is the number of all available\ncustom triggers for the selected core.\n\\param ctrig_info  [out] : Custom trigger information. This is an array allocated by the\ncalling function.\n\n\\return Return code (\\c mcd_return_et).\n\n\\par Allowed error codes:\n\\c MCD_ERR_NONE     if successful.\\n\n\\c MCD_ERR_PARAM    if custom trigger ID does not exist."] pub unsafe fn mcd_qry_ctrigs_f (& self , core : * const mcd_core_st , start_index : u32 , num_ctrigs : * mut u32 , ctrig_info : * mut mcd_ctrig_info_st) -> mcd_return_et { (self . mcd_qry_ctrigs_f . as_ref () . expect ("Expected function, got error.")) (core , start_index , num_ctrigs , ctrig_info) } # [doc = " \\brief Function allowing the creation of a new trigger.\n\nThis function allows a user to create a new trigger. If the exact trigger cannot be\ncreated, an approximate trigger is created instead and the \\c modified member of the\ntrigger structure is set.\n\nThe void pointer \\c trig usually points to a standard trigger structure like\n\\c mcd_trig_simple_core_st or \\ref mcd_trig_complex_core_st.\n\n\\param core        [in]  : A reference to the core the calling function addresses.\n\\param trig        [in]  : Pointer to the structure containing information about\nthe trigger object to be created.\n\\param trig        [out] : Members of the structure may be modified by the function.\nIn this case the \\c modified member of the trigger structure\nas well as the modified members are set.\n\\param trig_id     [out] : Unique ID for the newly created trigger returned by the API\nimplementation. A value of '0' indicates that the breakpoint\nis set, but cannot be identified by an ID. Removing such\nbreakpoints is only possible by calling \\ref mcd_remove_trig_set_f().\n\n\\return Return code (\\ref mcd_return_et).\n\n\\par Allowed error codes:\n\\c MCD_ERR_NONE          if successful.\\n\n\\c MCD_ERR_TRIG_CREATE   if trigger could not be created."] pub unsafe fn mcd_create_trig_f (& self , core : * const mcd_core_st , trig : * mut :: std :: os :: raw :: c_void , trig_id : * mut u32) -> mcd_return_et { (self . mcd_create_trig_f . as_ref () . expect ("Expected function, got error.")) (core , trig , trig_id) } # [doc = " \\brief Function querying the contents of a trigger.\n\nThis function allows the user to query the contents of a trigger.\nThe \\c max_trig_size parameter is set to the maximum size of\nthe trigger structure the user expects in bytes.\n\nThe void pointer \\c trig usually points to a standard trigger\nstructure like \\ref mcd_trig_simple_core_st or \\ref mcd_trig_complex_core_st.\n\n\\param core          [in]  : A reference to the core the calling function addresses.\n\\param trig_id       [in]  : ID of the trigger the user queries.\n\\param max_trig_size [in]  : Maximum size of the structure in bytes as expected by\nthe calling function.\n\\param trig          [out] : Pointer to the structure receiving the information about\nthe trigger object. The structure is allocated by the\ncalling function.\n\n\\return Return code (\\c mcd_return_et).\n\n\\par Allowed error codes:\n\\c MCD_ERR_NONE              if successful.\\n\n\\c MCD_ERR_RESULT_TOO_LONG   if requested trigger is larger than \\c max_trig_size.\\n\n\\c MCD_ERR_TRIG_ACCESS       if trigger could not be returned for any other reason."] pub unsafe fn mcd_qry_trig_f (& self , core : * const mcd_core_st , trig_id : u32 , max_trig_size : u32 , trig : * mut :: std :: os :: raw :: c_void) -> mcd_return_et { (self . mcd_qry_trig_f . as_ref () . expect ("Expected function, got error.")) (core , trig_id , max_trig_size , trig) } # [doc = " \\brief Function allowing a user to delete a particular trigger from a trigger set.\n\nThis function allows the user to delete a particular trigger from a trigger set.\n\n\\param core        [in] : A reference to the core the calling function addresses.\n\\param trig_id     [in] : ID of the trigger the user wants to delete.\n\n\\return Return code (\\c mcd_return_et).\n\n\\par Allowed error codes:\n\\c MCD_ERR_NONE              if successful.\\n\n\\c MCD_ERR_TRIG_ACCESS       if trigger could not be accessed for deletion."] pub unsafe fn mcd_remove_trig_f (& self , core : * const mcd_core_st , trig_id : u32) -> mcd_return_et { (self . mcd_remove_trig_f . as_ref () . expect ("Expected function, got error.")) (core , trig_id) } # [doc = " \\brief Function allowing a user to query the trigger states from the target.\n\nThis function allows a user to query the status of a single trigger.\nNote that \\ref mcd_qry_trig_set_state_f() needs to be called before to sample the trigger state.\n\n\\param core        [in]  : A reference to the core the calling function addresses.\n\\param trig_id     [in]  : ID of the trigger, the tool queries the state for.\n\\param trig_state  [out] : Queried Trigger state. The structure is allocated by\nthe calling function.\n\n\\return Return code (\\c mcd_return_et).\n\n\\par Allowed error codes:\n\\c MCD_ERR_NONE              if successful.\\n\n\\c MCD_ERR_TRIG_ACCESS       if trigger could not be accessed."] pub unsafe fn mcd_qry_trig_state_f (& self , core : * const mcd_core_st , trig_id : u32 , trig_state : * mut mcd_trig_state_st) -> mcd_return_et { (self . mcd_qry_trig_state_f . as_ref () . expect ("Expected function, got error.")) (core , trig_id , trig_state) } # [doc = " \\brief Function allowing a user to activat a trigger set on the target.\n\nThis function downloads the current trigger set to the hardware in order to activate\nit. If the trigger set is unchanged since the last call of this function, it will just\narm the triggers again.\n\nThis function is only needed to activate triggers on the fly (while the target is running)\nand in a consistent way - if supported by the target.\n\n\\param core       [in]  : A reference to the core the calling function addresses.\n\n\\return Return code (\\c mcd_return_et).\n\n\\par Allowed error codes:\n\\c MCD_ERR_NONE              if successful.\\n\n\\c MCD_ERR_TRIG_ACCESS       if trigger set could not be activated."] pub unsafe fn mcd_activate_trig_set_f (& self , core : * const mcd_core_st) -> mcd_return_et { (self . mcd_activate_trig_set_f . as_ref () . expect ("Expected function, got error.")) (core) } # [doc = " \\brief Function allowing a user to delete a trigger set.\n\nThis function allows a user to delete a trigger set for a particular core.\n\n\\param core           [in]  : A reference to the core the calling function addresses.\n\n\\return Return code (\\c mcd_return_et).\n\n\\par Allowed error codes:\n\\c MCD_ERR_NONE              if successful.\\n\n\\c MCD_ERR_TRIG_ACCESS       if trigger set could not be removed."] pub unsafe fn mcd_remove_trig_set_f (& self , core : * const mcd_core_st) -> mcd_return_et { (self . mcd_remove_trig_set_f . as_ref () . expect ("Expected function, got error.")) (core) } # [doc = " \\brief Function querying the contents of a trigger set.\n\nThis function queries information about the current state of the trigger set of a target core.\n\n\\param core             [in]     : A reference to the core the calling function addresses.\n\\param start_index      [in]     : Start index of the requested triggers. This refers to an\ninternal list of the target side implementation.\n\\param num_trigs        [in]     : The number of queried triggers starting from the defined\n\\c start_index. If it is set to '0', no triggers are\nreturned but the number of all available triggers of the\ntrigger set.\n\\param num_trigs        [out]    : The number of returned triggers. In case the input value\nof \\c num_trigs is '0', this is the number of all available\ntriggers of this core's trigger set.\n\\param trig_ids         [out]    : List of trigger IDs set in the target. This is an array\nallocated by the calling function.\n\n\\return Return code (\\c mcd_return_et).\n\n\\par Allowed error codes:\n\\c MCD_ERR_NONE              if successful.\\n\n\\c MCD_ERR_TRIG_ACCESS       if trigger set could not be queried."] pub unsafe fn mcd_qry_trig_set_f (& self , core : * const mcd_core_st , start_index : u32 , num_trigs : * mut u32 , trig_ids : * mut u32) -> mcd_return_et { (self . mcd_qry_trig_set_f . as_ref () . expect ("Expected function, got error.")) (core , start_index , num_trigs , trig_ids) } # [doc = " \\brief Function querying the state of a trigger set.\n\nThis function queries information about the current state of the trigger set of a target core.\nIt will consistently sample the state of all triggers in the set.\nThis is in particular necessary for Real HW targets.\nThe individual triggers can then be queried with \\ref mcd_qry_trig_state_f().\n\n\\param core        [in]  : A reference to the core the calling function addresses.\n\\param trig_state  [out] : Information about the current state of the trigger set.\n\n\\return Return code (\\c mcd_return_et).\n\n\\par Allowed error codes:\n\\c MCD_ERR_NONE              if successful.\\n\n\\c MCD_ERR_TRIG_ACCESS       if state of the trigger set could not be queried."] pub unsafe fn mcd_qry_trig_set_state_f (& self , core : * const mcd_core_st , trig_state : * mut mcd_trig_set_state_st) -> mcd_return_et { (self . mcd_qry_trig_set_state_f . as_ref () . expect ("Expected function, got error.")) (core , trig_state) } # [doc = " \\brief Function executing a transaction list on the target.\n\nThis function sends a transaction list to the target for execution and retrieves\nthe result. It is blocking, so it is the responsiblity of the tool to make sure\nthat the execution time will be reasonable by creating a transaction list with\nan appropriate payload size.\n\nNote that multiple tools can issue transaction lists requests to the same core at\nthe same time.\n\nIn case of an error, the execution of the transaction list is immediately aborted.\n\n\\param core      [in]  : A reference to the core the calling function addresses.\n\\param txlist    [in]  : A pointer to the transaction list for execution.\n\n\\return Return code (\\c mcd_return_et).\n\n\\par Allowed error codes:\n\\c MCD_ERR_NONE           if successful.\\n\n\\c MCD_ERR_TXLIST_READ    if execution of the transaction list aborted due to a specific read access.\\n\n\\c MCD_ERR_TXLIST_WRITE   if execution of the transaction list aborted due to a specific write access.\\n\n\\c MCD_ERR_TXLIST_TX      if execution of the transaction list aborted due to any other reason."] pub unsafe fn mcd_execute_txlist_f (& self , core : * const mcd_core_st , txlist : * mut mcd_txlist_st) -> mcd_return_et { (self . mcd_execute_txlist_f . as_ref () . expect ("Expected function, got error.")) (core , txlist) } # [doc = " \\brief Function starting execution on a particular core.\n\nThis function causes the corresponding target core to begin execution.\n\n\\param core           [in]  : A reference to the core the calling function addresses.\n\\param global         [in]  : Set to \"TRUE\" if all cores of a system shall start\nexecution. Otherwise, starting execution of selected\ncore only.\n\n\\return Return code (\\c mcd_return_et).\n\n\\par Allowed error codes:\n\\c MCD_ERR_NONE      if successful.\\n\n\\c MCD_ERR_GENERAL   if starting execution failed."] pub unsafe fn mcd_run_f (& self , core : * const mcd_core_st , global : mcd_bool_t) -> mcd_return_et { (self . mcd_run_f . as_ref () . expect ("Expected function, got error.")) (core , global) } # [doc = " \\brief Function stopping execution on a particular core.\n\nThis function causes the corresponding target core to stop execution.\n\n\\param core           [in]  : A reference to the core the calling function addresses.\n\\param global         [in]  : Set to \"TRUE\" if all cores of a system shall start\nexecution. Otherwise, starting execution of selected\ncore only.\n\n\\return Return code (\\c mcd_return_et).\n\n\\par Allowed error codes:\n\\c MCD_ERR_NONE      if successful.\\n\n\\c MCD_ERR_GENERAL   if stopping execution failed."] pub unsafe fn mcd_stop_f (& self , core : * const mcd_core_st , global : mcd_bool_t) -> mcd_return_et { (self . mcd_stop_f . as_ref () . expect ("Expected function, got error.")) (core , global) } # [doc = " \\brief Function running a particular core until a defined time.\n\nThis function causes the corresponding target core to run for a defined\ntime before it stops. If \\c absolute_time is \"FALSE\", \\c run_until_time\nis the value of the system timer that is associated with this core. This\nmeans it starts again from '0' for certain reset types, and it needs\nto be scaled depending on the crystal and PLL settings in order to determine\na time value.\nIf \\c absolute_time is \"TRUE\", \\c run_until_time is an absolute time\nin seconds. Usually, a simulation model can only support this case.\n\n\\param core           [in]  : A reference to the core the calling function addresses.\n\\param global         [in]  : Set to \"TRUE\" if all cores of a system shall start\nexecution. Otherwise, starting execution of selected\ncore only.\n\\param absolute_time  [in]  : Boolean value indicating whether the time parameter\nis absolute or not.\n\\param run_until_time [in]  : The number of time units (picoseconds) until which the\ntarget core shall run.\n\n\\return Return code (\\c mcd_return_et).\n\n\\par Allowed error codes:\n\\c MCD_ERR_NONE      if successful.\\n\n\\c MCD_ERR_GENERAL   if execution failed."] pub unsafe fn mcd_run_until_f (& self , core : * const mcd_core_st , global : mcd_bool_t , absolute_time : mcd_bool_t , run_until_time : u64) -> mcd_return_et { (self . mcd_run_until_f . as_ref () . expect ("Expected function, got error.")) (core , global , absolute_time , run_until_time) } # [doc = " \\brief Function querying the current time of execution from the target system.\n\nThis function returns the current execution time of the target.\n\n\\param core           [in]   : A reference to the core the calling function addresses.\n\\param current_time   [out]  : The current number of time units (picoseconds) the target\nsystem has been running.\n\n\\return Return code (\\c mcd_return_et).\n\n\\par Allowed error codes:\n\\c MCD_ERR_NONE      if successful.\\n\n\\c MCD_ERR_GENERAL   if querying for the time failed."] pub unsafe fn mcd_qry_current_time_f (& self , core : * const mcd_core_st , current_time : * mut u64) -> mcd_return_et { (self . mcd_qry_current_time_f . as_ref () . expect ("Expected function, got error.")) (core , current_time) } # [doc = " \\brief Function stepping a target core based on the particular step type.\n\nThis function causes the corresponding target core to step based on the provided\nstep type.\n\nNote that the function is blocking. It is the responsibility of the tool to call\nit with a reasonable number of steps.\n\n\\param core        [in]  : A reference to the core the calling function addresses.\n\\param global      [in]  : Set to \"TRUE\" if all cores of a system shall start\nexecution. Otherwise, starting execution of selected\ncore only.\n\\param step_type   [in]  : The unit, the stepping of the target core is based on.\n\\param n_steps     [in]  : The number of steps, the target core is stepped for.\n\n\\return Return code (\\c mcd_return_et).\n\n\\par Allowed error codes:\n\\c MCD_ERR_NONE      if successful.\\n\n\\c MCD_ERR_GENERAL   if stepping the target core failed."] pub unsafe fn mcd_step_f (& self , core : * const mcd_core_st , global : mcd_bool_t , step_type : mcd_core_step_type_et , n_steps : u32) -> mcd_return_et { (self . mcd_step_f . as_ref () . expect ("Expected function, got error.")) (core , global , step_type , n_steps) } # [doc = " \\brief Function enabling/disabling global stop and run activities on this core\n\nThis function enables or disables the effect of a global run and stop on this core.\nThe default state is target specific.\n\n\\param core        [in]  : A reference to the core the calling function addresses.\n\\param enable      [in]  : Set to \"TRUE\" if this core should perform global run or\nstop activities.\n\n\\return Return code (\\c mcd_return_et).\n\n\\par Allowed error codes:\n\\c MCD_ERR_NONE      if successful.\\n\n\\c MCD_ERR_GENERAL   if enabling/disabling the global effect of execution functions failed."] pub unsafe fn mcd_set_global_f (& self , core : * const mcd_core_st , enable : mcd_bool_t) -> mcd_return_et { (self . mcd_set_global_f . as_ref () . expect ("Expected function, got error.")) (core , enable) } # [doc = " \\brief Function querying the execution state of a target core.\n\nThis function queries the current execution state of a particular target core.\n\n\\param core         [in]  : A reference to the core the calling function addresses.\n\\param state        [out] : The current execution state of the target core.\n\n\\return Return code (\\c mcd_return_et).\n\n\\par Allowed error codes:\n\\c MCD_ERR_NONE      if successful.\\n\n\\c MCD_ERR_GENERAL   if querying the execution state failed."] pub unsafe fn mcd_qry_state_f (& self , core : * const mcd_core_st , state : * mut mcd_core_state_st) -> mcd_return_et { (self . mcd_qry_state_f . as_ref () . expect ("Expected function, got error.")) (core , state) } # [doc = " \\brief Function executing a command on the target platform.\n\nThis function sends a command to the target platform and retrieves the\nresult in the form of a string.\n\n\\param core               [in]  : A reference to the core the calling function addresses.\n\\param command_string     [in]  : The command string. This is implementation specific.\n\\param result_string_size [in]  : The maximum size of the result string.\n\\param result_string      [out] : The result string allocated by the calling function.\n\n\\return Return code (\\c mcd_return_et).\n\n\\par Allowed error codes:\n\\c MCD_ERR_NONE      if successful.\\n\n\\c MCD_ERR_GENERAL   if executing the command failed."] pub unsafe fn mcd_execute_command_f (& self , core : * const mcd_core_st , command_string : * const mcd_char_t , result_string_size : u32 , result_string : * mut mcd_char_t) -> mcd_return_et { (self . mcd_execute_command_f . as_ref () . expect ("Expected function, got error.")) (core , command_string , result_string_size , result_string) } # [doc = " \\brief Function querying information about reset classes supported by the target system.\n\nThis function queries all available reset classes of the target system. Each bit\nof \\c rst_class_vector represents an available reset class.\n\nIt is recommended that the strongest reset (e.g. power-on reset) is of class '0'.\n\n\\param core             [in]  : A reference to the core the calling function addresses.\n\\param rst_class_vector [out] : A 32 bit vector that defines the available reset classes.\n\n\\return Return code (\\c mcd_return_et).\n\n\\par Allowed error codes:\n\\c MCD_ERR_NONE      if successful.\\n\n\\c MCD_ERR_GENERAL   if querying the reset classes failed."] pub unsafe fn mcd_qry_rst_classes_f (& self , core : * const mcd_core_st , rst_class_vector : * mut u32) -> mcd_return_et { (self . mcd_qry_rst_classes_f . as_ref () . expect ("Expected function, got error.")) (core , rst_class_vector) } # [doc = " \\brief Function querying information about a particular reset class supported by the target system\n\nThis function queries more detailed information about a particular reset class\nof the target system.\n\n\\param core             [in]  : A reference to the core the calling function addresses.\n\\param rst_class        [in]  : Reset class ID which refers to a bit in the 32-bit reset\nclass vector as obtained by \\ref mcd_qry_rst_classes_f().\n\\param rst_info         [out] : Reference to an object of type \\ref mcd_rst_info_st\ncontaining detailed information about this reset class.\n\n\\return Return code (\\c mcd_return_et).\n\n\\par Allowed error codes:\n\\c MCD_ERR_NONE      if successful.\\n\n\\c MCD_ERR_PARAM     if reset class does not exist.\\n\n\\c MCD_ERR_GENERAL   if any other error occurred."] pub unsafe fn mcd_qry_rst_class_info_f (& self , core : * const mcd_core_st , rst_class : u8 , rst_info : * mut mcd_rst_info_st) -> mcd_return_et { (self . mcd_qry_rst_class_info_f . as_ref () . expect ("Expected function, got error.")) (core , rst_class , rst_info) } # [doc = " \\brief Function triggering one or more reset signals in parallel on the target system.\n\nThis function triggers one or more reset signals in parallel on the target system.\n\n\\param core             [in]  : A reference to the core the calling function addresses.\n\\param rst_class_vector [in]  : Reset vector specifying the resets which shall be issued.\n\\param rst_and_halt     [in]  : Optionally halting the core if the reset changes the core\nstate.\n\n\\return Return code (\\c mcd_return_et).\n\n\\par Allowed error codes:\n\\c MCD_ERR_NONE      if successful.\\n\n\\c MCD_ERR_PARAM     if one or several reset classes do not exist.\\n\n\\c MCD_ERR_GENERAL   if any other error occurred."] pub unsafe fn mcd_rst_f (& self , core : * const mcd_core_st , rst_class_vector : u32 , rst_and_halt : mcd_bool_t) -> mcd_return_et { (self . mcd_rst_f . as_ref () . expect ("Expected function, got error.")) (core , rst_class_vector , rst_and_halt) } # [doc = " \\brief Function opening a communication channel between the host tool and the target.\n\nThis function opens a defined communication channel between a host side tool and a target.\nThe addressed target is identified by a core reference.\nThis function call allows to establish a communication channel between the host side tool\nand any hierarchical level of the targeted system (i.e. at system level, at device level\nor at core level). For this reason, this function call accepts core structures which have\ntheir member \\c instance set to a null pointer for levels higher than core level. The target\nimplementation actually needs to determine the targeted hierarchical level based on the member\n\\c core_con_info of the core structure.\nThe established channel is described by \\c channel. Only a single debugger may be attached\nto a communication channel at a time.\n\n\\param core            [in]  : A reference to the targeted system, device or core. Here,\nmember \\c instance is allowed to be a null pointer for\nlevels higher than core level.\n\\param channel         [in]  : Requested channel setup.\n\\param channel         [out] : Accepted and at least for \\c chl_id modified channel setup.\nNote that \\c max_msg_len and \\c prio can be changed as well if\nthe requested values are not possible.\n\n\\return Return code (\\c mcd_return_et).\n\n\\par Allowed error codes:\n\\c MCD_ERR_NONE                      if successful.\\n\n\\c MCD_ERR_CHL_TYPE_NOT_SUPPORTED    if unsupported channel type was requested.\\n\n\\c MCD_ERR_CHL_TARGET_NOT_SUPPORTED  if addressed target does not support communication channels.\\n\n\\c MCD_ERR_CHL_SETUP                 if channel setup is invalid or contains unsupported attributes."] pub unsafe fn mcd_chl_open_f (& self , core : * const mcd_core_st , channel : * mut mcd_chl_st) -> mcd_return_et { (self . mcd_chl_open_f . as_ref () . expect ("Expected function, got error.")) (core , channel) } # [doc = " \\brief Function send a message using a specified communication channel.\n\nThis function sends a message using a defined communication channel between the host\nand the target.\n\n\\param core            [in]   : A reference to the targeted system, device or core. Here,\nmember \\c instance is allowed to be a null pointer for\nlevels higher than core level.\n\\param channel          [in]  : Description of the addressed communication channel.\n\\param msg_len          [in]  : The number of bytes sent with this message.\n\\param msg              [in]  : Message buffer.\n\n\\return Return code (\\c mcd_return_et).\n\n\\par Allowed error codes:\n\\c MCD_ERR_NONE                if successful.\\n\n\\c MCD_ERR_CHL_MESSAGE_FAILED  if sending the message failed."] pub unsafe fn mcd_send_msg_f (& self , core : * const mcd_core_st , channel : * const mcd_chl_st , msg_len : u32 , msg : * const u8) -> mcd_return_et { (self . mcd_send_msg_f . as_ref () . expect ("Expected function, got error.")) (core , channel , msg_len , msg) } # [doc = " \\brief Function receiving a message using a specified communication channel.\n\nThis function receives a message using a defined communication channel between the host\nand the target.\n\n\\param core            [in]  : A reference to the targeted system, device or core. Here,\nfor member \\c instance is allowed to be a null pointer for\nlevels higher than core level.\n\\param channel         [in]  : Description of the addressed communication channel.\n\\param timeout         [in]  : Number of time units (milliseconds) until function call times out.\n\\param msg_len         [in]  : Maximum number of bytes that can be fetched with this call.\n\\param msg_len         [out] : Number of bytes that have been actually fetched with this call.\n\\param msg             [out] : Message buffer.\n\n\\return Return code (\\c mcd_return_et).\n\n\\par Allowed error codes:\n\\c MCD_ERR_NONE                if successful.\\n\n\\c MCD_ERR_CHL_MESSAGE_FAILED  if receiving of the message failed."] pub unsafe fn mcd_receive_msg_f (& self , core : * const mcd_core_st , channel : * const mcd_chl_st , timeout : u32 , msg_len : * mut u32 , msg : * mut u8) -> mcd_return_et { (self . mcd_receive_msg_f . as_ref () . expect ("Expected function, got error.")) (core , channel , timeout , msg_len , msg) } # [doc = " \\brief Function resetting a specified communication channel.\n\nThis function resets a communication channel between the host and the target.\nThis allows the communication to be setup again e.g. if the communication hangs.\n\n\\param core            [in] : A reference to the targeted system, device or core.\nHere, member \\c instance is allowed to be a null\npointer for levels higher than core level.\n\\param channel         [in] : Description of the addressed communication channel.\n\n\\return Return code (\\c mcd_return_et).\n\n\\par Allowed error codes:\n\\c MCD_ERR_NONE       if successful.\\n\n\\c MCD_ERR_GENERAL    if resetting the communication channel failed."] pub unsafe fn mcd_chl_reset_f (& self , core : * const mcd_core_st , channel : * const mcd_chl_st) -> mcd_return_et { (self . mcd_chl_reset_f . as_ref () . expect ("Expected function, got error.")) (core , channel) } # [doc = " \\brief Function closing a specified communication channel.\n\nThis function closes a communication channel between the host and the target.\n\n\\param core            [in] : A reference to the targeted system, device or core.\nHere, member \\c instance is allowed to be a null\npointer for levels higher than core level.\n\\param channel         [in] : Description of the addressed communication channel.\n\n\\return Return code (\\c mcd_return_et).\n\n\\par Allowed error codes:\n\\c MCD_ERR_NONE       if successful.\\n\n\\c MCD_ERR_GENERAL    if closing the communication channel failed."] pub unsafe fn mcd_chl_close_f (& self , core : * const mcd_core_st , channel : * const mcd_chl_st) -> mcd_return_et { (self . mcd_chl_close_f . as_ref () . expect ("Expected function, got error.")) (core , channel) } # [doc = " \\brief Function querying information about available traces for a core.\n\n\\param core             [in]  : A reference to the core of which the traces are requested.\n\\param start_index      [in]  : Start index of the requested traces. This refers to an\ninternal list of the target side implementation.\n\\param num_traces       [in]  : The number of queried traces starting from the defined\n\\c start_index. If it is set to '0', no traces are returned\nbut the number of all available traces.\n\\param num_traces       [out] : The number of returned traces. In case the input value of\n\\c num_traces is '0', this is the number of all available\ntraces for the selected core.\n\\param trace_info       [out] : Trace information of the requested traces. This is an array\nallocated by the calling function.\n\n\\return Return code (\\c mcd_return_et).\n\n\\par Allowed error codes:\n\\c MCD_ERR_NONE       if successful.\\n\n\\c MCD_ERR_PARAM      if \\c trace_index is equal or larger than the number of traces.\\n\n\\c MCD_ERR_GENERAL    on any other error."] pub unsafe fn mcd_qry_traces_f (& self , core : * const mcd_core_st , start_index : u32 , num_traces : * mut u32 , trace_info : * mut mcd_trace_info_st) -> mcd_return_et { (self . mcd_qry_traces_f . as_ref () . expect ("Expected function, got error.")) (core , start_index , num_traces , trace_info) } # [doc = " \\brief Function querying the status of a trace.\n\nThis function queries the current status of a particular trace source.\n\n\\param core             [in]  : A reference to the core to which the trace belongs.\n\\param trace_id         [in]  : ID to which this trace refers to.\n\\param state            [out] : The current state of the trace.\n\n\\return Return code (\\c mcd_return_et).\n\n\\par Allowed error codes:\n\\c MCD_ERR_NONE       if successful.\\n\n\\c MCD_ERR_PARAM      if \\c trace_id is not a valid trace ID.\\n\n\\c MCD_ERR_GENERAL    on any other error."] pub unsafe fn mcd_qry_trace_state_f (& self , core : * const mcd_core_st , trace_id : u32 , state : * mut mcd_trace_state_st) -> mcd_return_et { (self . mcd_qry_trace_state_f . as_ref () . expect ("Expected function, got error.")) (core , trace_id , state) } # [doc = " \\brief Function setting the state and mode of a trace.\n\nThis function sets the state and mode of a particular trace source.\n\n\\param core         [in]  : A reference to the core to which the trace belongs.\n\\param trace_id     [in]  : ID of the trace which is referenced.\n\\param state        [in]  : The trace settings to be applied.\n\\param state        [out] : Returns the current state of the trace. Member\n\\c modified is set if a member has changed.\n\n\\return Return code (\\c mcd_return_et).\n\n\\par Allowed error codes:\n\\c MCD_ERR_NONE       if successful.\\n\n\\c MCD_ERR_PARAM      if \\c trace_id is not a valid trace ID.\\n\n\\c MCD_ERR_GENERAL    on any other error."] pub unsafe fn mcd_set_trace_state_f (& self , core : * const mcd_core_st , trace_id : u32 , state : * mut mcd_trace_state_st) -> mcd_return_et { (self . mcd_set_trace_state_f . as_ref () . expect ("Expected function, got error.")) (core , trace_id , state) } # [doc = " \\brief Function reading trace data from a trace.\n\nThis function reads trace data from a particular trace source.\n\n\\param core             [in]     : A reference to the core to which the trace belongs.\n\\param trace_id         [in]     : ID of the trace which is referenced.\n\\param start_index      [in]     : Start index of frame to read (0 = oldest frame).\nThis refers to an internal list of the target\nimplementation which stores the trace frames.\n\\param num_frames       [in]     : The number of queried trace frames starting from\nthe defined \\c start_index. If it is set to '0',\nno trace data is returned but the number of all\ncurrently available trace frames.\n\\param num_frames       [out]    : The number of read trace frames. In case the input\nvalue of \\c num_frames is '0', this is the number\nof all currently available trace frames.\n\\param trace_data_size  [in]     : Size of one trace data frame in bytes (for type checking).\n\\param trace_data       [out]    : Array of trace data structures filled by this function.\nThe format depends on the trace source. Standard formats\nare \\ref mcd_trace_data_core_st, \\ref mcd_trace_data_event_st\nand \\ref mcd_trace_data_stat_st.\n\n\\return Return code (\\c mcd_return_et).\n\n\\par Allowed error codes:\n\\c MCD_ERR_NONE       if successful.\\n\n\\c MCD_ERR_PARAM      if \\c trace_id is not a valid trace ID, or if start_index is larger\nthan the number of available trace frames.\\n\n\\c MCD_ERR_GENERAL    on any other error."] pub unsafe fn mcd_read_trace_f (& self , core : * const mcd_core_st , trace_id : u32 , start_index : u64 , num_frames : * mut u32 , trace_data_size : u32 , trace_data : * mut :: std :: os :: raw :: c_void) -> mcd_return_et { (self . mcd_read_trace_f . as_ref () . expect ("Expected function, got error.")) (core , trace_id , start_index , num_frames , trace_data_size , trace_data) } }